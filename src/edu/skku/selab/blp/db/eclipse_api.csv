id,class_url,description
1,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/ListenerList.html,extends Object This class is a thread safe list that is designed for storing lists of listeners.  The implementation is optimized for minimal memory footprint_ frequent reads   and infrequent writes. Modification of the list is synchronized and relatively  expensive_ while accessing the listeners is very fast. Readers are given access   to the underlying array data structure for reading_ with the trust that they will   not modify the underlying array.    A listener list handles the same listener being added   multiple times_ and tolerates removal of listeners that are the same as other  listeners in the list. For this purpose_ listeners can be compared with each other   using either equality or identity_ as specified in the list constructor.      Use the getListeners method when notifying listeners. The recommended  code sequence for notifying all registered listeners of say_  FooListener.eventHappened_ is:      Object[] listeners = myListenerList.getListeners();  for (int i = 0; i < listeners.length; ++i) {  ((FooListener) listeners[i]).eventHappened(event);  }        This class can be used without OSGi running.    Since:  org.eclipse.equinox.common 3.2    
2,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IStatus.html,A status object represents the outcome of an operation.  All CoreExceptions carry a status object to indicate   what went wrong. Status objects are also returned by methods needing   to provide details of failures (e.g._ validation methods).    A status carries the following information:    plug-in identifier (required)  severity (required)  status code (required)  message (required) - localized to current locale  exception (optional) - for problems stemming from a failure at  a lower level  Some status objects_ known as multi-statuses_ have other status objects   as children.      The class Status is the standard public implementation  of status objects; the subclass MultiStatus is the  implements multi-status objects.    This interface can be used without OSGi running.    See Also:  MultiStatus_  Status    
3,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IProgressMonitor.html,The IProgressMonitor interface is implemented  by objects that monitor the progress of an activity; the methods  in this interface are invoked by code that performs the activity.    All activity is broken down into a linear sequence of tasks against  which progress is reported. When a task begins_ a beginTask(String_ int)  notification is reported_ followed by any number and mixture of   progress reports (worked()) and subtask notifications   (subTask(String)). When the task is eventually completed_ a   done() notification is reported. After the done()  notification_ the progress monitor cannot be reused; i.e._   beginTask(String_ int) cannot be called again after the call to   done().      A request to cancel an operation can be signaled using the   setCanceled method. Operations taking a progress  monitor are expected to poll the monitor (using isCanceled)  periodically and abort at their earliest convenience. Operation can however   choose to ignore cancelation requests.      Since notification is synchronous with the activity itself_ the listener should   provide a fast and robust implementation. If the handling of notifications would   involve blocking operations_ or operations which might throw uncaught exceptions_   the notifications should be queued_ and the actual processing deferred (or perhaps  delegated to a separate thread).    This interface can be used without OSGi running.    Clients may implement this interface.      
4,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdaptable.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    "
5,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IUndoContext.html," An undo context is used to ""tag"" operations as being applicable to a certain  context. The undo context is used to filter the history of operations  available for undo or redo so that only operations appropriate for a given  undo context are shown when the application is presenting that context.      The scope of an undo context is defined by the application that is making  undo and redo of operations available. Undo contexts may be related to  application models_ or may be associated with UI objects that are providing  undo and redo support.      An undo context may be defined as ""matching"" another context. This allows  applications to provide specialized implementations of an undo context that  will appear in the operation history for their matching context.  Since:  3.1    "
6,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IObservable.html,An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
7,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IObservableCollection.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    "
8,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/Realm.html,extends Object A realm defines a context from which objects implementing IObservable  must be accessed_ and on which these objects will notify their listeners. To  bridge between observables from different realms_ subclasses of  Binding can be used.    A block of code is said to be executing within a realm if calling  isCurrent() from that block returns true. Code reached by calling  methods from that block will execute within the same realm_ with the  exception of methods on this class that can be used to execute code within a  specific realm. Clients can use syncExec(Runnable)_  asyncExec(Runnable)_ or exec(Runnable) to execute a  runnable within this realm. Note that using syncExec(Runnable) can  lead to deadlocks and should be avoided if the current thread holds any  locks.      It is instructive to think about possible implementations of Realm: It can be  based on executing on a designated thread such as a UI thread_ or based on  holding a lock. In the former case_ calling syncExec on a realm that is not  the current realm will execute the given runnable on a different thread (the  designated thread). In the latter case_ calling syncExec may execute the  given runnable on the calling thread_ but calling  asyncExec(Runnable) will execute the given runnable on a different  thread. Therefore_ no assumptions can be made about the thread that will  execute arguments to asyncExec(Runnable)_  syncExec(Runnable)_ or exec(Runnable).      It is possible that a block of code is executing within more than one realm.  This can happen for implementations of Realm that are based on holding a lock  but don't use a separate thread to run runnables given to  syncExec(Runnable). Realm implementations of this kind should be  appropriately documented because it increases the opportunity for deadlock.      Some implementations of IObservable provide constructors which do not  take a Realm argument and are specified to create the observable instance  with the current default realm. The default realm can be set for the  currently executing thread by using runWithDefault(Realm_ Runnable).  Note that the default realm does not have to be the current realm.      Subclasses must override at least one of asyncExec()/syncExec(). For realms  based on a designated thread_ it may be easier to implement asyncExec and  keep the default implementation of syncExec. For realms based on holding a  lock_ it may be easier to implement syncExec and keep the default  implementation of asyncExec.    Since:  1.0  See Also:  IObservable    
9,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/MultiStatus.html,"A status object represents the outcome of an operation.  All CoreExceptions carry a status object to indicate   what went wrong. Status objects are also returned by methods needing   to provide details of failures (e.g._ validation methods).    A status carries the following information:    plug-in identifier (required)  severity (required)  status code (required)  message (required) - localized to current locale  exception (optional) - for problems stemming from a failure at  a lower level  Some status objects_ known as multi-statuses_ have other status objects   as children.      The class Status is the standard public implementation  of status objects; the subclass MultiStatus is the  implements multi-status objects.    This interface can be used without OSGi running.    See Also:  MultiStatus_  Status    
extends Status A concrete multi-status implementation_   suitable either for instantiating or subclassing.    This class can be used without OSGi running.      "
10,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/DisposeEvent.html,extends ObservableEvent Event denoting that an IObservable object was disposed.  Since:  1.2  See Also:  Serialized Form    
11,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/IObservableList.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    
extends List_ IObservableCollection A list whose changes can be tracked by list change listeners.  Since:  1.0  See Also:  AbstractObservableList_  ObservableList  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the framework classes  that implement this interface. Note that direct implementers of  this interface outside of the framework will be broken in future  releases when methods are added to this interface.    "
12,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/list/IListProperty.html,extends IProperty Interface for list-typed properties.  Since:  1.2  See Also:  ListProperty_  SimpleListProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
13,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/value/IValueProperty.html,extends IProperty Interface for value-typed properties  Since:  1.2  See Also:  ValueProperty_  SimpleValueProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
14,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/conversion/IConverter.html,A one-way converter.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should subclass Converter.  Restriction:  This interface is not intended to be extended by clients.    
15,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/IObservableValue.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable A value whose changes can be tracked by value change listeners.  Since:  1.0  See Also:  AbstractObservableValue  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    "
16,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/IObservableSet.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    
extends Set_ IObservableCollection A set whose changes can be tracked by set change listeners.  Since:  1.0  See Also:  AbstractObservableSet_  ObservableSet  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    "
17,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/IObservableMap.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends Map_ IObservable Observable Map.  Since:  1.1  See Also:  AbstractObservableMap_  ObservableMap  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    "
18,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/ListDiff.html,extends Object implements IDiff Object describing a diff between two lists.  Since:  1.0    
19,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/SetDiff.html,extends Object implements IDiff  Since:  1.0    
20,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/validation/IValidator.html,A validator. This validator is responsible for determining if a given value  is valid. Validators can be used on target or model values. For example_ a  String2IntValidator would only accept source Strings that can successfully be  converted to an integer value_ and a PositiveIntegerValidator would only  accept positive integers.  Since:  1.0    
21,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/framework/log/FrameworkLog.html,The FramworkLog interface. A FrameworkLog implementation is provided by the  FrameworkAdaptor and used by the Framework to log any error messages and  FrameworkEvents of type ERROR. The FrameworkLog may persist the log messages   to the filesystem or allow other ways of accessing the log information.  Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.    
22,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/framework/log/FrameworkLogEntry.html,extends Object A framework log entry used to log information to a FrameworkLog  Since:  3.1  Restriction:  This class is not intended to be subclassed by clients.    
23,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/INativePropertyListener.html,"A listener capable of adding or removing itself as a listener on a source  object using the source's ""native"" listener API. Events received from the  source objects are parlayed to the ISimplePropertyListener provided  to the method that constructed this native listener instance.  Since:  1.2  See Also:  NativePropertyListener_  SimpleValueProperty.adaptListener(ISimplePropertyListener)_  SimpleListProperty.adaptListener(ISimplePropertyListener)_  SimpleSetProperty.adaptListener(ISimplePropertyListener)_  SimpleMapProperty.adaptListener(ISimplePropertyListener)    "
24,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/ISimplePropertyListener.html,Listener for changes to properties on a particular source object  Since:  1.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
25,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/MapDiff.html,extends Object implements IDiff  Since:  1.1    
26,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/WritableList.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    
extends List_ IObservableCollection A list whose changes can be tracked by list change listeners.  Since:  1.0  See Also:  AbstractObservableList_  ObservableList  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the framework classes  that implement this interface. Note that direct implementers of  this interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends ObservableList Mutable observable list backed by an ArrayList.      This class is thread safe. All state accessing methods must be invoked from  the current realm. Methods for adding and removing  listeners may be invoked from any thread.    Since:  1.0    "
27,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/Binding.html,extends ValidationStatusProvider This abstract class represents a binding between a model and a target. Newly  created instances need to be added to a data binding context using  init(DataBindingContext).  Since:  1.0    
28,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IChangeListener.html,extends IObservablesListener Listener for generic change events. Note that the change events do not carry  information about the change_ they only specify the affected observable. To  listen for specific change events_ use more specific change listeners.  Since:  1.0  See Also:  IValueChangeListener_  IListChangeListener_  ISetChangeListener_  IMapChangeListener    
29,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/IMapChangeListener.html,extends IObservablesListener Listener for changes to observable maps.  Since:  1.0    
30,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/set/ISetProperty.html,extends IProperty Interface for set-typed properties  Since:  1.2  See Also:  SetProperty_  SimpleSetProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
31,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/map/IMapProperty.html,extends IProperty Interface for map-typed properties  Since:  1.2  See Also:  MapProperty_  SimpleMapProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
32,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/masterdetail/IObservableFactory.html,Generates an IObservable when passed a target instance.  Since:  1.0    
33,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/beans/IBeanProperty.html,extends IProperty An IProperty extension interface providing access to details of bean  properties.  Since:  1.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
34,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/beans/IBeanListProperty.html,"extends IProperty An IProperty extension interface providing access to details of bean  properties.  Since:  1.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
extends IProperty Interface for list-typed properties.  Since:  1.2  See Also:  ListProperty_  SimpleListProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends IBeanProperty_ IListProperty An IListProperty extension interface with convenience methods for  creating nested bean properties.  Since:  1.2    "
35,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/beans/IBeanValueProperty.html,"extends IProperty An IProperty extension interface providing access to details of bean  properties.  Since:  1.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
extends IProperty Interface for value-typed properties  Since:  1.2  See Also:  ValueProperty_  SimpleValueProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends IBeanProperty_ IValueProperty An IValueProperty extension interface with convenience methods for  creating nested bean properties.  Since:  1.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
36,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/beans/IBeanMapProperty.html,"extends IProperty An IProperty extension interface providing access to details of bean  properties.  Since:  1.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
extends IProperty Interface for map-typed properties  Since:  1.2  See Also:  MapProperty_  SimpleMapProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends IBeanProperty_ IMapProperty An IMapProperty extension interface with convenience methods for  creating nested bean properties.  Since:  1.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
37,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/beans/IBeanSetProperty.html,"extends IProperty An IProperty extension interface providing access to details of bean  properties.  Since:  1.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
extends IProperty Interface for set-typed properties  Since:  1.2  See Also:  SetProperty_  SimpleSetProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends IBeanProperty_ ISetProperty An ISetProperty extension interface with convenience methods for  creating nested bean properties.  Since:  1.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
38,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/ValueDiff.html,extends Object implements IDiff  Since:  1.0    
39,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/ListDiffEntry.html,extends Object A single addition of an element to a list or removal of an element from a list.  Since:  1.0    
40,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IStaleListener.html,extends IObservablesListener Listener for staleness events. An observable object is stale if its state  will change eventually.  Since:  1.0    
41,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IDisposeListener.html,extends IObservablesListener Listener for dispose events. An observable object is disposed if its  IObservable.dispose() method has been called.  Since:  1.2    
42,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/StaleEvent.html,extends ObservableEvent Generic event denoting that the state of an IObservable object is  about to change. Note that this event is only fired when an observable  becomes stale_ not when it becomes unstale; an observable that becomes  unstale should always fire a change event. Staleness can be used (for  example) to notify listeners when an observable has started a background  thread for updating its state. Clients can safely ignore staleness.  Since:  1.0  See Also:  IObservable.isStale()_  Serialized Form    
43,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/ISetChangeListener.html,extends IObservablesListener Listener for changes to observable sets.  Since:  1.0    
44,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/IListChangeListener.html,extends IObservablesListener Listener for changes to observable lists.  Since:  1.0    
45,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/ValueChangeEvent.html,extends ObservableEvent Value change event describing a change of an IObservableValue  object's current value.  Since:  1.0  See Also:  Serialized Form    
46,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/ISafeRunnable.html,Safe runnables represent blocks of code and associated exception  handlers. They are typically used when a plug-in needs to call some  untrusted code (e.g._ code contributed by another plug-in via an  extension).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  SafeRunner.run(ISafeRunnable)    
47,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/IValueChangeListener.html,extends IObservablesListener Listener for changes to observable values.  Since:  1.0    
48,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/list/IListProperty.html#observe(org.eclipse.core.databinding.observable.Realm_ java.lang.Object),extends IProperty Interface for list-typed properties.  Since:  1.2  See Also:  ListProperty_  SimpleListProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
49,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/list/SimpleListProperty.html,"extends IProperty Interface for list-typed properties.  Since:  1.2  See Also:  ListProperty_  SimpleListProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends ListProperty Simplified abstract implementation of IListProperty. This class takes care of  most of the functional requirements for an IListProperty implementation_  leaving only the property-specific details to subclasses.    Subclasses must implement these methods:    IListProperty.getElementType()    doGetList(Object)    doSetList(Object_ List_ ListDiff)    adaptListener(ISimplePropertyListener)      In addition_ we recommended overriding Object.toString() to return a  description suitable for debugging purposes.  Since:  1.2    "
50,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/SimplePropertyEvent.html,extends EventObject Event object events in the properties API  Since:  1.2  See Also:  Serialized Form    
51,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/map/IMapProperty.html#observe(org.eclipse.core.databinding.observable.Realm_ java.lang.Object),extends IProperty Interface for map-typed properties  Since:  1.2  See Also:  MapProperty_  SimpleMapProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
52,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/map/SimpleMapProperty.html,"extends IProperty Interface for map-typed properties  Since:  1.2  See Also:  MapProperty_  SimpleMapProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends MapProperty Simplified abstract implementation of IMapProperty. This class takes care of  most of the functional requirements for an IMapProperty implementation_  leaving only the property-specific details to subclasses.    Subclasses must implement these methods:    IMapProperty.getKeyType()    IMapProperty.getValueType()    doGetMap(Object)    doSetMap(Object_ Map_ MapDiff)    adaptListener(ISimplePropertyListener)      In addition_ we recommended overriding Object.toString() to return a  description suitable for debugging purposes.  Since:  1.2    "
53,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/set/ISetProperty.html#observe(org.eclipse.core.databinding.observable.Realm_ java.lang.Object),extends IProperty Interface for set-typed properties  Since:  1.2  See Also:  SetProperty_  SimpleSetProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
54,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/set/SimpleSetProperty.html,"extends IProperty Interface for set-typed properties  Since:  1.2  See Also:  SetProperty_  SimpleSetProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends SetProperty Simplified abstract implementation of ISetProperty. This class takes care of  most of the functional requirements for an ISetProperty implementation_  leaving only the property-specific details to subclasses.    Subclasses must implement these methods:    ISetProperty.getElementType()    doGetSet(Object)    doSetSet(Object_ Set_ SetDiff)    adaptListener(ISimplePropertyListener)      In addition_ we recommended overriding Object.toString() to return a  description suitable for debugging purposes.  Since:  1.2    "
55,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/value/DelegatingValueProperty.html,"extends IProperty Interface for value-typed properties  Since:  1.2  See Also:  ValueProperty_  SimpleValueProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends ValueProperty  Since:  1.2    "
56,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/SetChangeEvent.html,extends ObservableEvent List change event describing an incremental change of an  IObservableSet object.  Since:  1.0  See Also:  Serialized Form    
57,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/value/SimpleValueProperty.html,"extends IProperty Interface for value-typed properties  Since:  1.2  See Also:  ValueProperty_  SimpleValueProperty  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends ValueProperty Simplified abstract implementation of IValueProperty. This class takes care  of most of the functional requirements for an IValueProperty implementation_  leaving only the property-specific details to subclasses.    Subclasses must implement these methods:    IValueProperty.getValueType()    doGetValue(Object)    doSetValue(Object_ Object)    adaptListener(ISimplePropertyListener)      In addition_ we recommended overriding Object.toString() to return a  description suitable for debugging purposes.  Since:  1.2    "
58,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/core/contexts/IEclipseContext.html,"A context is used to isolate application code from its dependencies on an application framework  or container. This helps avoid building in dependencies on a specific framework that inhibit  reuse of the application code. Fundamentally a context supplies values (either data objects or  services)_ and allows values to be set. Typically a client will be provided values  from a context through injection_ removing the need for clients to even depend on this interface.    While a context appears superficially to be a Map_ it may in fact compute values for requested  keys dynamically rather than simply retrieving a stored value.      Contexts may have a parent context_ and may delegate lookup of a value to their parent. Whether a  value is computed or stored in this context or a parent context is an implementation detail that  clients need not be concerned with. The content of parent contexts cannot be modified by a child  context.      Contexts may have child contexts. Children inherit context values from their parent  as described earlier. At any time_ one of the children may be considered the active  child. The interpretation of what active means depends on the domain in which the context  is used.    Like maps_ values are stored in the context based on keys. Two types of keys can be used: strings   and classes. When classes are used to access objects in the context_ keys are calculated based on   the class name_ so the value stored for the class String can be retrieved   using the key value of ""java.lang.String"".     Since:  1.3  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
59,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ICategoryListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of Category.    This interface may be implemented by clients.    Since:  3.1  See Also:  Category.addCategoryListener(ICategoryListener)_  Category.removeCategoryListener(ICategoryListener)    
60,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ICommandListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of Command.    This interface may be implemented by clients.    Since:  3.1  See Also:  Command.addCommandListener(ICommandListener)_  Command.removeCommandListener(ICommandListener)    
61,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IParameterTypeListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of ParameterType.    This interface may be implemented by clients.    Since:  3.2  See Also:  ParameterType.addListener(IParameterTypeListener)_  ParameterType.removeListener(IParameterTypeListener)    
62,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/CommandManager.html,"An instance of this interface can be used by clients to receive notification  of changes to one or more instances of Category.    This interface may be implemented by clients.    Since:  3.1  See Also:  Category.addCategoryListener(ICategoryListener)_  Category.removeCategoryListener(ICategoryListener)    
An instance of this interface can be used by clients to receive notification  of changes to one or more instances of Command.    This interface may be implemented by clients.    Since:  3.1  See Also:  Command.addCommandListener(ICommandListener)_  Command.removeCommandListener(ICommandListener)    
An instance of this interface can be used by clients to receive notification  of changes to one or more instances of ParameterType.    This interface may be implemented by clients.    Since:  3.2  See Also:  ParameterType.addListener(IParameterTypeListener)_  ParameterType.removeListener(IParameterTypeListener)    
extends HandleObjectManager implements ICategoryListener_ ICommandListener_ IParameterTypeListener  A central repository for commands -- both in the defined and undefined  states. Commands can be created and retrieved using this manager. It is  possible to listen to changes in the collection of commands by attaching a  listener to the manager.    Since:  3.1  See Also:  getCommand(String)    "
63,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ParameterizedCommand.html,extends Object implements Comparable  A command that has had one or more of its parameters specified. This class  serves as a utility class for developers that need to manipulate commands  with parameters. It handles the behaviour of generating a parameter map and a  human-readable name.    Since:  3.1    
64,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/common/IIdentifiable.html, An object that is unique identifiable based on the combination of its class  and its identifier.    Since:  3.2  See Also:  HandleObject    
65,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/Category.html," An object that is unique identifiable based on the combination of its class  and its identifier.    Since:  3.2  See Also:  HandleObject    
extends NamedHandleObject  A logical group for a set of commands. A command belongs to exactly one  category. The category has no functional effect_ but may be used in graphical  tools that want to group the set of commands somehow.    Since:  3.1    "
66,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IObjectWithState.html, An object that holds zero or more state objects. This state information can  be shared between different instances of IObjectWithState.      Clients may implement_ but must not extend this interface.    Since:  3.2  See Also:  AbstractHandlerWithState    
67,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/Command.html," An object that is unique identifiable based on the combination of its class  and its identifier.    Since:  3.2  See Also:  HandleObject    
 An object that holds zero or more state objects. This state information can  be shared between different instances of IObjectWithState.      Clients may implement_ but must not extend this interface.    Since:  3.2  See Also:  AbstractHandlerWithState    
extends NamedHandleObject implements Comparable  A command is an abstract representation for some semantic behaviour. It is  not the actual implementation of this behaviour_ nor is it the visual  appearance of this behaviour in the user interface. Instead_ it is a bridge  between the two.      The concept of a command is based on the command design pattern. The notable  difference is how the command delegates responsibility for execution. Rather  than allowing concrete subclasses_ it uses a handler mechanism (see the  handlers extension point). This provides another level of  indirection.      A command will exist in two states: defined and undefined. A command is  defined if it is declared in the XML of a resolved plug-in. If the plug-in is  unloaded or the command is simply not declared_ then it is undefined. Trying  to reference an undefined command will succeed_ but trying to access any of  its functionality will fail with a NotDefinedException. If  you need to know when a command changes from defined to undefined (or vice  versa)_ then attach a command listener.      Commands are mutable and will change as their definition changes.    Since:  3.1    "
68,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/IEvaluationContext.html,An evaluation context is used to manage a set of objects needed during  XML expression evaluation. A context has a parent context_ can manage  a set of named variables and has a default variable. The default variable  is used during XML expression evaluation if no explicit variable is  referenced.    This interface is not intended to be implemented by clients. Clients  are allowed to instantiate EvaluationContext.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
69,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ExecutionEvent.html,extends Object  The data object to pass to the command (and its handler) as it executes. This  carries information about the current state of the application_ and the  application context in which the command was executed.      An execution event carries three blocks of data: the parameters_ the trigger_  and the application context. How these blocks are used is application  dependent. In the Eclipse workbench_ the trigger is an SWT event_ and the  application context contains information about the selection and active part.    Since:  3.1    
70,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/HandlerEvent.html,extends AbstractBitSetEvent An instance of this class describes changes to an instance of  IHandler.    This class is not intended to be extended by clients.    Since:  3.1  See Also:  IHandlerListener.handlerChanged(HandlerEvent)    
71,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IHandler.html,A handler is the pluggable piece of a command that handles execution. Each  command can have zero or more handlers associated with it (in general)_ of  which only one will be active at any given moment in time. When the command  is asked to execute_ it will simply pass that request on to its active  handler_ if any.  Since:  3.1  See Also:  AbstractHandler    
72,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ParameterType.html," An object that is unique identifiable based on the combination of its class  and its identifier.    Since:  3.2  See Also:  HandleObject    
extends HandleObject implements Comparable  Provides information about the type of a command parameter. Clients can use a  parameter type to check if an object matches the type of the parameter with  isCompatible(Object) and can get an  AbstractParameterValueConverter to convert between objects matching  the parameter type and strings that encode the object's identity.      A command parameter is not required to declare a type. To determine if a  given parameter has a type_ check if an IParameter implements  ITypedParameter and if so_ use  ITypedParameter.getParameterType() like this:        IParameter parameter = // ... get IParameter from Command  if (parameter instanceof ITypedParameter) {  ParameterType type = ((ITypedParameter)parameter).getParameterType();  if (type != null) {  // this parameter has a ParameterType  }  }    Since:  3.2  See Also:  IParameter_  ITypedParameter.getParameterType()    "
73,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/AbstractParameterValueConverter.html,extends Object  Supports conversion between objects and strings for command parameter values.  Extenders must produce strings that identify objects (of a specific command  parameter type) as well as consume the strings to locate and return the  objects they identify.      This class offers multiple handlers of a command a consistent way of  converting string parameter values into the objects that the handlers would  prefer to deal with. This class also gives clients a way to serialize  object parameters as strings so that entire parameterized commands can be  serialized_ stored and later deserialized and executed.      This class will typically be extended so the subclass can be referenced from  the converter attribute of the  commandParameterType elemement of the  org.eclipse.ui.commands extension-point. Objects implementing  this interface may also be passed directly to  ParameterType.define(String_ AbstractParameterValueConverter) by  clients.    Since:  3.2  See Also:  ParameterType.define(String_ AbstractParameterValueConverter)_  ParameterizedCommand.serialize()    
74,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Drawable.html,Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
75,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TabFolder.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class implement the notebook user interface  metaphor. It allows the user to select a notebook page from  set of pages.    The item children that may be added to instances of this class  must be of type TabItem.  Control children are created and then set into a  tab item using TabItem#setControl.    Note that although this class is a subclass of Composite_  it does not make sense to set a layout on it.      Styles:  TOP_ BOTTOM  Events:  Selection    Note: Only one of the styles TOP and BOTTOM may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  TabFolder_ TabItem snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
76,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Composite.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Scrollable Instances of this class are controls which are capable  of containing other controls.  Styles:  NO_BACKGROUND_ NO_FOCUS_ NO_MERGE_PAINTS_ NO_REDRAW_RESIZE_ NO_RADIO_GROUP_ EMBEDDED_ DOUBLE_BUFFERED  Events:  (none)    Note: The NO_BACKGROUND_ NO_FOCUS_ NO_MERGE_PAINTS_  and NO_REDRAW_RESIZE styles are intended for use with Canvas.  They can be used with Composite if you are drawing your own_ but their  behavior is undefined if they are used with subclasses of Composite other  than Canvas.    Note: The CENTER style_ although undefined for composites_ has the  same value as EMBEDDED which is used to embed widgets from other  widget toolkits into SWT. On some operating systems (GTK_ Motif)_ this may cause  the children of this composite to be obscured.    This class may be subclassed by custom control implementors  who are building controls that are constructed from aggregates  of other controls.    See Also:  Canvas_  Composite snippets_  Sample code and further information    "
77,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/GridLayout.html,extends Layout Instances of this class lay out the control children of a   Composite in a grid.     GridLayout has a number of configuration fields_ and the   controls it lays out can have an associated layout data object_ called   GridData. The power of GridLayout lies in the   ability to configure GridData for each control in the layout.       The following code creates a shell managed by a GridLayout  with 3 columns:    Display display = new Display();  Shell shell = new Shell(display);  GridLayout gridLayout = new GridLayout();  gridLayout.numColumns = 3;  shell.setLayout(gridLayout);    The numColumns field is the most important field in a   GridLayout. Widgets are laid out in columns from left   to right_ and a new row is created when numColumns + 1   controls are added to the Composite.    See Also:  GridData_  GridLayout snippets_  SWT Example: LayoutExample_  Sample code and further information    
78,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IInputProvider.html,Interface common to all objects that provide an input.    
79,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IInputSelectionProvider.html,extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
80,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IPostSelectionProvider.html,extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
81,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ISelectionProvider.html,Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
82,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeViewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends AbstractTreeViewer A concrete viewer based on an SWT Tree control.    This class is not intended to be subclassed outside the viewer framework. It  is designed to be instantiated with a pre-existing SWT tree control and  configured with a domain-specific content provider_ label provider_ element  filter (optional)_ and element sorter (optional).      As of 3.2_ TreeViewer supports multiple equal elements (each with a  different parent chain) in the tree. This support requires that clients  enable the element map by calling setUseHashLookup(true).      Content providers for tree viewers must implement either the  ITreeContentProvider interface_ (as of 3.2) the  ILazyTreeContentProvider interface_ or (as of 3.3) the  ILazyTreePathContentProvider. If the content provider is an  ILazyTreeContentProvider or an  ILazyTreePathContentProvider_ the underlying Tree must be  created using the SWT.VIRTUAL style bit_ the tree viewer will not  support sorting or filtering_ and hash lookup must be enabled by calling  StructuredViewer.setUseHashlookup(boolean).      Users setting up an editable tree with more than 1 column have to pass the  SWT.FULL_SELECTION style bit    Restriction:  This class is not intended to be subclassed by clients.    "
83,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/FilteredTree.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite A simple control that provides a text widget and a tree viewer. The contents  of the text widget are used to drive a PatternFilter that is on the viewer.  Since:  3.2  See Also:  PatternFilter    "
84,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/GridData.html,extends Object GridData is the layout data object associated with   GridLayout. To set a GridData object into a   control_ you use the Control.setLayoutData(Object) method.     There are two ways to create a GridData object with certain   fields set. The first is to set the fields directly_ like this:    GridData gridData = new GridData();  gridData.horizontalAlignment = GridData.FILL;  gridData.grabExcessHorizontalSpace = true;  button1.setLayoutData(gridData);    gridData = new GridData();  gridData.horizontalAlignment = GridData.FILL;  gridData.verticalAlignment = GridData.FILL;  gridData.grabExcessHorizontalSpace = true;  gridData.grabExcessVerticalSpace = true;  gridData.horizontalSpan = 2;  button2.setLayoutData(gridData);    The second is to take advantage of GridData convenience constructors_ for example:     button1.setLayoutData(new GridData (SWT.FILL_ SWT.CENTER_ true_ false));  button2.setLayoutData(new GridData (SWT.FILL_ SWT.FILL_ true_ true_ 2_ 1));        NOTE: Do not reuse GridData objects. Every control in a   Composite that is managed by a GridLayout  must have a unique GridData object. If the layout data   for a control in a GridLayout is null at layout time_   a unique GridData object is created for it.    See Also:  GridLayout_  Control.setLayoutData(java.lang.Object)_  Sample code and further information    
85,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Tree.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class provide a selectable user interface object  that displays a hierarchy of items and issues notification when an  item in the hierarchy is selected.    The item children that may be added to instances of this class  must be of type TreeItem.    Style VIRTUAL is used to create a Tree whose  TreeItems are to be populated by the client on an on-demand basis  instead of up-front. This can provide significant performance improvements for  trees that are very large or for which TreeItem population is  expensive (for example_ retrieving values from an external source).    Here is an example of using a Tree with style VIRTUAL:    final Tree tree = new Tree(parent_ SWT.VIRTUAL | SWT.BORDER);  tree.setItemCount(20);  tree.addListener(SWT.SetData_ new Listener() {  public void handleEvent(Event event) {  TreeItem item = (TreeItem)event.item;  TreeItem parentItem = item.getParentItem();  String text = null;  if (parentItem == null) {  text = ""node "" + tree.indexOf(item);  } else {  text = parentItem.getText() + "" - "" + parentItem.indexOf(item);  }  item.setText(text);  System.out.println(text);  item.setItemCount(10);  }  });      Note that although this class is a subclass of Composite_  it does not normally make sense to add Control children to  it_ or set a layout on it_ unless implementing something like a cell  editor.      Styles:  SINGLE_ MULTI_ CHECK_ FULL_SELECTION_ VIRTUAL_ NO_SCROLL  Events:  Selection_ DefaultSelection_ Collapse_ Expand_ SetData_ MeasureItem_ EraseItem_ PaintItem    Note: Only one of the styles SINGLE and MULTI may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Tree_ TreeItem_ TreeColumn snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
86,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TreeColumn.html,extends Item Instances of this class represent a column in a tree widget.    Styles:  LEFT_ RIGHT_ CENTER  Events:  Move_ Resize_ Selection    Note: Only one of the styles LEFT_ RIGHT and CENTER may be specified.    IMPORTANT: This class is not intended to be subclassed.    Since:  3.1  See Also:  Tree_ TreeItem_ TreeColumn snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
87,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/SelectionEvent.html,extends TypedEvent Instances of this class are sent as a result of  widgets being selected.    Note: The fields that are filled in depend on the widget.    See Also:  SelectionListener_  Sample code and further information_  Serialized Form    
88,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Font.html,extends Resource Instances of this class manage operating system resources that  define how text looks when it is displayed. Fonts may be constructed  by providing a device and either name_ size and style information  or a FontData object which encapsulates this data.    Application code must explicitly invoke the Font.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    See Also:  FontData_  Font snippets_  SWT Examples: GraphicsExample_ PaintExample_  Sample code and further information    
89,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/MApplicationElement.html, A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
90,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MBindings.html, A representation of the model object 'Bindings'.        Mixin interface that lists MBindingContexts that should be active when this  object is active.    Example values: org.eclipse.ui.contexts.dialog_ org.eclipse.ui.contexts.window    Since:  1.0      The following features are supported:    Binding Contexts      
91,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MContext.html, A representation of the model object 'Context'.        This class is mixed into a UI element when that element is expected to participate  in the Dependency Injection context hierarchy. The context life-cycle matches  that of the rendered element it belongs to. It's automatically created when the  element is rendered and disposed when the element is unrendered.    Since:  1.0      The following features are supported:    Context  Variables  Properties      
92,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/MContribution.html,extends MApplicationElement  A representation of the model object 'Contribution'.        MContribution is a mix-in class used by concrete elements such as Parts to define  the location of the client supplied class implementing the specific logic needed.    Since:  1.0      The following features are supported:    Contribution URI  Object      
93,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MDirtyable.html, A representation of the model object 'Dirtyable'.        This class should be mixed into any UI element that should participate in the  dirty / save handling. Parts are the most likely scenario for this but it exists as  a mix-in to allow for future model extensions.    Since:  1.0      The following features are supported:    Dirty      
94,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MHandlerContainer.html, A representation of the model object 'Handler Container'.        This provides a container in which to store lists of Handlers.     Since:  1.0      The following features are supported:    Handlers      
95,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MPartSashContainerElement.html,extends MUIElement  A representation of the model object 'Part Sash Container Element'.        A class to be mixed in to any element that should be allowed to be added to  a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement  we can defined nested 'trees' of sash containment.    Since:  1.0      
96,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MStackElement.html,extends MUIElement  A representation of the model object 'Stack Element'.        A class to be mixed in to any element that should be allowed to be added to a  PartStack.    Since:  1.0      
97,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MUIElement.html,extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
98,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MUILabel.html, A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
99,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MWindowElement.html,extends MUIElement  A representation of the model object 'Window Element'.        A class to be mixed in to any element that should be allowed to be added to a  Window.    Since:  1.0      
100,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MPart.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Bindings'.        Mixin interface that lists MBindingContexts that should be active when this  object is active.    Example values: org.eclipse.ui.contexts.dialog_ org.eclipse.ui.contexts.window    Since:  1.0      The following features are supported:    Binding Contexts      
 A representation of the model object 'Context'.        This class is mixed into a UI element when that element is expected to participate  in the Dependency Injection context hierarchy. The context life-cycle matches  that of the rendered element it belongs to. It's automatically created when the  element is rendered and disposed when the element is unrendered.    Since:  1.0      The following features are supported:    Context  Variables  Properties      
extends MApplicationElement  A representation of the model object 'Contribution'.        MContribution is a mix-in class used by concrete elements such as Parts to define  the location of the client supplied class implementing the specific logic needed.    Since:  1.0      The following features are supported:    Contribution URI  Object      
 A representation of the model object 'Dirtyable'.        This class should be mixed into any UI element that should participate in the  dirty / save handling. Parts are the most likely scenario for this but it exists as  a mix-in to allow for future model extensions.    Since:  1.0      The following features are supported:    Dirty      
 A representation of the model object 'Handler Container'.        This provides a container in which to store lists of Handlers.     Since:  1.0      The following features are supported:    Handlers      
extends MUIElement  A representation of the model object 'Part Sash Container Element'.        A class to be mixed in to any element that should be allowed to be added to  a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement  we can defined nested 'trees' of sash containment.    Since:  1.0      
extends MUIElement  A representation of the model object 'Stack Element'.        A class to be mixed in to any element that should be allowed to be added to a  PartStack.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MUIElement  A representation of the model object 'Window Element'.        A class to be mixed in to any element that should be allowed to be added to a  Window.    Since:  1.0      
extends MUIElement_ MPartSashContainerElement_ MStackElement_ MContribution_ MContext_ MUILabel_ MHandlerContainer_ MDirtyable_ MBindings_ MWindowElement  A representation of the model object 'Part'.        This a concrete class representing the core UI functionality within a Window. It's what  used to be a View / Editor in Eclipse 3.    Since:  1.0      The following features are supported:    Menus  Toolbar  Closeable  Description      "
101,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/SashForm.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite The SashForm is a composite control that lays out its children in a  row or column arrangement (as specified by the orientation) and places  a Sash between each child. One child may be maximized to occupy the  entire size of the SashForm. The relative sizes of the children may  be specified using weights.      Styles:  HORIZONTAL_ VERTICAL_ SMOOTH    See Also:  SashForm snippets_  SWT Example: CustomControlExample_  Sample code and further information    "
102,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Label.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Control Instances of this class represent a non-selectable  user interface object that displays a string or image.  When SEPARATOR is specified_ displays a single  vertical or horizontal line.    Shadow styles are hints and may not be honored  by the platform. To create a separator label  with the default shadow style for the platform_  do not specify a shadow style.    Styles:  SEPARATOR_ HORIZONTAL_ VERTICAL  SHADOW_IN_ SHADOW_OUT_ SHADOW_NONE  CENTER_ LEFT_ RIGHT_ WRAP  Events:  (none)    Note: Only one of SHADOW_IN_ SHADOW_OUT and SHADOW_NONE may be specified.  SHADOW_NONE is a HINT. Only one of HORIZONTAL and VERTICAL may be specified.  Only one of CENTER_ LEFT and RIGHT may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Label snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
103,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/SelectionChangedEvent.html,extends EventObject Event object describing a selection change. The source of these  events is a selection provider.  See Also:  ISelection_  ISelectionProvider_  ISelectionChangedListener_  Serialized Form    
104,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ISelection.html,Interface for a selection.  See Also:  ISelectionProvider_  ISelectionChangedListener_  SelectionChangedEvent    
105,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IStructuredSelection.html,extends ISelection A selection containing elements.    
106,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/StructuredSelection.html,"Interface for a selection.  See Also:  ISelectionProvider_  ISelectionChangedListener_  SelectionChangedEvent    
extends ISelection A selection containing elements.    
extends Object implements IStructuredSelection A concrete implementation of the IStructuredSelection interface_  suitable for instantiating.    This class is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    "
107,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Group.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class provide an etched border  with an optional title.    Shadow styles are hints and may not be honoured  by the platform. To create a group with the  default shadow style for the platform_ do not  specify a shadow style.    Styles:  SHADOW_ETCHED_IN_ SHADOW_ETCHED_OUT_ SHADOW_IN_ SHADOW_OUT_ SHADOW_NONE  Events:  (none)    Note: Only one of the above styles may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
108,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITreeSelection.html,"Interface for a selection.  See Also:  ISelectionProvider_  ISelectionChangedListener_  SelectionChangedEvent    
extends ISelection A selection containing elements.    
extends IStructuredSelection A selection containing tree paths.    It is recommended that clients do not implement this interface but instead  use the standard implementation of this interface_ TreeSelection.  TreeSelection adds API for getting the IElementComparer  of a selection (if available). This is important for clients who want to  create a slightly modified tree selection based on an existing tree selection.  The recommended coding pattern in this case is as follows:    ITreeSelection selection = (ITreeSelection)treeViewer.getSelection();  TreePath[] paths = selection.getPaths();  IElementComparer comparer = null;  if (selection instanceof TreeSelection) {  comparer = ((TreeSelection)selection).getElementComparer();  }  TreePath[] modifiedPaths = ... // modify as required  TreeSelection modifiedSelection = new TreeSelection(modifiedPaths_ comparer);    See bugs 135818 and 133375 for details.    Since:  3.2    "
109,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/MessageBox.html,extends Dialog Instances of this class are used to inform or warn the user.  Styles:  ICON_ERROR_ ICON_INFORMATION_ ICON_QUESTION_ ICON_WARNING_ ICON_WORKING  OK_ OK | CANCEL  YES | NO_ YES | NO | CANCEL  RETRY | CANCEL  ABORT | RETRY | IGNORE  Events:  (none)    Note: Only one of the styles ICON_ERROR_ ICON_INFORMATION_ ICON_QUESTION_  ICON_WARNING and ICON_WORKING may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  SWT Example: ControlExample_ Dialog tab_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
110,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MTrimElement.html,extends MUIElement  A representation of the model object 'Trim Element'.        A class to be mixed in to any element that should be allowed to be added to a TrimBar.    Since:  1.0      
111,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolBar.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement  A representation of the model object 'Trim Element'.        A class to be mixed in to any element that should be allowed to be added to a TrimBar.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MElementContainer<MToolBarElement>_ MTrimElement  A representation of the model object 'Tool Bar'.        This is the concrete class representing a Toolbar in the UI Model.    Since:  1.0      "
112,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolBarElement.html,extends MUIElement  A representation of the model object 'Tool Bar Element'.        This is a placeholder class mixed in to any other type that can be added to a Toolbar.    Since:  1.0      
113,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolItem.html,extends MItem_ MToolBarElement  A representation of the model object 'Tool Item'.        This is the base type for both Direct and Handled tool items.    Since:  1.0      The following features are supported:    Menu      
114,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MDirectToolItem.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Contribution'.        MContribution is a mix-in class used by concrete elements such as Parts to define  the location of the client supplied class implementing the specific logic needed.    Since:  1.0      The following features are supported:    Contribution URI  Object      
extends MUIElement  A representation of the model object 'Tool Bar Element'.        This is a placeholder class mixed in to any other type that can be added to a Toolbar.    Since:  1.0      
extends MItem_ MToolBarElement  A representation of the model object 'Tool Item'.        This is the base type for both Direct and Handled tool items.    Since:  1.0      The following features are supported:    Menu      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MToolItem_ MContribution  A representation of the model object 'Direct Tool Item'.        This is the concrete class use to represent a tool item that is directly   invoked when selected. The supplied contribution is asked to execute  when selected.    Since:  1.0      "
115,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreePath.html,extends Object A tree path denotes a model element in a tree viewer. Tree path objects have  value semantics. A model element is represented by a path of elements in the  tree from the root element to the leaf element.    Clients may instantiate this class. Not intended to be subclassed.    Since:  3.2    
116,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeSelection.html,"Interface for a selection.  See Also:  ISelectionProvider_  ISelectionChangedListener_  SelectionChangedEvent    
extends ISelection A selection containing elements.    
Interface for a selection.  See Also:  ISelectionProvider_  ISelectionChangedListener_  SelectionChangedEvent    
extends ISelection A selection containing elements.    
extends IStructuredSelection A selection containing tree paths.    It is recommended that clients do not implement this interface but instead  use the standard implementation of this interface_ TreeSelection.  TreeSelection adds API for getting the IElementComparer  of a selection (if available). This is important for clients who want to  create a slightly modified tree selection based on an existing tree selection.  The recommended coding pattern in this case is as follows:    ITreeSelection selection = (ITreeSelection)treeViewer.getSelection();  TreePath[] paths = selection.getPaths();  IElementComparer comparer = null;  if (selection instanceof TreeSelection) {  comparer = ((TreeSelection)selection).getElementComparer();  }  TreePath[] modifiedPaths = ... // modify as required  TreeSelection modifiedSelection = new TreeSelection(modifiedPaths_ comparer);    See bugs 135818 and 133375 for details.    Since:  3.2    
extends StructuredSelection implements ITreeSelection A concrete implementation of the ITreeSelection interface_  suitable for instantiating.    This class is not intended to be subclassed.    Since:  3.2    "
117,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Display.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
provides inter-thread  communication methods which allow threads other than the   user-interface thread to request that it perform operations  on their behalf.)      The thread is not allowed to construct other   Displays until that display has been disposed.  (Note that_ this is in addition to the restriction mentioned  above concerning platform support for multiple displays. Thus_  the only way to have multiple simultaneously active displays_  even on platforms which support it_ is to have multiple threads.)    Enforcing these attributes allows SWT to be implemented directly  on the underlying operating system's event model. This has   numerous benefits including smaller footprint_ better use of   resources_ safer memory management_ clearer program logic_  better performance_ and fewer overall operating system threads  required. The down side however_ is that care must be taken  (only) when constructing multi-threaded applications to use the  inter-thread communication mechanisms which this class provides  when required.    All SWT API methods which may only be called from the user-interface  thread are distinguished in their documentation by indicating that  they throw the ""ERROR_THREAD_INVALID_ACCESS""  SWT exception.    Styles:  (none)  Events:  Close_ Dispose_ OpenDocument_ Settings_ Skin    IMPORTANT: This class is not intended to be subclassed.    See Also:  syncExec(java.lang.Runnable)_  asyncExec(java.lang.Runnable)_  wake()_  readAndDispatch()_  sleep()_  Device.dispose()_  Display snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
118,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/Viewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends Object implements IInputSelectionProvider A viewer is a model-based adapter on a widget.    A viewer can be created as an adapter on a pre-existing control (e.g._  creating a ListViewer on an existing List control).  All viewers also provide a convenience constructor for creating the control.      Implementing a concrete viewer typically involves the following steps:      create SWT controls for viewer (in constructor) (optional)      initialize SWT controls from input (inputChanged)      define viewer-specific update methods      support selections (setSelection_ getSelection)        "
119,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MBindingTableContainer.html, A representation of the model object 'Binding Table Container'.        This type contains the list of binding 'tables'_ representing the various sets of bindings  based on the applicaiton's current running 'context'. Here the 'context' represents  the applicaiton's UI state (i.e. whenther a Dialog is open...).    Since:  1.0      The following features are supported:    Binding Tables  Root Context      
120,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenuContributions.html, A representation of the model object 'Contributions'.        Provisional for 4.3. This is a container aggregating the menu contributions to be  applied to menus.    Since:  1.0      The following features are supported:    Menu Contributions    Restriction:  This interface is not intended to be referenced by clients.    
121,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/descriptor/basic/MPartDescriptorContainer.html, A representation of the model object 'Part Descriptor Container'.        A type specific collection of PartDescriptors.    Since:  1.0      The following features are supported:    Descriptors      
122,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MSnippetContainer.html, A representation of the model object 'Snippet Container'.        This provides a collection of model fragments that can be subsequently cloned and  inserterd into the model using the EModelService. For example saving a customized  Perspective will create a clone and store it in this container.    Since:  1.0      The following features are supported:    Snippets      
123,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolBarContributions.html, A representation of the model object 'Tool Bar Contributions'.        Provisional for 4.3. This is a container aggregating the toolbar contributions to be  applied to existing toolbars.    Since:  1.0      The following features are supported:    Tool Bar Contributions    Restriction:  This interface is not intended to be referenced by clients.    
124,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MTrimContributions.html, A representation of the model object 'Trim Contributions'.        Provisional for 4.3. This is a container aggregating the trim bar contributions to be  applied.    Since:  1.0      The following features are supported:    Trim Contributions    Restriction:  This interface is not intended to be referenced by clients.    
125,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/MApplication.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Bindings'.        Mixin interface that lists MBindingContexts that should be active when this  object is active.    Example values: org.eclipse.ui.contexts.dialog_ org.eclipse.ui.contexts.window    Since:  1.0      The following features are supported:    Binding Contexts      
 A representation of the model object 'Binding Table Container'.        This type contains the list of binding 'tables'_ representing the various sets of bindings  based on the applicaiton's current running 'context'. Here the 'context' represents  the applicaiton's UI state (i.e. whenther a Dialog is open...).    Since:  1.0      The following features are supported:    Binding Tables  Root Context      
 A representation of the model object 'Context'.        This class is mixed into a UI element when that element is expected to participate  in the Dependency Injection context hierarchy. The context life-cycle matches  that of the rendered element it belongs to. It's automatically created when the  element is rendered and disposed when the element is unrendered.    Since:  1.0      The following features are supported:    Context  Variables  Properties      
 A representation of the model object 'Handler Container'.        This provides a container in which to store lists of Handlers.     Since:  1.0      The following features are supported:    Handlers      
 A representation of the model object 'Contributions'.        Provisional for 4.3. This is a container aggregating the menu contributions to be  applied to menus.    Since:  1.0      The following features are supported:    Menu Contributions    Restriction:  This interface is not intended to be referenced by clients.    
 A representation of the model object 'Part Descriptor Container'.        A type specific collection of PartDescriptors.    Since:  1.0      The following features are supported:    Descriptors      
 A representation of the model object 'Snippet Container'.        This provides a collection of model fragments that can be subsequently cloned and  inserterd into the model using the EModelService. For example saving a customized  Perspective will create a clone and store it in this container.    Since:  1.0      The following features are supported:    Snippets      
 A representation of the model object 'Tool Bar Contributions'.        Provisional for 4.3. This is a container aggregating the toolbar contributions to be  applied to existing toolbars.    Since:  1.0      The following features are supported:    Tool Bar Contributions    Restriction:  This interface is not intended to be referenced by clients.    
 A representation of the model object 'Trim Contributions'.        Provisional for 4.3. This is a container aggregating the trim bar contributions to be  applied.    Since:  1.0      The following features are supported:    Trim Contributions    Restriction:  This interface is not intended to be referenced by clients.    
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MElementContainer<MWindow>_ MContext_ MHandlerContainer_ MBindingTableContainer_ MPartDescriptorContainer_ MBindings_ MMenuContributions_ MToolBarContributions_ MTrimContributions_ MSnippetContainer  A representation of the model object 'Application'.        The MApplication acts as the root of the UI Model. It's children are the  MWindows representing the UI for this application. It also owns the application's  context (which is hooked to the OSGI context_ allowing access not only to its  own runtime information but also to any registered OSGI service.    It also owns a number of caches which_ while independent of the UI itself are  used by the appliecation to populate new windows or to define state that is  epected to be the same for all windows:      Keybindings_ Handlers_ Commands  Part Descriptors (to support a 'Show View' dialog...)  Snippets of model (such as saved perspectives...)  Since:  1.0      The following features are supported:    Commands  Addons  Categories      "
126,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/descriptor/basic/MPartDescriptor.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Bindings'.        Mixin interface that lists MBindingContexts that should be active when this  object is active.    Example values: org.eclipse.ui.contexts.dialog_ org.eclipse.ui.contexts.window    Since:  1.0      The following features are supported:    Binding Contexts      
 A representation of the model object 'Handler Container'.        This provides a container in which to store lists of Handlers.     Since:  1.0      The following features are supported:    Handlers      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MApplicationElement_ MUILabel_ MHandlerContainer_ MBindings  A representation of the model object 'Part Descriptor'.        This element represents a template from which an MPart can be created on demand.  The collection of PartDescriptors owned by the Application represents the contributed  parts and is used in the e4 version of 'Show View'...    Since:  1.0      The following features are supported:    Allow Multiple  Category  Menus  Toolbar  Closeable  Dirtyable  Contribution URI  Description      "
127,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MWindow.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Bindings'.        Mixin interface that lists MBindingContexts that should be active when this  object is active.    Example values: org.eclipse.ui.contexts.dialog_ org.eclipse.ui.contexts.window    Since:  1.0      The following features are supported:    Binding Contexts      
 A representation of the model object 'Context'.        This class is mixed into a UI element when that element is expected to participate  in the Dependency Injection context hierarchy. The context life-cycle matches  that of the rendered element it belongs to. It's automatically created when the  element is rendered and disposed when the element is unrendered.    Since:  1.0      The following features are supported:    Context  Variables  Properties      
 A representation of the model object 'Handler Container'.        This provides a container in which to store lists of Handlers.     Since:  1.0      The following features are supported:    Handlers      
 A representation of the model object 'Snippet Container'.        This provides a collection of model fragments that can be subsequently cloned and  inserterd into the model using the EModelService. For example saving a customized  Perspective will create a clone and store it in this container.    Since:  1.0      The following features are supported:    Snippets      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MElementContainer<MWindowElement>_ MUILabel_ MContext_ MHandlerContainer_ MBindings_ MSnippetContainer  A representation of the model object 'Window'.        This is the concrete class representing a bare bones window in the UI Model. Unless  specifically desired it's likely better to use the TrimmedWindow instead.    Since:  1.0      The following features are supported:    Main Menu  X  Y  Width  Height  Windows  Shared Elements      "
128,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Control.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Widget implements Drawable Control is the abstract superclass of all windowed user interface classes.      Styles:    BORDER  LEFT_TO_RIGHT_ RIGHT_TO_LEFT_ FLIP_TEXT_DIRECTION  Events:    DragDetect_ FocusIn_ FocusOut_ Help_ KeyDown_ KeyUp_ MenuDetect_ MouseDoubleClick_ MouseDown_ MouseEnter_  MouseExit_ MouseHover_ MouseUp_ MouseMove_ MouseWheel_ MouseHorizontalWheel_ MouseVerticalWheel_ Move_  Paint_ Resize_ Traverse    Only one of LEFT_TO_RIGHT or RIGHT_TO_LEFT may be specified.    IMPORTANT: This class is intended to be subclassed only  within the SWT implementation.    See Also:  Control snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
129,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Event.html,extends Object Instances of this class provide a description of a particular  event which occurred within SWT. The SWT untyped listener  API uses these instances for all event dispatching.    Note: For a given event_ only the fields which are appropriate  will be filled in. The contents of the fields which are not used  by the event are unspecified.    See Also:  Listener_  TypedEvent_  SWT Example: ControlExample_ Listeners_  Sample code and further information    
130,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Listener.html,Implementers of Listener provide a simple   handleEvent() method that is used internally   by SWT to dispatch events.    After creating an instance of a class that implements this interface  it can be added to a widget using the   addListener(int eventType_ Listener handler) method and  removed using the   removeListener (int eventType_ Listener handler) method.   When the specified event occurs_ handleEvent(...) will  be sent to the instance.      Classes which implement this interface are described within SWT as  providing the untyped listener API. Typically_ widgets will  also provide a higher-level typed listener API_ that is based  on the standard java.util.EventListener pattern.        Note that_ since all internal SWT event dispatching is based on untyped  listeners_ it is simple to build subsets of SWT for use on memory   constrained_ small footprint devices_ by removing the classes and  methods which implement the typed listener API.    See Also:  Widget.addListener(int_ org.eclipse.swt.widgets.Listener)_  EventListener_  org.eclipse.swt.events    
131,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Shell.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Decorations Instances of this class represent the ""windows""  which the desktop or ""window manager"" is managing.  Instances that do not have a parent (that is_ they  are built using the constructor_ which takes a   Display as the argument) are described  as top level shells. Instances that do have  a parent are described as secondary or  dialog shells.    Instances are always displayed in one of the maximized_   minimized or normal states:      When an instance is marked as maximized_ the  window manager will typically resize it to fill the  entire visible area of the display_ and the instance  is usually put in a state where it can not be resized   (even if it has style RESIZE) until it is  no longer maximized.      When an instance is in the normal state (neither  maximized or minimized)_ its appearance is controlled by  the style constants which were specified when it was created  and the restrictions of the window manager (see below).      When an instance has been marked as minimized_  its contents (client area) will usually not be visible_  and depending on the window manager_ it may be  ""iconified"" (that is_ replaced on the desktop by a small  simplified representation of itself)_ relocated to a  distinguished area of the screen_ or hidden. Combinations  of these changes are also possible.      The modality of an instance may be specified using  style bits. The modality style bits are used to determine  whether input is blocked for other shells on the display.  The PRIMARY_MODAL style allows an instance to block  input to its parent. The APPLICATION_MODAL style  allows an instance to block input to every other shell in the  display. The SYSTEM_MODAL style allows an instance  to block input to all shells_ including shells belonging to  different applications.    Note: The styles supported by this class are treated  as HINTs_ since the window manager for the  desktop on which the instance is visible has ultimate  control over the appearance and behavior of decorations  and modality. For example_ some window managers only  support resizable windows and will always assume the  RESIZE style_ even if it is not set. In addition_ if a  modality style is not supported_ it is ""upgraded"" to a  more restrictive modality style that is supported. For  example_ if PRIMARY_MODAL is not supported_  it would be upgraded to APPLICATION_MODAL.  A modality style may also be ""downgraded"" to a less  restrictive style. For example_ most operating systems  no longer support SYSTEM_MODAL because  it can freeze up the desktop_ so this is typically  downgraded to APPLICATION_MODAL.    Styles:  BORDER_ CLOSE_ MIN_ MAX_ NO_TRIM_ RESIZE_ TITLE_ ON_TOP_ TOOL_ SHEET  APPLICATION_MODAL_ MODELESS_ PRIMARY_MODAL_ SYSTEM_MODAL  Events:  Activate_ Close_ Deactivate_ Deiconify_ Iconify  Class SWT provides two ""convenience constants""  for the most commonly required style combinations:  SHELL_TRIM    the result of combining the constants which are required  to produce a typical application top level shell: (that   is_ CLOSE | TITLE | MIN | MAX | RESIZE)    DIALOG_TRIM    the result of combining the constants which are required  to produce a typical application dialog shell: (that   is_ TITLE | CLOSE | BORDER)        Note: Only one of the styles APPLICATION_MODAL_ MODELESS_   PRIMARY_MODAL and SYSTEM_MODAL may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Decorations_  SWT_  Shell snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
132,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/contexts/IContextListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of IContext.    This interface may be implemented by clients.    Since:  3.1  See Also:  Context.addContextListener(IContextListener)_  Context.removeContextListener(IContextListener)    
133,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/contexts/ContextManager.html,"An instance of this interface can be used by clients to receive notification  of changes to one or more instances of IContext.    This interface may be implemented by clients.    Since:  3.1  See Also:  Context.addContextListener(IContextListener)_  Context.removeContextListener(IContextListener)    
extends HandleObjectManager implements IContextListener  A context manager tracks the sets of defined and enabled contexts within the  application. The manager sends notification events to listeners when these  sets change. It is also possible to retrieve any given context with its  identifier.      This class is not intended to be extended by clients.    Since:  3.1    "
134,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/Binding.html,"extends Object  A binding is a link between user input and the triggering of a particular  command. The most common example of a binding is a keyboard shortcut_ but  there are also mouse and gesture bindings.      Bindings are linked to particular conditions within the application. Some of  these conditions change infrequently (e.g._ locale_ scheme)_ while some will  tend to change quite frequently (e.g._ context). This allows the bindings to  be tailored to particular situations. For example_ a set of bindings may be  appropriate only inside a text editor. Or_ perhaps_ a set of bindings might  be appropriate only for a given locale_ such as bindings that coexist with  the Input Method Editor (IME) on Chinese locales.      It is also possible to remove a particular binding. This is typically done as  part of user configuration (e.g._ user changing keyboard shortcuts). However_  it can also be helpful when trying to change a binding on a particular locale  or platform. An ""unbinding"" is really just a binding with no command  identifier. For it to unbind a particular binding_ it must match that binding  in its context identifier and scheme identifier. Subclasses (e.g._  KeyBinding) may require other properties to match (e.g._  keySequence). If these properties match_ then this is an  unbinding. Note: the locale and platform can be different.      For example_ imagine you have a key binding that looks like this:      KeyBinding(command_ scheme_ context_ ""Ctrl+Shift+F"")      On GTK+_ the ""Ctrl+Shift+F"" interferes with some native behaviour. To change  the binding_ we first unbind the ""Ctrl+Shift+F"" key sequence by   assigning it a null command on the gtk platform. We then create a new binding  that maps the command to the ""Esc Ctrl+F"" key sequence.      KeyBinding(""Ctrl+Shift+F""_null_scheme_context_null_gtk_null_SYSTEM)  KeyBinding(""Esc Ctrl+F""_parameterizedCommand_scheme_context_null_gtk_SYSTEM)      Bindings are intended to be immutable objects.    Since:  3.1    "
135,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/TriggerSequence.html,extends Object  A sequence of one or more triggers. None of these triggers may be  null.    Since:  3.1    
136,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/contexts/Context.html," An object that is unique identifiable based on the combination of its class  and its identifier.    Since:  3.2  See Also:  HandleObject    
extends NamedHandleObject implements Comparable  A context is an answer to the question ""when"". Other services can listen for  the activation and deactivation of contexts_ and change their own state in  response to these changes. For example_ Eclipse's key binding service listens  to context activation and deactivation to determine which key bindings should  be active.      An instance of this interface can be obtained from an instance of  ContextManager for any identifier_ whether or not an context  with that identifier is defined in the extension registry.      The handle-based nature of this API allows it to work well with runtime  plugin activation and deactivation. If a context is defined_ that means that  its corresponding plug-in is active. If the plug-in is then deactivated_ the  context will still exist but it will be undefined. An attempts to use an  undefined context will result in a NotDefinedException being  thrown.      This class is not intended to be extended by clients.    Since:  3.1  See Also:  ContextManager    "
137,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Point.html,extends Object implements org.eclipse.swt.internal.SerializableCompatibility Instances of this class represent places on the (x_ y)  coordinate plane.    The coordinate space for rectangles and points is considered  to have increasing values downward and to the right from its  origin making this the normal_ computer graphics oriented notion  of (x_ y) coordinates rather than the strict mathematical one.      The hashCode() method in this class uses the values of the public  fields to compute the hash value. When storing instances of the  class in hashed collections_ do not modify these fields after the  object has been inserted.       Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.    See Also:  Rectangle_  Sample code and further information_  Serialized Form    
138,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Rectangle.html,extends Object implements org.eclipse.swt.internal.SerializableCompatibility Instances of this class represent rectangular areas in an  (x_ y) coordinate system. The top left corner of the rectangle  is specified by its x and y values_ and the extent of the  rectangle is specified by its width and height.    The coordinate space for rectangles and points is considered  to have increasing values downward and to the right from its  origin making this the normal_ computer graphics oriented notion  of (x_ y) coordinates rather than the strict mathematical one.      The hashCode() method in this class uses the values of the public  fields to compute the hash value. When storing instances of the  class in hashed collections_ do not modify these fields after the  object has been inserted.       Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.    See Also:  Point_  Sample code and further information_  Serialized Form    
139,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TableColumn.html,extends Item Instances of this class represent a column in a table widget.    Styles:  LEFT_ RIGHT_ CENTER  Events:  Move_ Resize_ Selection    Note: Only one of the styles LEFT_ RIGHT and CENTER may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Table_ TableItem_ TableColumn snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
140,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TableItem.html,extends Item Instances of this class represent a selectable user interface object  that represents an item in a table.  Styles:  (none)  Events:  (none)    IMPORTANT: This class is not intended to be subclassed.    See Also:  Table_ TableItem_ TableColumn snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
141,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Widget.html,extends Object This class is the abstract superclass of all user interface objects.   Widgets are created_ disposed and issue notification to listeners  when events occur which affect them.  Styles:  (none)  Events:  Dispose    IMPORTANT: This class is intended to be subclassed only  within the SWT implementation. However_ it has not been marked  final to allow those outside of the SWT development team to implement  patched versions of the class in order to get around specific  limitations in advance of when those limitations can be addressed  by the team. Any class built using subclassing to access the internals  of this class will likely fail to compile or run between releases and  may be strongly platform specific. Subclassing should not be attempted  without an intimate and detailed understanding of the workings of the  hierarchy. No support is provided for user-written classes which are  implemented as subclasses of this class.    See Also:  checkSubclass()_  Sample code and further information    
142,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/KeySequence.html,extends TriggerSequence implements Comparable  A KeySequence is defined as a list of zero or more  KeyStrokes_ with the stipulation that all  KeyStroke objects must be complete_ save for the last one_  whose completeness is optional. A KeySequence is said to be  complete if all of its KeyStroke objects are complete.      All KeySequence objects have a formal string representation  available via the toString() method. There are a number of  methods to get instances of KeySequence objects_ including one  which can parse this formal string representation.      All KeySequence objects_ via the format()  method_ provide a version of their formal string representation translated by  platform and locale_ suitable for display to a user.      KeySequence objects are immutable. Clients are not permitted  to extend this class.    Since:  3.1    
143,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/VerifyEvent.html,extends KeyEvent Instances of this class are sent as a result of  widgets handling keyboard events  See Also:  VerifyListener_  Sample code and further information_  Serialized Form    
144,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/Path.html,"extends Object implements IPath_ Cloneable The standard implementation of the IPath interface.  Paths are always maintained in canonicalized form. That is_ parent  references (i.e._ ../../) and duplicate separators are   resolved. For example_  new Path(""/a/b"").append(""../foo/bar"")  will yield the path  /a/foo/bar    This class can be used without OSGi running.    This class is not intended to be subclassed by clients but  may be instantiated.    See Also:  IPath  Restriction:  This class is not intended to be subclassed by clients.    "
145,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IPath.html,"extends Cloneable A path is an ordered collection of string segments_  separated by a standard separator character_ ""/"".  A path may also have a leading and/or a trailing separator.  Paths may also be prefixed by an optional device id_ which includes  the character(s) which separate the device id from the rest   of the path. For example_ ""C:"" and ""Server/Volume:"" are typical  device ids.  A device independent path has null for a device id.    Note that paths are value objects; all operations on paths   return a new path; the path that is operated on is unscathed.      UNC paths are denoted by leading double-slashes such   as //Server/Volume/My/Path. When a new path  is constructed all double-slashes are removed except those  appearing at the beginning of the path.      This interface can be used without OSGi running.    This interface is not intended to be implemented by clients.    See Also:  Path  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
146,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExtensionPoint.html,An extension point declared in a plug-in.  Except for the list of extensions plugged in to it_ the information   available for an extension point is obtained from the declaring plug-in's   manifest (plugin.xml) file.    These registry objects are intended for relatively short-term use. Clients that   deal with these objects must be aware that they may become invalid if the   declaring plug-in is updated or uninstalled. If this happens_ all methods except  isValid() will throw InvalidRegistryObjectException.  For extension point objects_ the most common case is code in a plug-in dealing  with one of the extension points it declares. These extension point objects are  guaranteed to be valid while the plug-in is active. Code in a plug-in that has  declared that it is not dynamic aware (or not declared anything) can also safely  ignore this issue_ since the registry would not be modified while it is  active. However_ code in a plug-in that declares that it is dynamic aware  must be careful if it access the extension point object of a different plug-in_  because it's at risk if that other plug-in is removed. Similarly_  tools that analyze or display the extension registry are vulnerable.  Client code can pre-test for invalid objects by calling isValid()_  which never throws this exception. However_ pre-tests are usually not sufficient  because of the possibility of the extension point object becoming invalid as a  result of a concurrent activity. At-risk clients must treat   InvalidRegistryObjectException as if it were a checked exception.  Also_ such clients should probably register a listener with the extension registry  so that they receive notification of any changes to the registry.    This interface can be used without OSGi running.    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    
147,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExtension.html,An extension declared in a plug-in.  All information is obtained from the declaring plug-in's   manifest (plugin.xml) file.    These registry objects are intended for relatively short-term use. Clients that   deal with these objects must be aware that they may become invalid if the   declaring plug-in is updated or uninstalled. If this happens_ all methods except  isValid() will throw InvalidRegistryObjectException.  For extension objects_ the most common case is code in a plug-in dealing  with extensions contributed to one of the extension points it declares.  Code in a plug-in that has declared that it is not dynamic aware (or not  declared anything) can safely ignore this issue_ since the registry  would not be modified while it is active. However_ code in a plug-in that  declares that it is dynamic aware must be careful when accessing the extension  objects because they become invalid if the contributing plug-in is removed.  Similarly_ tools that analyze or display the extension registry are vulnerable.  Client code can pre-test for invalid objects by calling isValid()_  which never throws this exception. However_ pre-tests are usually not sufficient  because of the possibility of the extension object becoming invalid as a  result of a concurrent activity. At-risk clients must treat   InvalidRegistryObjectException as if it were a checked exception.  Also_ such clients should probably register a listener with the extension registry  so that they receive notification of any changes to the registry.    This interface can be used without OSGi running.    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    
148,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IConfigurationElement.html,A configuration element_ with its attributes and children_   directly reflects the content and structure of the extension section  within the declaring plug-in's manifest (plugin.xml) file.    This interface also provides a way to create executable extension  objects.      These registry objects are intended for relatively short-term use. Clients that   deal with these objects must be aware that they may become invalid if the   declaring plug-in is updated or uninstalled. If this happens_ all methods except  isValid() will throw InvalidRegistryObjectException.  For configuration element objects_ the most common case is code in a plug-in dealing  with extensions contributed to one of the extension points it declares.  Code in a plug-in that has declared that it is not dynamic aware (or not  declared anything) can safely ignore this issue_ since the registry  would not be modified while it is active. However_ code in a plug-in that  declares that it is dynamic aware must be careful when accessing the extension  and configuration element objects because they become invalid if the contributing  plug-in is removed. Similarly_ tools that analyze or display the extension registry  are vulnerable. Client code can pre-test for invalid objects by calling isValid()_  which never throws this exception. However_ pre-tests are usually not sufficient  because of the possibility of the extension or configuration element object becoming  invalid as a result of a concurrent activity. At-risk clients must treat   InvalidRegistryObjectException as if it were a checked exception.  Also_ such clients should probably register a listener with the extension registry  so that they receive notification of any changes to the registry.    This interface can be used without OSGi running.    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    
149,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExtensionRegistry.html,The extension registry holds the master list of all  discovered namespaces_ extension points and extensions.     The extension registry can be queried_ by name_ for   extension points and extensions.       The various objects that describe the contents of the extension registry  (IExtensionPoint_ IExtension_ and IConfigurationElement)  are intended for relatively short-term use. Clients that deal with these objects  must be aware that they may become invalid if the declaring plug-in is updated  or uninstalled. If this happens_ all methods on these object except  isValid() will throw InvalidRegistryObjectException.  Code in a plug-in that has declared that it is not dynamic aware (or not declared  anything) can safely ignore this issue_ since the registry would not be  modified while it is active. However_ code in a plug-in that declares that it  is dynamic aware must be careful if it accesses extension registry objects_  because it's at risk if plug-in are removed. Similarly_ tools that analyze  or display the extension registry are vulnerable. Client code can pre-test for  invalid objects by calling isValid()_ which never throws this exception.  However_ pre-tests are usually not sufficient because of the possibility of the  extension registry object becoming invalid as a result of a concurrent activity.  At-risk clients must treat InvalidRegistryObjectException as if it  were a checked exception. Also_ such clients should probably register a listener  with the extension registry so that they receive notification of any changes to  the registry.      Extensions and extension points are declared by generic entities called   namespaces. The only fact known about namespaces is that they   have unique string-based identifiers. One example of a namespace   is a plug-in_ for which the namespace id is the plug-in id.    This interface can be used without OSGi running.    This interface is not intended to be implemented by clients.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    
150,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Button.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Control Instances of this class represent a selectable user interface object that  issues notification when pressed and released.   Styles:  ARROW_ CHECK_ PUSH_ RADIO_ TOGGLE_ FLAT_ WRAP  UP_ DOWN_ LEFT_ RIGHT_ CENTER  Events:  Selection    Note: Only one of the styles ARROW_ CHECK_ PUSH_ RADIO_ and TOGGLE   may be specified.    Note: Only one of the styles LEFT_ RIGHT_ and CENTER may be specified.    Note: Only one of the styles UP_ DOWN_ LEFT_ and RIGHT may be specified  when the ARROW style is specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Button snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
151,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CTabFolder.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class implement the notebook user interface  metaphor. It allows the user to select a notebook page from  set of pages.    The item children that may be added to instances of this class  must be of type CTabItem.  Control children are created and then set into a  tab item using CTabItem#setControl.    Note that although this class is a subclass of Composite_  it does not make sense to set a layout on it.      Styles:  CLOSE_ TOP_ BOTTOM_ FLAT_ BORDER_ SINGLE_ MULTI  Events:  Selection  ""CTabFolder2""    Note: Only one of the styles TOP and BOTTOM   may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  CTabFolder_ CTabItem snippets_  SWT Example: CustomControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
152,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Item.html,extends Widget This class is the abstract superclass of all non-windowed  user interface objects that occur within specific controls.  For example_ a tree will contain tree items.  Styles:  (none)  Events:  (none)  See Also:  Sample code and further information    
153,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CTabItem.html,extends Item Instances of this class represent a selectable user interface object  that represent a page in a notebook widget.    Styles:  SWT.CLOSE  Events:  (none)    IMPORTANT: This class is not intended to be subclassed.    See Also:  CTabFolder_ CTabItem snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
154,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Text.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Scrollable Instances of this class are selectable user interface  objects that allow the user to enter and modify text.  Text controls can be either single or multi-line.  When a text control is created with a border_ the  operating system includes a platform specific inset  around the contents of the control. When created  without a border_ an effort is made to remove the  inset such that the preferred size of the control  is the same size as the contents.      Styles:  CENTER_ ICON_CANCEL_ ICON_SEARCH_ LEFT_ MULTI_ PASSWORD_ SEARCH_ SINGLE_ RIGHT_ READ_ONLY_ WRAP  Events:  DefaultSelection_ Modify_ Verify_ OrientationChange    Note: Only one of the styles MULTI and SINGLE may be specified_  and only one of the styles LEFT_ CENTER_ and RIGHT may be specified.      Note: The styles ICON_CANCEL and ICON_SEARCH are hints used in combination with SEARCH.  When the platform supports the hint_ the text control shows these icons. When an icon  is selected_ a default selection event is sent with the detail field set to one of  ICON_CANCEL or ICON_SEARCH. Normally_ application code does not need to check the  detail. In the case of ICON_CANCEL_ the text is cleared before the default selection  event is sent causing the application to search for an empty string.      IMPORTANT: This class is not intended to be subclassed.    See Also:  Text snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
155,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Scale.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Control Instances of the receiver represent a selectable user  interface object that present a range of continuous  numeric values.  Styles:  HORIZONTAL_ VERTICAL  Events:  Selection    Note: Only one of the styles HORIZONTAL and VERTICAL may be specified.      IMPORTANT: This class is not intended to be subclassed.    See Also:  Scale snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
156,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Table.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class implement a selectable user interface  object that displays a list of images and strings and issues  notification when selected.    The item children that may be added to instances of this class  must be of type TableItem.    Style VIRTUAL is used to create a Table whose  TableItems are to be populated by the client on an on-demand basis  instead of up-front. This can provide significant performance improvements for  tables that are very large or for which TableItem population is  expensive (for example_ retrieving values from an external source).    Here is an example of using a Table with style VIRTUAL:    final Table table = new Table (parent_ SWT.VIRTUAL | SWT.BORDER);  table.setItemCount (1000000);  table.addListener (SWT.SetData_ new Listener () {  public void handleEvent (Event event) {  TableItem item = (TableItem) event.item;  int index = table.indexOf (item);  item.setText (""Item "" + index);  System.out.println (item.getText ());  }  });       Note that although this class is a subclass of Composite_  it does not normally make sense to add Control children to  it_ or set a layout on it_ unless implementing something like a cell  editor.      Styles:  SINGLE_ MULTI_ CHECK_ FULL_SELECTION_ HIDE_SELECTION_ VIRTUAL_ NO_SCROLL  Events:  Selection_ DefaultSelection_ SetData_ MeasureItem_ EraseItem_ PaintItem    Note: Only one of the styles SINGLE_ and MULTI may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Table_ TableItem_ TableColumn snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
157,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ToolBar.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class support the layout of selectable  tool bar items.    The item children that may be added to instances of this class  must be of type ToolItem.    Note that although this class is a subclass of Composite_  it does not make sense to add Control children to it_  or set a layout on it.      Styles:  FLAT_ WRAP_ RIGHT_ HORIZONTAL_ VERTICAL_ SHADOW_OUT  Events:  (none)    Note: Only one of the styles HORIZONTAL and VERTICAL may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  ToolBar_ ToolItem snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
158,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ToolItem.html,extends Item Instances of this class represent a selectable user interface object  that represents a button in a tool bar.  Styles:  PUSH_ CHECK_ RADIO_ SEPARATOR_ DROP_DOWN  Events:  Selection    Note: Only one of the styles CHECK_ PUSH_ RADIO_ SEPARATOR and DROP_DOWN   may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  ToolBar_ ToolItem snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
159,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/DisposeEvent.html,extends TypedEvent Instances of this class are sent as a result of  widgets being disposed.  See Also:  DisposeListener_  Sample code and further information_  Serialized Form    
160,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Color.html,extends Resource Instances of this class manage the operating system resources that  implement SWT's RGB color model. To create a color you can either  specify the individual color components as integers in the range   0 to 255 or provide an instance of an RGB.     Application code must explicitly invoke the Color.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    See Also:  RGB_  Device.getSystemColor(int)_  Color and RGB snippets_  SWT Example: PaintExample_  Sample code and further information    
161,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/RGB.html,extends Object implements org.eclipse.swt.internal.SerializableCompatibility Instances of this class are descriptions of colors in  terms of the primary additive color model (red_ green and  blue). A color may be described in terms of the relative  intensities of these three primary colors. The brightness  of each color is specified by a value in the range 0 to 255_  where 0 indicates no color (blackness) and 255 indicates  maximum intensity.    The hashCode() method in this class uses the values of the public  fields to compute the hash value. When storing instances of the  class in hashed collections_ do not modify these fields after the  object has been inserted.       Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.    See Also:  Color_  Color and RGB snippets_  Sample code and further information_  Serialized Form    
162,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Cursor.html,extends Resource Instances of this class manage operating system resources that  specify the appearance of the on-screen pointer. To create a  cursor you specify the device and either a simple cursor style  describing one of the standard operating system provided cursors  or the image and mask data for the desired appearance.    Application code must explicitly invoke the Cursor.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    Styles:    CURSOR_ARROW_ CURSOR_WAIT_ CURSOR_CROSS_ CURSOR_APPSTARTING_ CURSOR_HELP_  CURSOR_SIZEALL_ CURSOR_SIZENESW_ CURSOR_SIZENS_ CURSOR_SIZENWSE_ CURSOR_SIZEWE_  CURSOR_SIZEN_ CURSOR_SIZES_ CURSOR_SIZEE_ CURSOR_SIZEW_ CURSOR_SIZENE_ CURSOR_SIZESE_  CURSOR_SIZESW_ CURSOR_SIZENW_ CURSOR_UPARROW_ CURSOR_IBEAM_ CURSOR_NO_ CURSOR_HAND      Note: Only one of the above styles may be specified.    See Also:  Cursor snippets_  Sample code and further information    
163,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/FontData.html,extends Object Instances of this class describe operating system fonts.    For platform-independent behaviour_ use the get and set methods  corresponding to the following properties:    height  the height of the font in points  name  the face name of the font_ which may include the foundry  style  A bitwise combination of NORMAL_ ITALIC and BOLD  If extra_ platform-dependent functionality is required:  On Windows_ the data member of the FontData  corresponds to a Windows LOGFONT structure whose fields  may be retrieved and modified.  On X_ the fields of the FontData correspond  to the entries in the font's XLFD name and may be retrieved and modified.    Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.  See Also:  Font_  Sample code and further information    
164,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/PaintListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated when the  control needs to be painted.     After creating an instance of a class that implements  this interface it can be added to a control using the  addPaintListener method and removed using  the removePaintListener method. When a  paint event occurs_ the paintControl method will be  invoked.    See Also:  PaintEvent    
165,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/PaintEvent.html,extends TypedEvent Instances of this class are sent as a result of  visible areas of controls requiring re-painting.  See Also:  PaintListener_  Sample code and further information_  Serialized Form    
166,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/GC.html,extends Resource Class GC is where all of the drawing capabilities that are   supported by SWT are located. Instances are used to draw on either an   Image_ a Control_ or directly on a Display.  Styles:  LEFT_TO_RIGHT_ RIGHT_TO_LEFT      The SWT drawing coordinate system is the two-dimensional space with the origin  (0_0) at the top left corner of the drawing area and with (x_y) values increasing  to the right and downward respectively.        The result of drawing on an image that was created with an indexed  palette using a color that is not in the palette is platform specific.  Some platforms will match to the nearest color while other will draw  the color itself. This happens because the allocated image might use  a direct palette on platforms that do not support indexed palette.        Application code must explicitly invoke the GC.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required. This is particularly  important on Windows95 and Windows98 where the operating system has a limited  number of device contexts available.        Note: Only one of LEFT_TO_RIGHT and RIGHT_TO_LEFT may be specified.    See Also:  PaintEvent_  GC snippets_  SWT Examples: GraphicsExample_ PaintExample_  Sample code and further information    
167,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Image.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Resource implements Drawable Instances of this class are graphics which have been prepared  for display on a specific device. That is_ they are ready  to paint using methods such as GC.drawImage()  and display on widgets with_ for example_ Button.setImage().    If loaded from a file format that supports it_ an  Image may have transparency_ meaning that certain  pixels are specified as being transparent when drawn. Examples  of file formats that support transparency are GIF and PNG.    There are two primary ways to use Images.   The first is to load a graphic file from disk and create an  Image from it. This is done using an Image  constructor_ for example:    Image i = new Image(device_ ""C:\\graphic.bmp"");    A graphic file may contain a color table specifying which  colors the image was intended to possess. In the above example_  these colors will be mapped to the closest available color in  SWT. It is possible to get more control over the mapping of  colors as the image is being created_ using code of the form:    ImageData data = new ImageData(""C:\\graphic.bmp"");   RGB[] rgbs = data.getRGBs();   // At this point_ rgbs contains specifications of all  // the colors contained within this image. You may  // allocate as many of these colors as you wish by  // using the Color constructor Color(RGB)_ then  // create the image:  Image i = new Image(device_ data);      Applications which require even greater control over the image  loading process should use the support provided in class  ImageLoader.    Application code must explicitly invoke the Image.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    See Also:  Color_  ImageData_  ImageLoader_  Image snippets_  SWT Examples: GraphicsExample_ ImageAnalyzer_  Sample code and further information    "
168,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Device.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Object implements Drawable This class is the abstract superclass of all device objects_  such as the Display device and the Printer device. Devices  can have a graphics context (GC) created for them_ and they  can be drawn on by sending messages to the associated GC.  See Also:  Sample code and further information    "
169,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Layout.html,extends Object A layout controls the position and size  of the children of a composite widget.  This class is the abstract base class for  layouts.  See Also:  Composite.setLayout(Layout)_  Sample code and further information    
170,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CTabFolderRenderer.html,extends Object Instances of this class provide all of the measuring and drawing functionality   required by CTabFolder. This class can be subclassed in order to  customize the look of a CTabFolder.  Since:  3.6  See Also:  Sample code and further information    
171,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/VerifyListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the events that are generated when text  is about to be modified.    After creating an instance of a class that implements  this interface it can be added to a text control using the  addVerifyListener method and removed using  the removeVerifyListener method. When the  text is about to be modified_ the verifyText method  will be invoked.    See Also:  VerifyEvent    
172,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/ImageData.html,extends Object implements org.eclipse.swt.internal.CloneableCompatibility Instances of this class are device-independent descriptions  of images. They are typically used as an intermediate format  between loading from or writing to streams and creating an   Image.    Note that the public fields x_ y_   disposalMethod and delayTime are  typically only used when the image is in a set of images used  for animation.    See Also:  Image_  ImageLoader_  ImageData snippets_  SWT Example: ImageAnalyzer_  Sample code and further information    
173,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/service/datalocation/Location.html,A Location represents a URL which may have a default value_ may be read only_ may   or may not have a current value and may be cascaded on to a parent location.    This interface is not intended to be implemented by clients.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    
174,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/IEclipsePreferences.html,extends org.osgi.service.prefs.Preferences This interface describes Eclipse extensions to the preference  story. It provides means for both preference and node change  listeners.    Clients may implement this interface.    Since:  3.0  See Also:  Preferences    
175,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MBindingContext.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Binding Context'.        This class describes the hierarchy of contexts that are used by the   EBindingService to determine which Bindings are currently   available to the user.    Since:  1.0      The following features are supported:    Name  Description  Children      "
176,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MCategory.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Category'.        This defines a logical grouping of Commands in order to facilitate showing   the current set of Commands in dialogs_ lists etc    Since:  1.0      The following features are supported:    Name  Description      "
177,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MCommandsFactory.html, The Factory for the model.  It provides a create method for each non-abstract class of the model.  Since:  1.0      
178,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MCommand.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Command'.        A Command represents a logical operation within the applicaiton. The implementation  is provided by an MHandler chosen by examining all the candidate's enablement.    Since:  1.0      The following features are supported:    Command Name  Description  Parameters  Category      "
179,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/descriptor/basic/MBasicFactory.html, The Factory for the model.  It provides a create method for each non-abstract class of the model.  Since:  1.0      
180,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/MApplicationFactory.html, The Factory for the model.  It provides a create method for each non-abstract class of the model.  Since:  1.0      
181,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/advanced/MAdvancedFactory.html, The Factory for the model.  It provides a create method for each non-abstract class of the model.  Since:  1.0      
182,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/advanced/MPerspective.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Context'.        This class is mixed into a UI element when that element is expected to participate  in the Dependency Injection context hierarchy. The context life-cycle matches  that of the rendered element it belongs to. It's automatically created when the  element is rendered and disposed when the element is unrendered.    Since:  1.0      The following features are supported:    Context  Variables  Properties      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MElementContainer<MPartSashContainerElement>_ MUILabel_ MContext  A representation of the model object 'Perspective'.        The Persepctive defines a part of the UI presentation that can be switched independently  of the rest of the UI. By using Placeholders it's possible to share elements between  different perspectives.    Since:  1.0      The following features are supported:    Windows      "
183,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MPartSashContainer.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement  A representation of the model object 'Part Sash Container Element'.        A class to be mixed in to any element that should be allowed to be added to  a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement  we can defined nested 'trees' of sash containment.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MUIElement  A representation of the model object 'Window Element'.        A class to be mixed in to any element that should be allowed to be added to a  Window.    Since:  1.0      
extends MGenericTile<MPartSashContainerElement>_ MPartSashContainerElement_ MWindowElement  A representation of the model object 'Part Sash Container'.        This is the concrete class representing sashed containment in the UI Model. This  type is recursive_ allowing the creation of a tree of sashes whose leafs are Parts.    Since:  1.0      "
184,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MBasicFactory.html, The Factory for the model.  It provides a create method for each non-abstract class of the model.  Since:  1.0      
185,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenuElement.html,extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
186,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenu.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MMenuElement_ MElementContainer<MMenuElement>  A representation of the model object 'Menu'.        This is a concrete class used to represent a menu in the UI Model.    Since:  1.0      The following features are supported:    Enabled      "
187,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MInput.html, A representation of the model object 'Input'.        This class should be mixed into UI elements such as InputParts that need to   reference an external resource (files...).    Since:  1.0      The following features are supported:    Input URI      
188,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/advanced/MPlaceholder.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement  A representation of the model object 'Part Sash Container Element'.        A class to be mixed in to any element that should be allowed to be added to  a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement  we can defined nested 'trees' of sash containment.    Since:  1.0      
extends MUIElement  A representation of the model object 'Stack Element'.        A class to be mixed in to any element that should be allowed to be added to a  PartStack.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MUIElement_ MPartSashContainerElement_ MStackElement  A representation of the model object 'Placeholder'.        A Placeholder is a concrete class used to share elements between perspectives. The  elements referenced by a Placeholder generally exist in the Window's 'sharedElements'  list. By convention a placeholder usually shares the same elementId as the element  that it's referencing.    Since:  1.0      The following features are supported:    Ref  Closeable      "
189,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MExpression.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Expression'.        A class upon which specific types of expressions are based. These are often used to  evaluate visibility and enablement of model elements.    Since:  1.0      "
190,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MUiFactory.html, The Factory for the model.  It provides a create method for each non-abstract class of the model.  Since:  1.0      
191,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenuSeparator.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MMenuElement  A representation of the model object 'Separator'.        An element representing a separator in a menu.    Since:  1.0      "
192,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenuContribution.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MElementContainer<MMenuElement>  A representation of the model object 'Contribution'.        Provisional for 4.3. This represents a potential extension to some menu already  defined in the UI.    Since:  1.0      The following features are supported:    Position In Parent  Parent Id    Restriction:  This interface is not intended to be referenced by clients.    "
193,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MPopupMenu.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Context'.        This class is mixed into a UI element when that element is expected to participate  in the Dependency Injection context hierarchy. The context life-cycle matches  that of the rendered element it belongs to. It's automatically created when the  element is rendered and disposed when the element is unrendered.    Since:  1.0      The following features are supported:    Context  Variables  Properties      
extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MMenu_ MContext  A representation of the model object 'Popup Menu'.        This is a concrete class representing context menus. Menus of this type are generally  managed by code within the running application since they're not visible in the UI.    Since:  1.0      "
194,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenuItem.html,extends MItem_ MMenuElement  A representation of the model object 'Item'.        This is the base type for both Handled and direct menu items.    Since:  1.0      
195,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MDirectMenuItem.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Contribution'.        MContribution is a mix-in class used by concrete elements such as Parts to define  the location of the client supplied class implementing the specific logic needed.    Since:  1.0      The following features are supported:    Contribution URI  Object      
extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
extends MItem_ MMenuElement  A representation of the model object 'Item'.        This is the base type for both Handled and direct menu items.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MMenuItem_ MContribution  A representation of the model object 'Direct Menu Item'.        This is the concrete class use to represent a menu item that is directly   invoked when selected. The supplied contribution is asked to execute  when selected.    Since:  1.0      "
196,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MHandledItem.html,extends MItem  A representation of the model object 'Handled Item'.        This is the base class for menu and tool items associated with Commands.    Since:  1.0      The following features are supported:    Command  Wb Command  Parameters      
197,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MHandledMenuItem.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MItem  A representation of the model object 'Handled Item'.        This is the base class for menu and tool items associated with Commands.    Since:  1.0      The following features are supported:    Command  Wb Command  Parameters      
extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
extends MItem_ MMenuElement  A representation of the model object 'Item'.        This is the base type for both Handled and direct menu items.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MMenuItem_ MHandledItem  A representation of the model object 'Handled Menu Item'.        This is the concrete UI Model element representing a menu item that is managed  through the Commands / Handlers infrastructure.    Since:  1.0      "
198,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolControl.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Contribution'.        MContribution is a mix-in class used by concrete elements such as Parts to define  the location of the client supplied class implementing the specific logic needed.    Since:  1.0      The following features are supported:    Contribution URI  Object      
extends MUIElement  A representation of the model object 'Tool Bar Element'.        This is a placeholder class mixed in to any other type that can be added to a Toolbar.    Since:  1.0      
extends MUIElement  A representation of the model object 'Trim Element'.        A class to be mixed in to any element that should be allowed to be added to a TrimBar.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MToolBarElement_ MContribution_ MTrimElement  A representation of the model object 'Tool Control'.        This is a concrete class representing a widget hosted directly in the trim   or as an item in a Toolbar.    Since:  1.0      "
199,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MHandledToolItem.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MItem  A representation of the model object 'Handled Item'.        This is the base class for menu and tool items associated with Commands.    Since:  1.0      The following features are supported:    Command  Wb Command  Parameters      
extends MUIElement  A representation of the model object 'Tool Bar Element'.        This is a placeholder class mixed in to any other type that can be added to a Toolbar.    Since:  1.0      
extends MItem_ MToolBarElement  A representation of the model object 'Tool Item'.        This is the base type for both Direct and Handled tool items.    Since:  1.0      The following features are supported:    Menu      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MToolItem_ MHandledItem  A representation of the model object 'Handled Tool Item'.        This is the concrete UI Model element representing a tool item that is managed  through the Commands / Handlers infrastructure.    Since:  1.0      "
200,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolBarSeparator.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement  A representation of the model object 'Tool Bar Element'.        This is a placeholder class mixed in to any other type that can be added to a Toolbar.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MToolBarElement  A representation of the model object 'Tool Bar Separator'.        This is the concrete class used to represent a separator in a Toolbar.    Since:  1.0      "
201,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MRenderedMenu.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MMenu  A representation of the model object 'Rendered Menu'.      Do no use! This class will be removed at the beginning of Luna (4.4) development.  Since:  1.0      The following features are supported:    Contribution Manager    Restriction:      "
202,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MRenderedToolBar.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement  A representation of the model object 'Trim Element'.        A class to be mixed in to any element that should be allowed to be added to a TrimBar.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MElementContainer<MToolBarElement>_ MTrimElement  A representation of the model object 'Tool Bar'.        This is the concrete class representing a Toolbar in the UI Model.    Since:  1.0      
extends MUIElement  A representation of the model object 'Trim Element'.        A class to be mixed in to any element that should be allowed to be added to a TrimBar.    Since:  1.0      
extends MToolBar  A representation of the model object 'Rendered Tool Bar'.      Do no use! This class will be removed at the beginning of Luna (4.4) development.  Since:  1.0      The following features are supported:    Contribution Manager    Restriction:      "
203,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolBarContribution.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MElementContainer<MToolBarElement>  A representation of the model object 'Tool Bar Contribution'.        Provisional for 4.3. This represents a potential extension to some toolbar already  defined in the UI.    Since:  1.0      The following features are supported:    Parent Id  Position In Parent    Restriction:  This interface is not intended to be referenced by clients.    "
204,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MTrimContribution.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MElementContainer<MTrimElement>  A representation of the model object 'Trim Contribution'.        Provisional for 4.3. This represents a potential extension to some trim bar.    Since:  1.0      The following features are supported:    Parent Id  Position In Parent    Restriction:  This interface is not intended to be referenced by clients.    "
205,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MRenderedMenuItem.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
extends MItem_ MMenuElement  A representation of the model object 'Item'.        This is the base type for both Handled and direct menu items.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MMenuItem  A representation of the model object 'Rendered Menu Item'.      Do no use! This class will be removed at the beginning of Luna (4.4) development.  Since:  1.0      The following features are supported:    Contribution Item    Restriction:  This interface is not intended to be referenced by clients.    "
206,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MOpaqueToolItem.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement  A representation of the model object 'Tool Bar Element'.        This is a placeholder class mixed in to any other type that can be added to a Toolbar.    Since:  1.0      
extends MItem_ MToolBarElement  A representation of the model object 'Tool Item'.        This is the base type for both Direct and Handled tool items.    Since:  1.0      The following features are supported:    Menu      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MToolItem  A representation of the model object 'Opaque Tool Item'.      Do no use! This class will be removed at the beginning of Luna (4.4) development.  Since:  1.0      The following features are supported:    Opaque Item    Restriction:  This interface is not intended to be referenced by clients.    "
207,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MOpaqueMenuItem.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
extends MItem_ MMenuElement  A representation of the model object 'Item'.        This is the base type for both Handled and direct menu items.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MMenuItem  A representation of the model object 'Opaque Menu Item'.      Do no use! This class will be removed at the beginning of Luna (4.4) development.  Since:  1.0      The following features are supported:    Opaque Item    Restriction:  This interface is not intended to be referenced by clients.    "
208,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MOpaqueMenuSeparator.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
 A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MMenuElement  A representation of the model object 'Separator'.        An element representing a separator in a menu.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MMenuSeparator  A representation of the model object 'Opaque Menu Separator'.      Do no use! This class will be removed at the beginning of Luna (4.4) development.  Since:  1.0      The following features are supported:    Opaque Item    Restriction:  This interface is not intended to be referenced by clients.    "
209,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MOpaqueMenu.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MMenu  A representation of the model object 'Opaque Menu'.      Do no use! This class will be removed at the beginning of Luna (4.4) development.  Since:  1.0    Restriction:  This interface is not intended to be referenced by clients.    "
210,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenuFactory.html, The Factory for the model.  It provides a create method for each non-abstract class of the model.  Since:  1.0      
211,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MItem.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MUIElement_ MUILabel  A representation of the model object 'Item'.        This is the base type for various menu and toolbar items.    Since:  1.0      The following features are supported:    Enabled  Selected  Type      "
212,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/fragment/MFragmentFactory.html, The Factory for the model.  It provides a create method for each non-abstract class of the model.  Since:  1.0      
213,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/di/UISynchronize.html,extends Object Widget toolkit abstract to synchronize back into the UI-Thread from other  threads  Since:  1.0  Restriction:  This class is not intended to be subclassed by clients.    
214,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseEvent.html,extends TypedEvent Instances of this class are sent whenever mouse  related actions occur. This includes mouse buttons  being pressed and released_ the mouse pointer being   moved and the mouse pointer crossing widget boundaries.    Note: The button field is an integer that  represents the mouse button number. This is not the same  as the SWT mask constants BUTTONx.    See Also:  MouseListener_  MouseMoveListener_  MouseTrackListener_  Sample code and further information_  Serialized Form    
215,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ControlEvent.html,extends TypedEvent Instances of this class are sent as a result of  controls being moved or resized.  See Also:  ControlListener_  Sample code and further information_  Serialized Form    
216,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MTrimBar.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MGenericTrimContainer<MTrimElement>_ MUIElement  A representation of the model object 'Trim Bar'.        This is a concrete class representing the trim along a Window's edge.    Since:  1.0      The following features are supported:    Pending Cleanup      "
217,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/service/debug/DebugOptions.html,Used to get debug options settings and creating a new DebugTrace instance for  a bundle to use for dynamic tracing.  Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
218,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/service/debug/DebugTrace.html,"A DebugTrace is used to record debug trace statements_ based on the current  option settings in a corresponding DebugOptions class. The trace implementation  will automatically insert additional contextual information such as the bundle_ class_   and method performing the tracing.     Trace statements may be written to a file_ or onto standard output_ depending on   how the DebugOptions is configured.      All methods on this class have an optional option argument.  When specified_ this argument will cause the tracing to be conditional on the value  of DebugOptions.getBooleanOption(String_ boolean)_ where the bundle's  symbolic name will automatically be prepended to the provided option string. For example_  if your bundle symbolic name is ""com.acme.bundle""_ and you provide an option argument  of ""/debug/parser""_ the trace will only be printed if the option ""com.acme.bundle/debug/parser""  has a value of ""true"".      Note that the pipe character (""|"") is reserved for internal use. If this character   happens to occur in any of the thread name_ the option_ the message or an Exception  message_ it will be escaped to the corresponding HTML representation (""&#124;"").     Since:  3.5  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
219,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/EModelService.html,This service is used to find_ create and handle model elements  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.    
220,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IParameter.html," A parameter for a command. A parameter identifies a type of information that  the command might accept. For example_ a ""Show View"" command might accept the  id of a view for display. This parameter also identifies possible values_ for  display in the user interface.    Since:  3.1    "
221,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MCommandParameter.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Command Parameter'.        This represents the format of a parameter to be used in a Command.    Since:  1.0      The following features are supported:    Name  Type Id  Optional      "
222,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/CommandManagerEvent.html,extends Object  An event indicating that the set of defined command identifiers has changed.    Since:  3.1  See Also:  ICommandManagerListener.commandManagerChanged(CommandManagerEvent)    
223,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MHandler.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Contribution'.        MContribution is a mix-in class used by concrete elements such as Parts to define  the location of the client supplied class implementing the specific logic needed.    Since:  1.0      The following features are supported:    Contribution URI  Object      
extends MContribution  A representation of the model object 'Handler'.        Handlers provide the execution logic that provides the implementation of a  particular command.    Since:  1.0      The following features are supported:    Command      "
224,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/EPartService.html,The part service provides clients with the functionalities of showing and hiding parts. Part  events can also be tracked via the part service.    It is expected that any methods that are exposed by this service that takes an MPart  as an argument be a part that is actually being managed by this service.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.    
225,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/IPartListener.html, Since:  1.0  Restriction:  This interface is not intended to be referenced by clients.    
226,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/advanced/MPerspectiveStack.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement  A representation of the model object 'Part Sash Container Element'.        A class to be mixed in to any element that should be allowed to be added to  a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement  we can defined nested 'trees' of sash containment.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MUIElement  A representation of the model object 'Window Element'.        A class to be mixed in to any element that should be allowed to be added to a  Window.    Since:  1.0      
extends MUIElement_ MGenericStack<MPerspective>_ MPartSashContainerElement_ MWindowElement  A representation of the model object 'Perspective Stack'.        The PerspectiveStack is a collectin of Perspectives. Only one perspective may be  visible at a time and is determined by the container's 'selectedElement'.    Since:  1.0      "
227,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/IDelta.html, Since:  1.0  Restriction:  This interface is not intended to be referenced by clients.    
228,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/ExpressionInfo.html,extends Object A status object describing information about an expression tree.  This information can for example be used to decide whether an  expression tree has to be reevaluated if the value of some  variables changes.    This class is not intended to be extended by clients.    Since:  3.2  Restriction:  This class is not intended to be subclassed by clients.    
229,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MCoreExpression.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Expression'.        A class upon which specific types of expressions are based. These are often used to  evaluate visibility and enablement of model elements.    Since:  1.0      
extends MExpression  A representation of the model object 'Core Expression'.        A specific kind of expression used by the Eclipse Workbench.    Since:  1.0      The following features are supported:    Core Expression Id  Core Expression      "
230,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/Expression.html,extends Object Abstract base class for all expressions provided by the common  expression language.    An expression is evaluated by calling evaluate(IEvaluationContext).      This class may be subclassed to provide specific expressions.    Since:  3.0    
231,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/IWorkbench.html,A running instance of the workbench.    This instance is published through:  the IEclipseContext of the application  the OSGi-Service-Registry  It is possible that there are multiple active IWorkbench instances in one  OSGi-Instance  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.    
232,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IContributor.html,This interface describes a registry contributor - an entity that supplies information  to the extension registry.     Registry contributor objects can be obtained by calling IExtensionPoint.getContributor()_   IExtension.getContributor()_ and IConfigurationElement.getContributor().  Alternatively_ a contributor factory appropriate for the registry in use can be called to directly  obtain an IContributor object.    This interface can be used without OSGi running.    This interface is not intended to be implemented or extended by clients.    Since:  org.eclipse.equinox.registry 3.2  See Also:  ContributorFactoryOSGi_  ContributorFactorySimple  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
233,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/fragment/MModelFragments.html, A representation of the model object 'Model Fragments'.        Developers:  Add more detailed documentation by editing this comment in   /org.eclipse.e4.ui.model.workbench/model/ModelFragment.ecore.   There is a GenModel/documentation node under each type and attribute.    Since:  1.0      The following features are supported:    Imports  Fragments      
234,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/fragment/MModelFragment.html, A representation of the model object 'Model Fragment'.        Developers:  Add more detailed documentation by editing this comment in   /org.eclipse.e4.ui.model.workbench/model/ModelFragment.ecore.   There is a GenModel/documentation node under each type and attribute.    Since:  1.0      The following features are supported:    Elements      
235,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/ModelReconciler.html,extends Object  Since:  1.0  Restriction:  This class is not intended to be referenced by clients.    
236,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/ModelDelta.html," Since:  1.0  Restriction:  This interface is not intended to be referenced by clients.    
extends Object implements IDelta  Since:  1.0  Restriction:  This class is not intended to be referenced by clients.    "
237,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/core/services/events/IEventBroker.html,To obtain an instance of the event broker service from the IEclipseContext context_ use      (IEventBroker) context.get(IEventBroker.class.getName())    Since:  1.1  Restriction:  This interface is not intended to be implemented by clients.    
238,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/advanced/MArea.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement  A representation of the model object 'Part Sash Container Element'.        A class to be mixed in to any element that should be allowed to be added to  a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement  we can defined nested 'trees' of sash containment.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MUIElement  A representation of the model object 'Window Element'.        A class to be mixed in to any element that should be allowed to be added to a  Window.    Since:  1.0      
extends MGenericTile<MPartSashContainerElement>_ MPartSashContainerElement_ MWindowElement  A representation of the model object 'Part Sash Container'.        This is the concrete class representing sashed containment in the UI Model. This  type is recursive_ allowing the creation of a tree of sashes whose leafs are Parts.    Since:  1.0      
extends MUIElement  A representation of the model object 'Part Sash Container Element'.        A class to be mixed in to any element that should be allowed to be added to  a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement  we can defined nested 'trees' of sash containment.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MUIElement  A representation of the model object 'Window Element'.        A class to be mixed in to any element that should be allowed to be added to a  Window.    Since:  1.0      
extends MPartSashContainer_ MUILabel  A representation of the model object 'Area'.        This is a concrete element representing a (possibly sashed) chunk of the UI presentation  that will minimize / maximize as one unit. This is used in Eclipse 4 to allow for a split  Editor Area.    Since:  1.0      "
239,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MTrimmedWindow.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Bindings'.        Mixin interface that lists MBindingContexts that should be active when this  object is active.    Example values: org.eclipse.ui.contexts.dialog_ org.eclipse.ui.contexts.window    Since:  1.0      The following features are supported:    Binding Contexts      
 A representation of the model object 'Context'.        This class is mixed into a UI element when that element is expected to participate  in the Dependency Injection context hierarchy. The context life-cycle matches  that of the rendered element it belongs to. It's automatically created when the  element is rendered and disposed when the element is unrendered.    Since:  1.0      The following features are supported:    Context  Variables  Properties      
 A representation of the model object 'Handler Container'.        This provides a container in which to store lists of Handlers.     Since:  1.0      The following features are supported:    Handlers      
 A representation of the model object 'Snippet Container'.        This provides a collection of model fragments that can be subsequently cloned and  inserterd into the model using the EModelService. For example saving a customized  Perspective will create a clone and store it in this container.    Since:  1.0      The following features are supported:    Snippets      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
 A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Bindings'.        Mixin interface that lists MBindingContexts that should be active when this  object is active.    Example values: org.eclipse.ui.contexts.dialog_ org.eclipse.ui.contexts.window    Since:  1.0      The following features are supported:    Binding Contexts      
 A representation of the model object 'Context'.        This class is mixed into a UI element when that element is expected to participate  in the Dependency Injection context hierarchy. The context life-cycle matches  that of the rendered element it belongs to. It's automatically created when the  element is rendered and disposed when the element is unrendered.    Since:  1.0      The following features are supported:    Context  Variables  Properties      
 A representation of the model object 'Handler Container'.        This provides a container in which to store lists of Handlers.     Since:  1.0      The following features are supported:    Handlers      
 A representation of the model object 'Snippet Container'.        This provides a collection of model fragments that can be subsequently cloned and  inserterd into the model using the EModelService. For example saving a customized  Perspective will create a clone and store it in this container.    Since:  1.0      The following features are supported:    Snippets      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MElementContainer<MWindowElement>_ MUILabel_ MContext_ MHandlerContainer_ MBindings_ MSnippetContainer  A representation of the model object 'Window'.        This is the concrete class representing a bare bones window in the UI Model. Unless  specifically desired it's likely better to use the TrimmedWindow instead.    Since:  1.0      The following features are supported:    Main Menu  X  Y  Width  Height  Windows  Shared Elements      
extends MWindow  A representation of the model object 'Trimmed Window'.        A subclass of Window that also supports TrimBars on its edges.    Since:  1.0      The following features are supported:    Trim Bars      "
240,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/EPlaceholderResolver.html,This service is used to resolve references from MPlaceholders.    The issue is that we may be storing a cloned snippet which contains references to 'shared  elements' but instantiating the snippet in a new window requires that the shared elements list be  updated.  Since:  1.0  Restriction:  This interface is not intended to be referenced by clients.    
241,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MPartStack.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MUIElement  A representation of the model object 'Part Sash Container Element'.        A class to be mixed in to any element that should be allowed to be added to  a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement  we can defined nested 'trees' of sash containment.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
extends MUIElement  A representation of the model object 'Window Element'.        A class to be mixed in to any element that should be allowed to be added to a  Window.    Since:  1.0      
extends MGenericStack<MStackElement>_ MPartSashContainerElement_ MWindowElement  A representation of the model object 'Part Stack'.        This is the concrete class representing a stack of Parts in the UI Model.    Since:  1.0      "
242,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/IPresentationEngine.html,The presentation engine is used to translate the generic workbench model into widgets.  Implementations of this service are responsible for creating or destroying widgets corresponding  to model elements_ as well as for running any event loop required for handling user events on  those widgets.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.    
243,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IParameterValues.html, The parameters for a command. This interface will only be consulted if the  parameters need to be displayed to the user. Otherwise_ they will be ignored.    Since:  3.1    
244,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MElementContainer.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
T extends MUIElement> extends MUIElement  A representation of the model object 'Element Container'.        This is the base for the two different types of containment used in the model;  'Stacks' (where only one element would be visible at a time) and 'Tiles' (where   all the ele elements are visible at the same time.    All containers define the type of element that they are to contain. By design this is  always a single type. Where different concrete types are to be contained within the  same container they all both mix in a container-specific type. For example both  MParts and MPlaceholders are valid children for an MPartStack so they both mix in  'StackElement' (which is an empty stub used only to constran the stack's types.    Since:  1.0      The following features are supported:    Children  Selected Element      "
245,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MInputPart.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Bindings'.        Mixin interface that lists MBindingContexts that should be active when this  object is active.    Example values: org.eclipse.ui.contexts.dialog_ org.eclipse.ui.contexts.window    Since:  1.0      The following features are supported:    Binding Contexts      
 A representation of the model object 'Context'.        This class is mixed into a UI element when that element is expected to participate  in the Dependency Injection context hierarchy. The context life-cycle matches  that of the rendered element it belongs to. It's automatically created when the  element is rendered and disposed when the element is unrendered.    Since:  1.0      The following features are supported:    Context  Variables  Properties      
extends MApplicationElement  A representation of the model object 'Contribution'.        MContribution is a mix-in class used by concrete elements such as Parts to define  the location of the client supplied class implementing the specific logic needed.    Since:  1.0      The following features are supported:    Contribution URI  Object      
 A representation of the model object 'Dirtyable'.        This class should be mixed into any UI element that should participate in the  dirty / save handling. Parts are the most likely scenario for this but it exists as  a mix-in to allow for future model extensions.    Since:  1.0      The following features are supported:    Dirty      
 A representation of the model object 'Handler Container'.        This provides a container in which to store lists of Handlers.     Since:  1.0      The following features are supported:    Handlers      
 A representation of the model object 'Input'.        This class should be mixed into UI elements such as InputParts that need to   reference an external resource (files...).    Since:  1.0      The following features are supported:    Input URI      
extends MUIElement  A representation of the model object 'Part Sash Container Element'.        A class to be mixed in to any element that should be allowed to be added to  a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement  we can defined nested 'trees' of sash containment.    Since:  1.0      
extends MUIElement  A representation of the model object 'Stack Element'.        A class to be mixed in to any element that should be allowed to be added to a  PartStack.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MUIElement  A representation of the model object 'Window Element'.        A class to be mixed in to any element that should be allowed to be added to a  Window.    Since:  1.0      
extends MPart_ MInput  A representation of the model object 'Input Part'.        This is a subclass of Part that allows tracking of an 'input'. While originally defined as  a type of 'editor' it turns out that it may well be better to just use a regular Part and  to store what would be the input as an entry on the Part's 'persistentData' map.    Since:  1.0      "
246,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/IModelReconcilingService.html, Since:  1.0  Restriction:  This interface is not intended to be referenced by clients.    
247,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/ISelectionListener.html, Since:  1.0  Restriction:  This interface is not intended to be referenced by clients.    
248,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MBindingTable.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Binding Table'.        A set of Bindings that will be active if the matching MBindingContext  is active.    Since:  1.0      The following features are supported:    Bindings  Binding Context      "
249,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MKeySequence.html, A representation of the model object 'Key Sequence'.        This represents the sequence of characters in a KeyBinding whose detection will  fire the associated Command.    Since:  1.0      The following features are supported:    Key Sequence      
250,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MKeyBinding.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
 A representation of the model object 'Key Sequence'.        This represents the sequence of characters in a KeyBinding whose detection will  fire the associated Command.    Since:  1.0      The following features are supported:    Key Sequence      
extends MApplicationElement_ MKeySequence  A representation of the model object 'Key Binding'.        Keybindings map a particular keyboard sequence (i.e. Ctrl + C for Copy...) onto  some command.    Since:  1.0      The following features are supported:    Command  Parameters      "
251,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/MAddon.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Contribution'.        MContribution is a mix-in class used by concrete elements such as Parts to define  the location of the client supplied class implementing the specific logic needed.    Since:  1.0      The following features are supported:    Contribution URI  Object      
extends MContribution  A representation of the model object 'Addon'.        An MAddon represents a self-contained application logic. Addons may be used  to augment the UI in a variety of ways without requriing that the base application  be aware of the extensions.    Addons aare expected to be capable of being removed without damage to the  original UI. While not yet implemented there will be an uninstall protocol defined  ni the future allowing an addon to remove any model elements specific to the  addon (i.e. The MinMaxAddon's TrimElements.    Since:  1.0      "
252,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MParameter.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Parameter'.        This defines the value of a Parameter to be used by a Command.    Since:  1.0      The following features are supported:    Name  Value      "
253,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Region.html,extends Resource Instances of this class represent areas of an x-y coordinate  system that are aggregates of the areas covered by a number  of polygons.    Application code must explicitly invoke the Region.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    See Also:  SWT Example: GraphicsExample_  Sample code and further information    
254,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/DragDetectEvent.html,extends MouseEvent Instances of this class are sent as a result of  a drag gesture.  Since:  3.3  See Also:  DragDetectListener_  Sample code and further information_  Serialized Form    
255,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/KeyEvent.html,extends TypedEvent Instances of this class are sent as a result of  keys being pressed and released on the keyboard.    When a key listener is added to a control_ the control  will take part in widget traversal. By default_ all  traversal keys (such as the tab key and so on) are  delivered to the control. In order for a control to take  part in traversal_ it should listen for traversal events.  Otherwise_ the user can traverse into a control but not  out. Note that native controls such as table and tree  implement key traversal in the operating system. It is  not necessary to add traversal listeners for these controls_  unless you want to override the default traversal.    See Also:  KeyListener_  TraverseListener_  Sample code and further information_  Serialized Form    
256,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/services/IStylingEngine.html, Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be referenced by clients.    
257,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/MenuItem.html,extends Item Instances of this class represent a selectable user interface object  that issues notification when pressed and released.   Styles:  CHECK_ CASCADE_ PUSH_ RADIO_ SEPARATOR  Events:  Arm_ Help_ Selection    Note: Only one of the styles CHECK_ CASCADE_ PUSH_ RADIO and SEPARATOR  may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
258,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Menu.html,extends Widget Instances of this class are user interface objects that contain  menu items.  Styles:  BAR_ DROP_DOWN_ POP_UP_ NO_RADIO_GROUP  LEFT_TO_RIGHT_ RIGHT_TO_LEFT  Events:  Help_ Hide_ Show     Note: Only one of BAR_ DROP_DOWN and POP_UP may be specified.  Only one of LEFT_TO_RIGHT or RIGHT_TO_LEFT may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Menu snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
259,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/TraverseEvent.html,extends KeyEvent Instances of this class are sent as a result of  widget traversal actions.    The traversal event allows fine control over keyboard traversal  in a control both to implement traversal and override the default  traversal behavior defined by the system. This is achieved using  two fields_ detail and doit.    When a control is traversed_ a traverse event is sent. The detail  describes the type of traversal and the doit field indicates the default  behavior of the system. For example_ when a right arrow key is pressed  in a text control_ the detail field is TRAVERSE_ARROW_NEXT  and the doit field is false_ indicating that the system  will not traverse to the next tab item and the arrow key will be  delivered to the text control. If the same key is pressed in a radio  button_ the doit field will be true_ indicating that  traversal is to proceed to the next tab item_ possibly another radio  button in the group and that the arrow key is not to be delivered  to the radio button.    How can the traversal event be used to implement traversal?  When a tab key is pressed in a canvas_ the detail field will be  TRAVERSE_TAB_NEXT and the doit field will be  false. The default behavior of the system is to  provide no traversal for canvas controls. This means that by  default in a canvas_ a key listener will see every key that the  user types_ including traversal keys. To understand why this  is so_ it is important to understand that only the widget implementor  can decide which traversal is appropriate for the widget. Returning  to the TRAVERSE_TAB_NEXT example_ a text widget implemented  by a canvas would typically want to use the tab key to insert a  tab character into the widget. A list widget implementation_ on the  other hand_ would like the system default traversal behavior. Using  only the doit flag_ both implementations are possible. The text widget  implementor sets doit to false_ ensuring that the system  will not traverse and that the tab key will be delivered to key listeners.  The list widget implementor sets doit to true_ indicating  that the system should perform tab traversal and that the key should not  be delivered to the list widget.    How can the traversal event be used to override system traversal?  When the return key is pressed in a single line text control_ the  detail field is TRAVERSE_RETURN and the doit field  is true. This means that the return key will be processed  by the default button_ not the text widget. If the text widget has  a default selection listener_ it will not run because the return key  will be processed by the default button. Imagine that the text control  is being used as an in-place editor and return is used to dispose the  widget. Setting doit to false will stop the system from  activating the default button but the key will be delivered to the text  control_ running the key and selection listeners for the text. How  can TRAVERSE_RETURN be implemented so that the default button  will not be activated and the text widget will not see the return key?  This is achieved by setting doit to true_ and the detail  to TRAVERSE_NONE.    Note: A widget implementor will typically implement traversal using  only the doit flag to either enable or disable system traversal.    See Also:  TraverseListener_  Sample code and further information_  Serialized Form    
260,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TableViewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends AbstractTableViewer A concrete viewer based on a SWT Table control.    This class is not intended to be subclassed outside the viewer framework. It  is designed to be instantiated with a pre-existing SWT table control and  configured with a domain-specific content provider_ table label provider_  element filter (optional)_ and element sorter (optional).      Label providers for table viewers must implement either the  ITableLabelProvider or the ILabelProvider interface  (see TableViewer.setLabelProvider for more details).      As of 3.1 the TableViewer now supports the SWT.VIRTUAL flag. If the  underlying table is SWT.VIRTUAL_ the content provider may implement ILazyContentProvider instead of IStructuredContentProvider . Note  that in this case_ the viewer does not support sorting or filtering. Also  note that in this case_ the Widget based APIs may return null if the element  is not specified or not created yet.      Users of SWT.VIRTUAL should also avoid using getItems() from the Table within  the TreeViewer as this does not necessarily generate a callback for the  TreeViewer to populate the items. It also has the side effect of creating all  of the items thereby eliminating the performance improvements of SWT.VIRTUAL.      Users setting up an editable table with more than 1 column have to pass the  SWT.FULL_SELECTION style bit    See Also:  SWT.VIRTUAL_  doFindItem(Object)_  AbstractTableViewer.internalRefresh(Object_ boolean)  Restriction:  This class is not intended to be subclassed by clients.    "
261,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/FontMetrics.html,extends Object Instances of this class provide measurement information  about fonts including ascent_ descent_ height_ leading  space between rows_ and average character width.  FontMetrics are obtained from GCs  using the getFontMetrics() method.  See Also:  GC.getFontMetrics()_  Sample code and further information    
262,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ModifyEvent.html,extends TypedEvent Instances of this class are sent as a result of  text being modified.  See Also:  ModifyListener_  Sample code and further information_  Serialized Form    
263,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IBaseLabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    "
264,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider Extends IBaseLabelProvider with the methods  to provide the text and/or image for the label of a given element.   Used by most structured viewers_ except table viewers.    "
265,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ImageDescriptor.html,extends DeviceResourceDescriptor An image descriptor is an object that knows how to create  an SWT image. It does not hold onto images or cache them_  but rather just creates them on demand. An image descriptor  is intended to be a lightweight representation of an image  that can be manipulated even when no SWT display exists.    This package defines a concrete image descriptor implementation  which reads an image from a file (FileImageDescriptor).  It also provides abstract framework classes (this one and  CompositeImageDescriptor) which may be subclassed to define  news kinds of image descriptors.      Using this abstract class involves defining a concrete subclass  and providing an implementation for the getImageData  method.      There are two ways to get an Image from an ImageDescriptor. The method  createImage will always return a new Image which must be disposed by  the caller. Alternatively_ createResource() returns a shared  Image. When the caller is done with an image obtained from createResource_  they must call destroyResource() rather than disposing the Image directly.  The result of createResource() can be safely cast to an Image.     See Also:  Image    
266,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IContributionItem.html,A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
267,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IContributionManager.html,A contribution manager organizes contributions to such UI components  as menus_ toolbars and status lines.    A contribution manager keeps track of a list of contribution  items. Each contribution item may has an optional identifier_ which can be used  to retrieve items from a manager_ and for positioning items relative to  each other. The list of contribution items can be subdivided into named groups   using special contribution items that serve as group markers.      The IContributionManager interface provides general  protocol for adding_ removing_ and retrieving contribution items.  It also provides convenience methods that make it convenient  to contribute actions. This interface should be implemented  by all objects that wish to manage contributions.      There are several implementions of this interface in this package_  including ones for menus (MenuManager)_  tool bars (ToolBarManager)_  and status lines (StatusLineManager).      
268,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IMenuManager.html,extends IContributionManager_ IContributionItem The IMenuManager interface provides protocol for managing  contributions to a menu bar and its sub menus.  An IMenuManager is also an IContributionItem_  allowing sub-menus to be nested in parent menus.    This interface is internal to the framework; it should not be implemented outside  the framework.      This package provides a concrete menu manager implementation_  MenuManager.    Restriction:  This interface is not intended to be implemented by clients.    
269,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/MenuManager.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
A contribution manager organizes contributions to such UI components  as menus_ toolbars and status lines.    A contribution manager keeps track of a list of contribution  items. Each contribution item may has an optional identifier_ which can be used  to retrieve items from a manager_ and for positioning items relative to  each other. The list of contribution items can be subdivided into named groups   using special contribution items that serve as group markers.      The IContributionManager interface provides general  protocol for adding_ removing_ and retrieving contribution items.  It also provides convenience methods that make it convenient  to contribute actions. This interface should be implemented  by all objects that wish to manage contributions.      There are several implementions of this interface in this package_  including ones for menus (MenuManager)_  tool bars (ToolBarManager)_  and status lines (StatusLineManager).      
extends IContributionManager_ IContributionItem The IMenuManager interface provides protocol for managing  contributions to a menu bar and its sub menus.  An IMenuManager is also an IContributionItem_  allowing sub-menus to be nested in parent menus.    This interface is internal to the framework; it should not be implemented outside  the framework.      This package provides a concrete menu manager implementation_  MenuManager.    Restriction:  This interface is not intended to be implemented by clients.    
extends ContributionManager implements IMenuManager A menu manager is a contribution manager which realizes itself and its items  in a menu control; either as a menu bar_ a sub-menu_ or a context menu.    This class may be instantiated; it may also be subclassed.      "
270,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Pattern.html,extends Resource Instances of this class represent patterns to use while drawing. Patterns  can be specified either as bitmaps or gradients.    Application code must explicitly invoke the Pattern.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.      This class requires the operating system's advanced graphics subsystem  which may not be available on some platforms.    Since:  3.1  See Also:  Path_ Pattern snippets_  SWT Example: GraphicsExample_  Sample code and further information    
271,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/IResourceUtilities.html,ImageDesc> This interface describes a utility that is used to load ImageDesc's from URIs  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.    
272,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/LocalResourceManager.html,extends ResourceManager A local registry that shares its resources with some global registry.  LocalResourceManager is typically used to safeguard against leaks. Clients  can use a nested registry to allocate and deallocate resources in the  global registry. Calling dispose() on the nested registry will deallocate  everything allocated for the nested registry without affecting the rest  of the global registry.    A nested registry can be used to manage the resources for_ say_ a dialog  box.    Since:  3.1    
273,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IMenuCreator.html,Interface for something that creates and disposes of SWT menus. Note that  it is the responsibility of the implementor to dispose of SWT menus it  creates.    
274,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MDynamicMenuContribution.html," A representation of the model object 'Element'.        This is the root element for all UI Model elements_ defining attribtues common  to every element; the element's id as well as three general storage elements:    Tags: This is a set of strings which can be used to stereotype a particular  element. Tags may be specified in element searches and can also be referred  to in the CSS styling definition.  PersistedState: A string to string map used to store information that nneds  to be persisted between sessions.  TransientData: A string to object map which can be used to store runtime data  relevant to a particular model element.    Since:  1.0      The following features are supported:    Element Id  Persisted State  Tags  Contributor URI  Transient Data      
extends MApplicationElement  A representation of the model object 'Contribution'.        MContribution is a mix-in class used by concrete elements such as Parts to define  the location of the client supplied class implementing the specific logic needed.    Since:  1.0      The following features are supported:    Contribution URI  Object      
extends MUIElement_ MUILabel  A representation of the model object 'Element'.        This is the bsae type for both menu items and Separators.    Since:  1.0      The following features are supported:    Mnemonics      
extends MItem_ MMenuElement  A representation of the model object 'Item'.        This is the base type for both Handled and direct menu items.    Since:  1.0      
extends MApplicationElement  A representation of the model object 'UI Element'.        This is the base mix-in shared by all model elements that can be rendered into the  UI presentation of the application. Its main job is to manage the bindings between  the concrete element and the UI 'widget' representing it in the UI.    Since:  1.0      The following features are supported:    Widget  Renderer  To Be Rendered  On Top  Visible  Parent  Container Data  Cur Shared Ref  Visible When  Accessibility Phrase      
 A representation of the model object 'UI Label'.        This is a mix in that will be used for UI Elements that are capable of showing label  information in the GUI (e.g. Parts_ Menus / Toolbars_ Persepectives...)    Since:  1.0      The following features are supported:    Label  Icon URI  Tooltip      
extends MMenuItem_ MContribution  A representation of the model object 'Dynamic Menu Contribution'.        This is a concrete class used to represent a menu item that replaces itself through  the execution of the associated client code. The supplied contribution will  provide the appropriate MMenuElement model elements when queried.    Since:  1.0      "
275,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/core/contexts/IContextFunction.html,A context function encapsulates evaluation of some code within an  IEclipseContext. The result of the function must be derived purely  from the provided arguments and context objects_ and must be free from  side-effects other than the function's return value. In particular_ the  function must be idempotent - subsequent invocations of the same function  with the same inputs must produce the same result.    A common use for context functions is as a place holder for an object that  has not yet been created. These place holders can be stored as values in an  IEclipseContext_ allowing the concrete value they represent to be  computed lazily only when requested.      Context functions can optionally be registered as OSGi services. Context  implementations may use such registered services to seed context instances  with initial values. Registering your context function as a service is a  signal that contexts are free to add an instance of your function to their  context automatically_ using the key specified by the  SERVICE_CONTEXT_KEY service property.    Since:  1.3  See Also:  IEclipseContext.set(String_ Object)  Restriction:  This interface is not intended to be implemented by clients.  Function implementations must subclass ContextFunction  instead.    
276,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/AbstractGroupMarker.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
extends ContributionItem Abstract superclass for group marker classes.    This class is not intended to be subclassed outside the framework.    Restriction:  This class is not intended to be subclassed by clients.    "
277,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/StackLayout.html,"extends Layout This Layout stacks all the controls one on top of the other and resizes all controls  to have the same size and location.  The control specified in topControl is visible and all other controls are not visible.  Users must set the topControl value to flip between the visible items and then call   layout() on the composite which has the StackLayout.    Here is an example which places ten buttons in a stack layout and   flips between them:      public static void main(String[] args) {  Display display = new Display();  Shell shell = new Shell(display);  shell.setLayout(new GridLayout());    final Composite parent = new Composite(shell_ SWT.NONE);  parent.setLayoutData(new GridData(GridData.FILL_BOTH));  final StackLayout layout = new StackLayout();  parent.setLayout(layout);  final Button[] bArray = new Button[10];  for (int i = 0; i < 10; i++) {  bArray[i] = new Button(parent_ SWT.PUSH);  bArray[i].setText(""Button ""+i);  }  layout.topControl = bArray[0];    Button b = new Button(shell_ SWT.PUSH);  b.setText(""Show Next Button"");  final int[] index = new int[1];  b.addListener(SWT.Selection_ new Listener(){  public void handleEvent(Event e) {  index[0] = (index[0] + 1) % 10;  layout.topControl = bArray[index[0]];  parent.layout();  }  });    shell.open();  while (shell != null && !shell.isDisposed()) {  if (!display.readAndDispatch())  display.sleep();   }   }    See Also:  StackLayout snippets_  SWT Example: LayoutExample_  Sample code and further information    "
278,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ContributionItem.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
extends Object implements IContributionItem An abstract base implementation for contribution items.    "
279,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IToolBarManager.html,extends IContributionManager The IToolBarManager interface provides protocol for managing  contributions to a tool bar. It extends IContributionManager  but does not declare any new members; it exists only to increase the  readability of code using tool bars.    This package also provides a concrete tool bar manager implementation_  ToolBarManager.      
280,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ToolBarManager.html,"A contribution manager organizes contributions to such UI components  as menus_ toolbars and status lines.    A contribution manager keeps track of a list of contribution  items. Each contribution item may has an optional identifier_ which can be used  to retrieve items from a manager_ and for positioning items relative to  each other. The list of contribution items can be subdivided into named groups   using special contribution items that serve as group markers.      The IContributionManager interface provides general  protocol for adding_ removing_ and retrieving contribution items.  It also provides convenience methods that make it convenient  to contribute actions. This interface should be implemented  by all objects that wish to manage contributions.      There are several implementions of this interface in this package_  including ones for menus (MenuManager)_  tool bars (ToolBarManager)_  and status lines (StatusLineManager).      
extends IContributionManager The IToolBarManager interface provides protocol for managing  contributions to a tool bar. It extends IContributionManager  but does not declare any new members; it exists only to increase the  readability of code using tool bars.    This package also provides a concrete tool bar manager implementation_  ToolBarManager.      
extends ContributionManager implements IToolBarManager A tool bar manager is a contribution manager which realizes itself and its  items in a tool bar control.    This class may be instantiated; it may also be subclassed if a more  sophisticated layout is required.      "
281,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/RowLayout.html,extends Layout Instances of this class determine the size and position of the   children of a Composite by placing them either in   horizontal rows or vertical columns within the parent Composite.     RowLayout aligns all controls in one row if the  type is set to horizontal_ and one column if it is  set to vertical. It has the ability to wrap_ and provides configurable   margins and spacing. RowLayout has a number of configuration   fields. In addition_ the height and width of each control in a   RowLayout can be specified by setting a RowData  object into the control using setLayoutData ().      The following example code creates a RowLayout_ sets all   of its fields to non-default values_ and then sets it into a   Shell.     RowLayout rowLayout = new RowLayout();  rowLayout.wrap = false;  rowLayout.pack = false;  rowLayout.justify = true;  rowLayout.type = SWT.VERTICAL;  rowLayout.marginLeft = 5;  rowLayout.marginTop = 5;  rowLayout.marginRight = 5;  rowLayout.marginBottom = 5;  rowLayout.spacing = 0;  shell.setLayout(rowLayout);    If you are using the default field values_ you only need one line of code:    shell.setLayout(new RowLayout());      See Also:  RowData_  RowLayout snippets_  SWT Example: LayoutExample_  Sample code and further information    
282,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/RowData.html,"extends Object Each control controlled by a RowLayout can have its initial   width and height specified by setting a RowData object   into the control.    The following code uses a RowData object to change the initial  size of a Button in a Shell:    Display display = new Display();  Shell shell = new Shell(display);  shell.setLayout(new RowLayout());  Button button1 = new Button(shell_ SWT.PUSH);  button1.setText(""Button 1"");  button1.setLayoutData(new RowData(50_ 40));      See Also:  RowLayout_  Sample code and further information    "
283,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleEvent.html,extends org.eclipse.swt.internal.SWTEventObject Instances of this class are sent as a result of  accessibility clients sending messages to controls  asking for information about the control instance.    Note: The meaning of the result field depends  on the message that was sent.    Since:  2.0  See Also:  AccessibleListener_  AccessibleAdapter_  Sample code and further information_  Serialized Form    
284,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/Accessible.html,extends Object Instances of this class provide a bridge between application  code and assistive technology clients. Many platforms provide  default accessible behavior for most widgets_ and this class  allows that default behavior to be overridden. Applications  can get the default Accessible object for a control by sending  it getAccessible_ and then add an accessible listener  to override simple items like the name and help string_ or they  can add an accessible control listener to override complex items.  As a rule of thumb_ an application would only want to use the  accessible control listener to implement accessibility for a  custom control.  Since:  2.0  See Also:  Control.getAccessible()_  AccessibleListener_  AccessibleEvent_  AccessibleControlListener_  AccessibleControlEvent_  Accessibility snippets_  Sample code and further information    
285,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated as mouse buttons  are pressed.    After creating an instance of a class that implements  this interface it can be added to a control using the  addMouseListener method and removed using  the removeMouseListener method. When a  mouse button is pressed or released_ the appropriate method  will be invoked.    See Also:  MouseAdapter_  MouseEvent    
286,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CTabFolder2Listener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated by the CTabFolder   control.    After creating an instance of a class that implements  this interface it can be added to a CTabFolder using the  addCTabFolder2Listener method and removed using  the removeCTabFolder2Listener method. When  events occurs in a CTabFolder the appropriate method  will be invoked.    Since:  3.0  See Also:  CTabFolder2Adapter_  CTabFolderEvent    
287,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CTabFolder2Adapter.html,"extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated by the CTabFolder   control.    After creating an instance of a class that implements  this interface it can be added to a CTabFolder using the  addCTabFolder2Listener method and removed using  the removeCTabFolder2Listener method. When  events occurs in a CTabFolder the appropriate method  will be invoked.    Since:  3.0  See Also:  CTabFolder2Adapter_  CTabFolderEvent    
extends Object implements CTabFolder2Listener This adapter class provides default implementations for the  methods described by the CTabFolder2Listener interface.    Classes that wish to deal with CTabFolderEvents can  extend this class and override only the methods which they are  interested in.    Since:  3.0  See Also:  CTabFolder2Listener_  CTabFolderEvent_  Sample code and further information    "
288,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MenuDetectEvent.html,extends TypedEvent Instances of this class are sent whenever the platform-  specific trigger for showing a context menu is detected.  Since:  3.3  See Also:  MenuDetectListener_  Sample code and further information_  Serialized Form    
289,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Monitor.html,extends Object Instances of this class are descriptions of monitors.  Since:  3.0  See Also:  Display_  Monitor snippets_  Sample code and further information    
290,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/core/contexts/RunAndTrack.html,extends Object Instances of this class contain behavior that is executed within an  IEclipseContext. The context records all values accessed by this  object_ and will re-evaluate this runnable whenever any accessed value changes.  Since:  1.3  See Also:  IEclipseContext.runAndTrack(RunAndTrack)    
291,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IContributionManagerOverrides.html,This interface is used by instances of IContributionItem  to determine if the values for certain properties have been overriden  by their manager.    This interface is internal to the framework; it should not be implemented outside  the framework.    Since:  2.0  Restriction:  This interface is not intended to be implemented by clients.    
292,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ShellEvent.html,extends TypedEvent Instances of this class are sent as a result of  operations being performed on shells.  See Also:  ShellListener_  Sample code and further information_  Serialized Form    
293,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/IWindowCloseHandler.html,A handler that can be inserted into the context of the application or a particular window to  determine whether the window should be closed or not.  Since:  1.0  Restriction:  This interface is not intended to be referenced by clients.    
294,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Transform.html,extends Resource Instances of this class represent transformation matrices for   points expressed as (x_ y) pairs of floating point numbers.    Application code must explicitly invoke the Transform.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.      This class requires the operating system's advanced graphics subsystem  which may not be available on some platforms.    Since:  3.1  See Also:  SWT Example: GraphicsExample_  Sample code and further information    
295,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/equinox/app/IApplicationContext.html,The context used to start an application.    This interface is not intended to be implemented by clients.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
296,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IProduct.html,Products are the Eclipse unit of branding. From the runtime point of view they have  a name_ id and description and identify the Eclipse application to run.     Since the bulk of the branding related information is  specific to the UI_ products also carry an arbitrary set of properties. The valid set of   key-value pairs and their interpretation defined by the UI of the target environment.  For example_ in the standard Eclipse UI_ org.eclipse.ui.branding.IProductConstants  the properties of interest to the UI. Other clients may specify additional properties.    Products can be defined directly using extensions to the org.eclipse.core.runtime.products  extension point or by using facilities provided by IProductProvider implementations.    For readers familiar with Eclipse 2.1 and earlier_ products are roughly equivalent to   primary features.     Since:  3.0  See Also:  IProductProvider    
297,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/testing/TestableObject.html,extends Object A testable object.  Allows a test harness to register itself with a testable object.  The test harness is notified of test-related lifecycle events_  such as when is an appropriate time to run tests on the object.  This also provides API for running tests as a runnable_ and for signaling  when the tests are starting and when they are finished.    The workbench provides an implementation of this facade_ available  via PlatformUI.getTestableObject().    Since:  3.0    
298,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/services/EContextService.html, Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.    
299,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/Status.html,"A status object represents the outcome of an operation.  All CoreExceptions carry a status object to indicate   what went wrong. Status objects are also returned by methods needing   to provide details of failures (e.g._ validation methods).    A status carries the following information:    plug-in identifier (required)  severity (required)  status code (required)  message (required) - localized to current locale  exception (optional) - for problems stemming from a failure at  a lower level  Some status objects_ known as multi-statuses_ have other status objects   as children.      The class Status is the standard public implementation  of status objects; the subclass MultiStatus is the  implements multi-status objects.    This interface can be used without OSGi running.    See Also:  MultiStatus_  Status    
extends Object implements IStatus A concrete status implementation_ suitable either for   instantiating or subclassing.    This class can be used without OSGi running.      "
300,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/IShellProvider.html,Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
301,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IDialogSettings.html,An interface to a storage mechanism for making dialog settings persistent.  The store manages a collection of key/value pairs. The keys must be strings  and the values can be either_ strings or array of strings. Convenience API to  convert primitive types to strings is provided.  See Also:  DialogSettings    
302,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TreeItem.html,extends Item Instances of this class represent a selectable user interface object  that represents a hierarchy of tree items in a tree widget.    Styles:  (none)  Events:  (none)    IMPORTANT: This class is not intended to be subclassed.    See Also:  Tree_ TreeItem_ TreeColumn snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
303,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/FocusEvent.html,extends TypedEvent Instances of this class are sent as a result of  widgets gaining and losing focus.  See Also:  FocusListener_  Sample code and further information_  Serialized Form    
304,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IAction.html,An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
305,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleControlEvent.html,extends org.eclipse.swt.internal.SWTEventObject Instances of this class are sent as a result of  accessibility clients sending messages to controls  asking for detailed information about the implementation  of the control instance. Typically_ only implementors  of custom controls need to listen for this event.    Note: The meaning of each field depends on the  message that was sent.    Since:  2.0  See Also:  AccessibleControlListener_  AccessibleControlAdapter_  Sample code and further information_  Serialized Form    
306,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IContentProvider.html,A content provider mediates between the viewer's model  and the viewer itself.  See Also:  ContentViewer.setContentProvider(IContentProvider)    
307,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IStructuredContentProvider.html,extends IContentProvider An interface to content providers for structured viewers.  See Also:  StructuredViewer    
308,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITreeContentProvider.html,"A content provider mediates between the viewer's model  and the viewer itself.  See Also:  ContentViewer.setContentProvider(IContentProvider)    
extends IContentProvider An interface to content providers for structured viewers.  See Also:  StructuredViewer    
extends IStructuredContentProvider An interface to content providers for tree-structure-oriented  viewers.  See Also:  AbstractTreeViewer    "
309,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/DoubleClickEvent.html,extends EventObject Event object describing a double-click. The source of these  events is a viewer.  See Also:  IDoubleClickListener_  Serialized Form    
310,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/Scheme.html," An object that is unique identifiable based on the combination of its class  and its identifier.    Since:  3.2  See Also:  HandleObject    
extends NamedHandleObject implements Comparable  An instance of IScheme is a handle representing a binding  scheme as defined by the extension point org.eclipse.ui.bindings.  The identifier of the handle is the identifier of the scheme being represented.      An instance of IScheme can be obtained from an instance of  ICommandManager for any identifier_ whether or not a scheme  with that identifier is defined in the plugin registry.      The handle-based nature of this API allows it to work well with runtime  plugin activation and deactivation. If a scheme is defined_ that means that  its corresponding plug-in is active. If the plug-in is then deactivated_ the  scheme will still exist but it will be undefined. An attempt to use an  undefined scheme will result in a NotDefinedException  being thrown.      This class is not intended to be extended by clients.    Since:  3.1  See Also:  ISchemeListener_  CommandManager    "
311,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/IPropertyChangeListener.html,extends EventListener Listener for property changes.    Usage:    IPropertyChangeListener listener =  new IPropertyChangeListener() {  public void propertyChange(PropertyChangeEvent event) {  ... // code to deal with occurrence of property change  }  };  emitter.addPropertyChangeListener(listener);  ...  emitter.removePropertyChangeListener(listener);        
312,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/PropertyChangeEvent.html,extends EventObject An event object describing a change to a named property.    This concrete class was designed to be instantiated_ but may  also be subclassed if required.      The JFace frameworks contain classes that report property   change events for internal state changes that may be of interest  to external parties. A special listener interface  (IPropertyChangeListener) is defined for this purpose_  and a typical class allow listeners to be registered via  an addPropertyChangeListener method.    See Also:  IPropertyChangeListener_  Serialized Form    
313,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/HelpListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the event that is generated when help is  requested for a control_ typically when the user presses F1.    After creating an instance of a class that implements  this interface it can be added to a control using the  addHelpListener method and removed using  the removeHelpListener method. When help  is requested for a control_ the helpRequested method  will be invoked.    See Also:  HelpEvent    
314,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/IKeyLookup.html, A facilitiy for converting the formal representation for key strokes  (i.e._ used in persistence) into real key stroke instances.    Since:  3.1    
315,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/Trigger.html,extends Object implements Comparable  The abstract class for any object that can be used as a trigger for a binding.   This ensures that trigger conform to certain minimum requirements. Namely_ triggers   need to be hashable.    Since:  3.1    
316,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/KeyStroke.html,"extends Trigger implements Comparable  A KeyStroke is defined as an optional set of modifier keys  followed optionally by a natural key. A KeyStroke is said to  be complete if it contains a natural key. A natural key is any Unicode  character (e.g._ ""backspace""_ etc.)_ any character belonging to a natural  language (e.g._ ""A""_ ""1""_ ""[""_ etc.)_ or any special control character  specific to computers (e.g._ ""F10""_ ""PageUp""_ etc.).      All KeyStroke objects have a formal string representation  available via the toString() method. There are a number of  methods to get instances of KeyStroke objects_ including one  which can parse this formal string representation.      All KeyStroke objects_ via the format() method_  provide a version of their formal string representation translated by  platform and locale_ suitable for display to a user.      KeyStroke objects are immutable. Clients are not permitted to  extend this class.    Since:  3.1    "
317,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ResourceManager.html,extends Object This class manages SWT resources. It manages reference-counted instances of resources  such as Fonts_ Images_ and Colors_ and allows them to be accessed using descriptors.  Everything allocated through the registry should also be disposed through the registry.  Since the resources are shared and reference counted_ they should never be disposed  directly.    ResourceManager handles correct allocation and disposal of resources. It differs from   the various JFace *Registry classes_ which also map symbolic IDs onto resources. In   general_ you should use a *Registry class to map IDs onto descriptors_ and use a   ResourceManager to convert the descriptors into real Images/Fonts/etc.    Since:  3.1    
318,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/CoolBar.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class provide an area for dynamically  positioning the items they contain.    The item children that may be added to instances of this class  must be of type CoolItem.    Note that although this class is a subclass of Composite_  it does not make sense to add Control children to it_  or set a layout on it.      Styles:  FLAT_ HORIZONTAL_ VERTICAL  Events:  (none)    Note: Only one of the styles HORIZONTAL and VERTICAL may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  CoolBar snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
319,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/CoolItem.html,extends Item Instances of this class are selectable user interface  objects that represent the dynamically positionable  areas of a CoolBar.  Styles:  DROP_DOWN  Events:  Selection    IMPORTANT: This class is not intended to be subclassed.    See Also:  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
320,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Decorations.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Canvas Instances of this class provide the appearance and  behavior of Shells_ but are not top  level shells or dialogs. Class Shell  shares a significant amount of code with this class_  and is a subclass.    IMPORTANT: This class was intended to be abstract and  should never be referenced or instantiated.  Instead_ the class Shell should be used.      Instances are always displayed in one of the maximized_   minimized or normal states:      When an instance is marked as maximized_ the  window manager will typically resize it to fill the  entire visible area of the display_ and the instance  is usually put in a state where it can not be resized   (even if it has style RESIZE) until it is  no longer maximized.      When an instance is in the normal state (neither  maximized or minimized)_ its appearance is controlled by  the style constants which were specified when it was created  and the restrictions of the window manager (see below).      When an instance has been marked as minimized_  its contents (client area) will usually not be visible_  and depending on the window manager_ it may be  ""iconified"" (that is_ replaced on the desktop by a small  simplified representation of itself)_ relocated to a  distinguished area of the screen_ or hidden. Combinations  of these changes are also possible.      Note: The styles supported by this class must be treated  as HINTs_ since the window manager for the  desktop on which the instance is visible has ultimate  control over the appearance and behavior of decorations.  For example_ some window managers only support resizable  windows and will always assume the RESIZE style_ even if  it is not set.  Styles:  BORDER_ CLOSE_ MIN_ MAX_ NO_TRIM_ RESIZE_ TITLE_ ON_TOP_ TOOL  Events:  (none)  Class SWT provides two ""convenience constants""  for the most commonly required style combinations:  SHELL_TRIM    the result of combining the constants which are required  to produce a typical application top level shell: (that   is_ CLOSE | TITLE | MIN | MAX | RESIZE)    DIALOG_TRIM    the result of combining the constants which are required  to produce a typical application dialog shell: (that   is_ TITLE | CLOSE | BORDER)      IMPORTANT: This class is intended to be subclassed only  within the SWT implementation.    See Also:  getMinimized()_  getMaximized()_  Shell_  SWT_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
321,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MenuEvent.html,extends TypedEvent Instances of this class are sent as a result of  menus being shown and hidden.  See Also:  MenuListener_  Sample code and further information_  Serialized Form    
322,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/Clipboard.html,extends Object The Clipboard provides a mechanism for transferring data from one  application to another or within an application.    IMPORTANT: This class is not intended to be subclassed.  See Also:  Clipboard snippets_  SWT Example: ClipboardExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
323,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes that implement this interface provide methods  that deal with the events that are generated when an  accessibility client sends a message to a control.    After creating an instance of a class that implements  this interface it can be added to a control using the  addAccessibleListener method and removed  using the removeAccessibleListener method.  When a client requests information_ the appropriate method  will be invoked.    Note: Accessibility clients use child identifiers to specify  whether they want information about a control or one of its children.  Child identifiers are increasing integers beginning with 0.  The identifier CHILDID_SELF represents the control itself.    Since:  2.0  See Also:  AccessibleAdapter_  AccessibleEvent    
324,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/contexts/ContextManagerEvent.html,extends AbstractBitSetEvent  An event indicating that the set of defined context identifiers has changed.    Since:  3.1  See Also:  IContextManagerListener.contextManagerChanged(ContextManagerEvent)    
325,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/formatting/IKeyFormatter.html, Any formatter capable of taking a key sequence or a key stroke and converting  it into a string. These formatters are used to produce the strings that the  user sees in the keys preference page and the menus_ as well as the strings  that are used for persistent storage.    Since:  3.1    
326,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IHandlerListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of IHandler.    This interface may be implemented by clients.    Since:  3.1  See Also:  IHandler.addHandlerListener(IHandlerListener)_  IHandler.removeHandlerListener(IHandlerListener)    
327,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/IPreferenceStore.html,"The IPreferenceStore interface represents a table mapping  named preferences to values. If there is no value for a given name_  then that preferences's default value is returned; and if there is no  default value for that preference_ then a default-default value is returned.  The default-default values for the primitive types are as follows:  boolean = false  double = 0.0  float = 0.0f  int = 0  long = 0  String = """" (the empty string)    Thus a preference store maintains two values for each of a set of  names: a current value and a default value.  The typical usage is to establish the defaults for all known preferences  and then restore previously stored values for preferences whose values  were different from their defaults. After the current values of  the preferences have been modified_ it is a simple matter to write  out only those preferences whose values are different from their defaults.  This two-tiered approach to saving and restoring preference setting  minimized the number of preferences that need to be persisted; indeed_  the normal starting state does not require storing any preferences  at all.      A property change event is reported whenever a preferences current  value actually changes (whether through setValue_  setToDefault_ or other unspecified means). Note_ however_  that manipulating default values (with setDefault)  does not cause such events to be reported.      Clients who need a preference store may implement this interface or  instantiate the standard implementation PreferenceStore.    See Also:  PreferenceStore    "
328,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FormData.html,extends Object Instances of this class are used to define the attachments   of a control in a FormLayout.     To set a FormData object into a control_ you use the   setLayoutData () method. To define attachments for the   FormData_ set the fields directly_ like this:    FormData data = new FormData();  data.left = new FormAttachment(0_5);  data.right = new FormAttachment(100_-5);  button.setLayoutData(formData);        FormData contains the FormAttachments for   each edge of the control that the FormLayout uses to  determine the size and position of the control. FormData  objects also allow you to set the width and height of controls within  a FormLayout.     Since:  2.0  See Also:  FormLayout_  FormAttachment_  Sample code and further information    
329,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/List.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Scrollable Instances of this class represent a selectable user interface  object that displays a list of strings and issues notification  when a string is selected. A list may be single or multi select.      Styles:  SINGLE_ MULTI  Events:  Selection_ DefaultSelection    Note: Only one of SINGLE and MULTI may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  List snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
330,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/FieldDecorationRegistry.html,extends Object FieldDecorationRegistry is a common registry used to define shared field  decorations within an application. Unlike resource registries_ the  FieldDecorationRegistry does not perform any lifecycle management of the  decorations.      Clients may specify images for the decorations in several different ways.  Images may be described by their image id in a specified  ImageRegistry. In this case_ the life cycle of the image is managed  by the image registry_ and the decoration registry will not attempt to obtain  an image from the image registry until the decoration is actually requested.  In cases where the client has access to an already-created image_ the image  itself can be specified when registering the decoration. In this case_ the  life cycle should be managed by the specifying client.    Since:  3.2  See Also:  FieldDecoration_  ImageRegistry    
331,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/layout/GridDataFactory.html,"extends Object This class provides a convienient shorthand for creating and initializing  GridData. This offers several benefits over creating GridData normal way:    The same factory can be used many times to create several GridData instances  The setters on GridDataFactory all return ""this""_ allowing them to be chained  GridDataFactory uses vector setters (it accepts Points)_ making it easy to  set X and Y values together      GridDataFactory instances are created using one of the static methods on this class.         Example usage:        ////////////////////////////////////////////////////////////  // Example 1: Typical grid data for a non-wrapping label    // GridDataFactory version  GridDataFactory.fillDefaults().applyTo(myLabel);    // Equivalent SWT version  GridData labelData = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.VERTICAL_ALIGN_FILL);  myLabel.setLayoutData(labelData);    ///////////////////////////////////////////////////////////  // Example 2: Typical grid data for a wrapping label    // GridDataFactory version  GridDataFactory.fillDefaults()  .align(SWT.FILL_ SWT.CENTER)  .hint(150_ SWT.DEFAULT)  .grab(true_ false)  .applyTo(wrappingLabel);    // Equivalent SWT version  GridData wrappingLabelData = new GridData(GridData.FILL_HORIZONTAL | GridData.VERTICAL_ALIGN_CENTER);  wrappingLabelData.minimumWidth = 1;  wrappingLabelData.widthHint = 150;  wrappingLabel.setLayoutData(wrappingLabelData);    //////////////////////////////////////////////////////////////  // Example 3: Typical grid data for a scrollable control (a list box_ tree_ table_ etc.)    // GridDataFactory version  GridDataFactory.fillDefaults().grab(true_ true).hint(150_ 150).applyTo(listBox);    // Equivalent SWT version  GridData listBoxData = new GridData(GridData.FILL_BOTH);  listBoxData.widthHint = 150;  listBoxData.heightHint = 150;  listBoxData.minimumWidth = 1;  listBoxData.minimumHeight = 1;  listBox.setLayoutData(listBoxData);    /////////////////////////////////////////////////////////////  // Example 4: Typical grid data for a button  // GridDataFactory version  Point preferredSize = button.computeSize(SWT.DEFAULT_ SWT.DEFAULT_ false);  Point hint = Geometry.max(LayoutConstants.getMinButtonSize()_ preferredSize);  GridDataFactory.fillDefaults().align(SWT.FILL_ SWT.CENTER).hint(hint).applyTo(button);  // Equivalent SWT version  Point preferredSize = button.computeSize(SWT.DEFAULT_ SWT.DEFAULT_ false);  Point hint = Geometry.max(LayoutConstants.getMinButtonSize()_ preferredSize);  GridData buttonData = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.VERTICAL_ALIGN_CENTER);  buttonData.widthHint = hint.x;  buttonData.heightHint = hint.y;  button.setLayoutData(buttonData);    /////////////////////////////////////////////////////////////  // Example 5: Generated GridData  // Generates GridData a wrapping label that spans 2 columns  GridDataFactory.generate(wrappingLabel_ 2_ 1);    // Generates GridData for a listbox. and adjusts the preferred size to 300x400 pixels  GridDataFactory.defaultsFor(listBox).hint(300_ 400).applyTo(listBox);    // Generates GridData equivalent to example 4  GridDataFactory.generate(button_ 1_ 1);      Since:  3.2    "
332,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/layout/GridLayoutFactory.html,"extends Object GridLayoutFactory creates and initializes grid layouts. There are two ways to use GridLayoutFactory.  Normally_ it is used as a shorthand for writing ""new GridLayout()"" and initializing a bunch   of fields. In this case the main benefit is a more concise syntax and the ability to create more  than one identical GridLayout from the same factory. Changing a property of the factory will affect  future layouts created by the factory_ but has no effect on layouts that have already been created.      GridLayoutFactory can also generate grid data for all the controls in a layout. This is done with  the generateLayout method. To use this feature:      Create the composite  Create all the controls in the composite  Call generateLayout      The order here is important. generateLayout must be called after all the child controls have  been created. generateLayout will not change any layout data that has already been attached  to a child control and it will not recurse into nested composites.     Since:  3.2    "
333,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Tracker.html,extends Widget Instances of this class implement rubber banding rectangles that are  drawn onto a parent Composite or Display.  These rectangles can be specified to respond to mouse and key events  by either moving or resizing themselves accordingly. Trackers are  typically used to represent window geometries in a lightweight manner.    Styles:  LEFT_ RIGHT_ UP_ DOWN_ RESIZE  Events:  Move_ Resize    Note: Rectangle move behavior is assumed unless RESIZE is specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Tracker snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
334,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/operation/IRunnableWithProgress.html,The IRunnableWithProgress interface should be implemented by any  class whose instances are intended to be executed as a long-running operation.  Long-running operations are typically presented at the UI via a modal dialog  showing a progress indicator and a Cancel button.  The class must define a run method that takes a progress monitor.  The run method is usually not invoked directly_ but rather by  passing the IRunnableWithProgress to the run method of  an IRunnableContext_ which provides the UI for the progress monitor  and Cancel button.  See Also:  IRunnableContext    
335,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FormLayout.html,extends Layout Instances of this class control the position and size of the   children of a composite control by using FormAttachments  to optionally configure the left_ top_ right and bottom edges of  each child.    The following example code creates a FormLayout and then sets  it into a Shell:    Display display = new Display ();  Shell shell = new Shell(display);  FormLayout layout = new FormLayout();  layout.marginWidth = 3;  layout.marginHeight = 3;  shell.setLayout(layout);        To use a FormLayout_ create a FormData with  FormAttachment for each child of Composite.  The following example code attaches button1 to the top  and left edge of the composite and button2 to the right  edge of button1 and the top and right edges of the  composite:    FormData data1 = new FormData();  data1.left = new FormAttachment(0_ 0);  data1.top = new FormAttachment(0_ 0);  button1.setLayoutData(data1);  FormData data2 = new FormData();  data2.left = new FormAttachment(button1);  data2.top = new FormAttachment(0_ 0);  data2.right = new FormAttachment(100_ 0);  button2.setLayoutData(data2);        Each side of a child control can be attached to a position in the parent   composite_ or to other controls within the Composite by  creating instances of FormAttachment and setting them into  the top_ bottom_ left_ and right fields of the child's FormData.      If a side is not given an attachment_ it is defined as not being attached  to anything_ causing the child to remain at its preferred size. If a child  is given no attachment on either the left or the right or top or bottom_ it is  automatically attached to the left and top of the composite respectively.  The following code positions button1 and button2  but relies on default attachments:    FormData data2 = new FormData();  data2.left = new FormAttachment(button1);  data2.right = new FormAttachment(100_ 0);  button2.setLayoutData(data2);        IMPORTANT: Do not define circular attachments. For example_ do not attach  the right edge of button1 to the left edge of button2  and then attach the left edge of button2 to the right edge of  button1. This will over constrain the layout_ causing undefined  behavior. The algorithm will terminate_ but the results are undefined.    Since:  2.0  See Also:  FormData_  FormAttachment_  FormLayout snippets_  SWT Example: LayoutExample_  Sample code and further information    
336,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleAttributeEvent.html,extends org.eclipse.swt.internal.SWTEventObject Instances of this class are sent as a result of accessibility clients  sending AccessibleAttribute messages to an accessible object.  Since:  3.6  See Also:  AccessibleAttributeListener_  AccessibleAttributeAdapter_  Serialized Form    
337,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/ToolTip.html,extends Object This class gives implementors to provide customized tooltips for any control.  Since:  3.3    
338,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Link.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Control Instances of this class represent a selectable  user interface object that displays a text with   links.      Styles:  (none)  Events:  Selection    IMPORTANT: This class is not intended to be subclassed.    Since:  3.1  See Also:  Link snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
339,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Combo.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class are controls that allow the user  to choose an item from a list of items_ or optionally   enter a new value by typing it into an editable text  field. Often_ Combos are used in the same place  where a single selection List widget could  be used but space is limited. A Combo takes  less space than a List widget and shows  similar information.    Note: Since Combos can contain both a list  and an editable text field_ it is possible to confuse methods  which access one versus the other (compare for example_  clearSelection() and deselectAll()).  The API documentation is careful to indicate either ""the  receiver's list"" or the ""the receiver's text field"" to   distinguish between the two cases.    Note that although this class is a subclass of Composite_  it does not make sense to add children to it_ or set a layout on it.    Styles:  DROP_DOWN_ READ_ONLY_ SIMPLE  Events:  DefaultSelection_ Modify_ Selection_ Verify_ OrientationChange    Note: Only one of the styles DROP_DOWN and SIMPLE may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  List_  Combo snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
340,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MenuDetectListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated when the  platform-specific trigger for showing a context menu is  detected.    After creating an instance of a class that implements  this interface it can be added to a control or TrayItem  using the addMenuDetectListener method and  removed using the removeMenuDetectListener method.  When the context menu trigger occurs_ the  menuDetected method will be invoked.    Since:  3.3  See Also:  MenuDetectEvent    
341,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/SelectionListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated when selection  occurs in a control.    After creating an instance of a class that implements  this interface it can be added to a control using the  addSelectionListener method and removed using  the removeSelectionListener method. When  selection occurs in a control the appropriate method  will be invoked.    See Also:  SelectionAdapter_  SelectionEvent    
342,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ImageRegistry.html,extends Object An image registry maintains a mapping between symbolic image names   and SWT image objects or special image descriptor objects which  defer the creation of SWT image objects until they are needed.    An image registry owns all of the image objects registered  with it_ and automatically disposes of them when the SWT Display  that creates the images is disposed. Because of this_ clients do not   need to (indeed_ must not attempt to) dispose of these images themselves.      Clients may instantiate this class (it was not designed to be subclassed).      Unlike the FontRegistry_ it is an error to replace images. As a result  there are no events that fire when values are changed in the registry    Restriction:  This class is not intended to be subclassed by clients.    
343,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnLayoutData.html,extends Object An abstract column layout data describing the information needed   (by TableLayout) to properly lay out a table.     This class is not intended to be subclassed outside the framework.    Restriction:  This class is not intended to be subclassed by clients.    
344,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Scrollable.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Control This class is the abstract superclass of all classes which  represent controls that have standard scroll bars.  Styles:  H_SCROLL_ V_SCROLL  Events:    (none)    IMPORTANT: This class is intended to be subclassed only  within the SWT implementation.    See Also:  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
345,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnPixelData.html,extends ColumnLayoutData Describes the width of a table column in pixels_ and  whether the column is resizable.    This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    
346,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnWeightData.html,extends ColumnLayoutData Describes the width of a table column in terms of a weight_   a minimum width_ and whether the column is resizable.    This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    
347,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ColorDialog.html,extends Dialog Instances of this class allow the user to select a color  from a predefined set of available colors.  Styles:  (none)  Events:  (none)    IMPORTANT: This class is not intended to be subclassed.    See Also:  SWT Example: ControlExample_ Dialog tab_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
348,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/DirectoryDialog.html,extends Dialog Instances of this class allow the user to navigate  the file system and select a directory.  Styles:  (none)  Events:  (none)    IMPORTANT: This class is not intended to be subclassed.    See Also:  DirectoryDialog snippets_  SWT Example: ControlExample_ Dialog tab_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
349,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IDialogPage.html,Interface for a page in a multi-page dialog.    
350,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IMessageProvider.html,Minimal interface to a message provider. Used for dialog pages which can  provide a message with an icon.  Since:  2.0    
351,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/DialogPage.html,"Interface for a page in a multi-page dialog.    
Minimal interface to a message provider. Used for dialog pages which can  provide a message with an icon.  Since:  2.0    
extends Object implements IDialogPage_ IMessageProvider Abstract base implementation of a dialog page. All dialog pages are  subclasses of this one.    "
352,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/FileDialog.html,extends Dialog Instances of this class allow the user to navigate  the file system and select or enter a file name.  Styles:  SAVE_ OPEN_ MULTI  Events:  (none)    Note: Only one of the styles SAVE and OPEN may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  FileDialog snippets_  SWT Example: ControlExample_ Dialog tab_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
353,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/FontDialog.html,extends Dialog Instances of this class allow the user to select a font  from all available fonts in the system.  Styles:  (none)  Events:  (none)    IMPORTANT: This class is not intended to be subclassed.    See Also:  SWT Example: ControlExample_ Dialog tab_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
354,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/SafeRunnable.html,"Safe runnables represent blocks of code and associated exception  handlers. They are typically used when a plug-in needs to call some  untrusted code (e.g._ code contributed by another plug-in via an  extension).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  SafeRunner.run(ISafeRunnable)    
extends Object implements ISafeRunnable Implements a default implementation of ISafeRunnable. The default  implementation of handleException opens a dialog to show any  errors as they accumulate.    This may be executed on any thread.    "
355,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Sash.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Control Instances of the receiver represent a selectable user interface object  that allows the user to drag a rubber banded outline of the sash within  the parent control.  Styles:  HORIZONTAL_ VERTICAL_ SMOOTH  Events:  Selection    Note: Only one of the styles HORIZONTAL and VERTICAL may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Sash snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
356,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/HelpEvent.html,extends TypedEvent Instances of this class are sent as a result of  help being requested for a widget.  See Also:  HelpListener_  Sample code and further information_  Serialized Form    
357,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerComparator.html,extends Object A viewer comparator is used by a StructuredViewer to  reorder the elements provided by its content provider.    The default compare method compares elements using two steps.   The first step uses the values returned from category.   By default_ all elements are in the same category.   The second level is based on a case insensitive compare of the strings obtained   from the content viewer's label provider via ILabelProvider.getText.      Subclasses may implement the isSorterProperty method;  they may reimplement the category method to provide   categorization; and they may override the compare methods  to provide a totally different way of sorting elements.    Since:  3.2  See Also:  IStructuredContentProvider_  StructuredViewer    
358,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IPageChangedListener.html,A listener which is notified when the current page of the multi-page dialog  is changed.  Since:  3.1  See Also:  IPageChangeProvider_  PageChangedEvent    
359,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/PageChangedEvent.html,extends EventObject Event object describing a page selection change. The source of these events  is a page change provider.  Since:  3.1  See Also:  IPageChangeProvider_  IPageChangedListener_  Serialized Form    
360,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/PaletteData.html,extends Object Instances of this class describe the color data used by an image.    Depending on the depth of the image_ the PaletteData can take one  of two forms_ indicated by the isDirect field:      isDirect is false      If isDirect is false_ this palette is an indexed  palette which maps pixel values to RGBs. The actual RGB values  may be retrieved by using the getRGBs() method.      isDirect is true      If isDirect is true_ this palette is a direct color  palette. Instead of containing RGB values_ it contains red_  green and blue mask and shift information which indicates how  the color components may be extracted from a given pixel.  This means that the RGB value is actually encoded in the pixel value.    In this case_ the shift data is the number of bits required to shift  the RGB value to the left in order to align the high bit of the  corresponding mask with the high bit of the first byte. This number  may be negative_ so care must be taken when shifting. For example_  with a red mask of 0xFF0000_ the red shift would be -16. With a red  mask of 0x1F_ the red shift would be 3.      See Also:  Image_  RGB_  Sample code and further information    
361,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/SegmentEvent.html,"extends TypedEvent This event is sent to SegmentListeners when a text content is to be modified.  The segments field can be used in conjunction with the segmentsChars field or  by itself. Setting only the segmentsChars field has no effect. When used by  itself_ the segments field specify text ranges that should be treated as  separate segments.    The elements in the segments field specify the start offset of a segment  relative to the start of the text. They must follow the following rules:    elements must be in ascending order and must not have duplicates    elements must not exceed the text length    In addition_ the first element may be set to zero and the last element may   be set to the end of the line but this is not required.  The segments field may be left null if the entire text content doesn't  require segmentation.    A SegmentListener may be used when adjacent segments of right-to-left text  should not be reordered relative to each other. For example_ within a Java  editor_ you may wish multiple right-to-left string literals to be reordered  differently than the bidi algorithm specifies.   Example:    stored text = ""R1R2R3"" + ""R4R5R6""  R1 to R6 are right-to-left characters. The quotation marks  are part of the text. The text is 13 characters long.    segments = null:   entire text content will be reordered and thus the two R2L segments   swapped (as per the bidi algorithm).   visual display (rendered on screen) = ""R6R5R4"" + ""R3R2R1""    segments = [0_ 5_ 8]   ""R1R2R3"" will be reordered_ followed by [blank]+[blank] and   ""R4R5R6"".   visual display = ""R3R2R1"" + ""R6R5R4""        The segments and segmentsChars fields can be used together to obtain different  types of bidi reordering and text display. The application can use these two fields  to insert Unicode Control Characters in specific offsets in the text_ the character  at segmentsChars[i] is inserted at the offset specified by segments[i]. When both fields   are set_ the rules for the segments field are less restrictive:    elements must be in ascending order_ duplicates are allowed    elements must not exceed the text length      Since:  3.8  See Also:  Serialized Form    "
362,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/SegmentListener.html,extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive  SegmentEvents.  Since:  3.8  See Also:  SegmentEvent    
363,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/StyledText.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Canvas A StyledText is an editable user interface object that displays lines   of text. The following style attributes can be defined for the text:   foreground color     background color    font style (bold_ italic_ bold-italic_ regular)    underline    strikeout      In addition to text style attributes_ the background color of a line may   be specified.    There are two ways to use this widget when specifying text style information.   You may use the API that is defined for StyledText or you may define your own   LineStyleListener. If you define your own listener_ you will be responsible   for maintaining the text style information for the widget. IMPORTANT: You may   not define your own listener and use the StyledText API. The following  StyledText API is not supported if you have defined a LineStyleListener:    getStyleRangeAtOffset(int)    getStyleRanges()    replaceStyleRanges(int_int_StyleRange[])    setStyleRange(StyleRange)    setStyleRanges(StyleRange[])      There are two ways to use this widget when specifying line background colors.  You may use the API that is defined for StyledText or you may define your own   LineBackgroundListener. If you define your own listener_ you will be responsible   for maintaining the line background color information for the widget.   IMPORTANT: You may not define your own listener and use the StyledText API.   The following StyledText API is not supported if you have defined a   LineBackgroundListener:    getLineBackground(int)    setLineBackground(int_int_Color)      The content implementation for this widget may also be user-defined. To do so_  you must implement the StyledTextContent interface and use the StyledText API  setContent(StyledTextContent) to initialize the widget.       Styles:  FULL_SELECTION_ MULTI_ READ_ONLY_ SINGLE_ WRAP    Events:  ExtendedModify_ LineGetBackground_ LineGetSegments_ LineGetStyle_ Modify_ Selection_ Verify_ VerifyKey_ OrientationChange      IMPORTANT: This class is not intended to be subclassed.    See Also:  StyledText snippets_  SWT Examples: CustomControlExample_ TextEditor_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
364,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/BidiSegmentEvent.html,"extends SegmentEvent This event is sent to BidiSegmentListeners when a line is to  be measured or rendered in a bidi locale.   The segments field can be used in conjunction with the segmentsChars  field or by itself. Setting only the segmentsChars field has no effect.  When used by itself_ the segments field specify text ranges in the line  that should be treated as separate segments for bidi reordering. Each   segment will be reordered and rendered separately.    The elements in the segments field specify the start offset of   a segment relative to the start of the line. They must follow  the following rules:    elements must be in ascending order and must not have duplicates    elements must not exceed the line length    In addition_ the first element may be set to zero and the last element may   be set to the end of the line but this is not required.  The segments field may be left null if the entire line should   be reordered as is.    A BidiSegmentListener may be used when adjacent segments of   right-to-left text should not be reordered relative to each other.   For example_ within a Java editor_ you may wish multiple   right-to-left string literals to be reordered differently than the  bidi algorithm specifies.   Example:    stored line = ""R1R2R3"" + ""R4R5R6""  R1 to R6 are right-to-left characters. The quotation marks  are part of the line text. The line is 13 characters long.    segments = null:   entire line will be reordered and thus the two R2L segments   swapped (as per the bidi algorithm).   visual line (rendered on screen) = ""R6R5R4"" + ""R3R2R1""    segments = [0_ 5_ 8]   ""R1R2R3"" will be reordered_ followed by [blank]+[blank] and   ""R4R5R6"".   visual line = ""R3R2R1"" + ""R6R5R4""        The segments and segmentsChars fields can be used together to obtain different  types of bidi reordering and text display. The application can use these two fields  to insert Unicode Control Characters in specific offsets in the line_ the character  at segmentsChars[i] is inserted at the offset specified by segments[i]. When both fields   are set_ the rules for the segments field are less restrictive:    elements must be in ascending order_ duplicates are allowed    elements must not exceed the line length      See Also:  Sample code and further information_  Serialized Form    "
365,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DragSourceEvent.html,extends TypedEvent The DragSourceEvent contains the event information passed in the methods of the DragSourceListener.  See Also:  DragSourceListener_  Sample code and further information_  Serialized Form    
366,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DropTargetEvent.html,extends TypedEvent The DropTargetEvent contains the event information passed in the methods of the DropTargetListener.  See Also:  Sample code and further information_  Serialized Form    
367,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/TransferData.html,extends Object The TransferData class is a platform specific data structure for  describing the type and the contents of data being converted by a transfer agent.  As an application writer_ you do not need to know the specifics of   TransferData. TransferData instances are passed to a subclass of Transfer   and the Transfer object manages the platform specific issues.   You can ask a Transfer subclass if it can handle this data by calling   Transfer.isSupportedType(transferData).  You should only need to become familiar with the fields in this class if you   are implementing a Transfer subclass and you are unable to subclass the   ByteArrayTransfer class.  See Also:  Sample code and further information    
368,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TableTree.html,extends Composite A TableTree is a selectable user interface object  that displays a hierarchy of items_ and issues  notification when an item is selected.  A TableTree may be single or multi select.    The item children that may be added to instances of this class  must be of type TableTreeItem.    Note that although this class is a subclass of Composite_  it does not make sense to add Control children to it_  or set a layout on it.      Styles:   SINGLE_ MULTI_ CHECK_ FULL_SELECTION    Events:   Selection_ DefaultSelection_ Collapse_ Expand      Note: Only one of the styles SINGLE_ and MULTI may be specified.      
369,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TableTreeItem.html,extends Item A TableTreeItem is a selectable user interface object  that represents an item in a hierarchy of items in a  TableTree.    
370,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/AnimatorFactory.html,extends Object Factory for control animators used by JFace to animate the display of an SWT  Control. Through the use of the method  Policy.setAnimatorFactory(AnimatorFactory)   a new type of animator factory can be plugged into JFace.  Since:  3.2    
371,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/ErrorSupportProvider.html,extends Object A ErrorSupportProvider defines the area to be shown in an error dialog for extra support information.  Since:  3.3    
372,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CellLabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends BaseLabelProvider The CellLabelProvider is an abstract implementation of a label provider for  structured viewers.    This class is intended to be subclassed  Since:  3.3  See Also:  as a concrete implementation    "
373,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerCell.html,extends Object The ViewerCell is the JFace representation of a cell entry in a ViewerRow.  Since:  3.3    
374,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/equinox/bidi/custom/StructuredTextTypeHandler.html,extends Object Generic handler to be used as superclass (base class)  for specific structured text handlers.    Here are some guidelines about how to write structured text  handlers.    Handler instances may be accessed simultaneously by  several threads. They should have no instance variables.  This class provides common logic in code which can be invoked  by any structured text handler.   This common logic uses handler methods to query the  characteristics of the specific handler:  the separators which separate the structured text into  tokens. See getSeparators(org.eclipse.equinox.bidi.advanced.IStructuredTextExpert).  the direction which governs the display of tokens  one after the other. See getDirection(org.eclipse.equinox.bidi.advanced.IStructuredTextExpert_ java.lang.String).  the number of special cases which need to be handled by  code specific to that handler.  See getSpecialsCount(org.eclipse.equinox.bidi.advanced.IStructuredTextExpert).  Before starting deeper analysis of the submitted text_ the common  logic gives to the handler a chance to shorten the process by  invoking its skipProcessing(org.eclipse.equinox.bidi.advanced.IStructuredTextExpert_ java.lang.String_ org.eclipse.equinox.bidi.custom.StructuredTextCharTypes) method.  The common logic then analyzes the text to segment it into tokens  according to the appearance of separators (as retrieved using  getSeparators(org.eclipse.equinox.bidi.advanced.IStructuredTextExpert)).  If the handler indicated a positive number of special cases as  return value from its getSpecialsCount(org.eclipse.equinox.bidi.advanced.IStructuredTextExpert)  method_ the common logic will repeatedly invoke the handler's  indexOfSpecial(org.eclipse.equinox.bidi.advanced.IStructuredTextExpert_ java.lang.String_ org.eclipse.equinox.bidi.custom.StructuredTextCharTypes_ org.eclipse.equinox.bidi.custom.StructuredTextOffsets_ int_ int) method to let it signal the  presence of special strings which may further delimit the source text.  When such a special case is signaled by the handler_ the common  logic will call the handler's processSpecial(org.eclipse.equinox.bidi.advanced.IStructuredTextExpert_ java.lang.String_ org.eclipse.equinox.bidi.custom.StructuredTextCharTypes_ org.eclipse.equinox.bidi.custom.StructuredTextOffsets_ int_ int)  method to give it the opportunity to handle it as needed. Typical  actions that the handler may perform are to add directional marks  unconditionally (by calling insertMark(java.lang.String_ org.eclipse.equinox.bidi.custom.StructuredTextCharTypes_ org.eclipse.equinox.bidi.custom.StructuredTextOffsets_ int) or  conditionally (by calling processSeparator(java.lang.String_ org.eclipse.equinox.bidi.custom.StructuredTextCharTypes_ org.eclipse.equinox.bidi.custom.StructuredTextOffsets_ int)).    
375,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/Transfer.html,extends Object Transfer provides a mechanism for converting between a java   representation of data and a platform specific representation of data and   vice versa. It is used in data transfer operations such as drag and drop and   clipboard copy/paste.  You should only need to become familiar with this class if you are   implementing a Transfer subclass and you are unable to subclass the   ByteArrayTransfer class.  See Also:  ByteArrayTransfer_  Drag and Drop snippets_  SWT Example: DNDExample_  Sample code and further information    
376,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/TreeListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the expanding and collapsing of tree  branches.    After creating an instance of a class that implements  this interface it can be added to a tree control using the  addTreeListener method and removed using  the removeTreeListener method. When a branch  of the tree is expanded or collapsed_ the appropriate method  will be invoked.    See Also:  TreeAdapter_  TreeEvent    
377,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/TreeEvent.html,extends SelectionEvent Instances of this class are sent as a result of  trees being expanded and collapsed.  See Also:  TreeListener_  Sample code and further information_  Serialized Form    
378,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CCombo.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite The CCombo class represents a selectable user interface object  that combines a text field and a list and issues notification  when an item is selected from the list.    CCombo was written to work around certain limitations in the native  combo box. Specifically_ on win32_ the height of a CCombo can be set;  attempts to set the height of a Combo are ignored. CCombo can be used  anywhere that having the increased flexibility is more important than  getting native L&F_ but the decision should not be taken lightly.   There is no is no strict requirement that CCombo look or behave  the same as the native combo box.      Note that although this class is a subclass of Composite_  it does not make sense to add children to it_ or set a layout on it.    Styles:    BORDER_ READ_ONLY_ FLAT  Events:    DefaultSelection_ Modify_ Selection_ Verify  See Also:  CCombo snippets_  SWT Example: CustomControlExample_  Sample code and further information    "
379,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IFilter.html,Interface for filters. Can accept or reject items.  Since:  3.1    
380,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/FocusListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated as controls  gain and lose focus.    After creating an instance of a class that implements  this interface it can be added to a control using the  addFocusListener method and removed using  the removeFocusListener method. When a  control gains or loses focus_ the appropriate method  will be invoked.    See Also:  FocusAdapter_  FocusEvent    
381,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DragSourceListener.html,extends org.eclipse.swt.internal.SWTEventListener The DragSourceListener class provides event notification to the application for DragSource events.  When the user drops data on a DropTarget_ the application which defines the DragSource  must provide the dropped data by implementing dragSetData. In the dragSetData_ the application  must support all the data types that were specified in the DragSource#setTransfer method.  After the drop has completed successfully or has been aborted_ the application which defines the   DragSource is required to take the appropriate cleanup action. In the case of a successful   move operation_ the application must remove the data that was transferred.    
382,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DragSource.html,"extends Widget DragSource defines the source object for a drag and drop transfer.  IMPORTANT: This class is not intended to be subclassed.    A drag source is the object which originates a drag and drop operation. For the specified widget_   it defines the type of data that is available for dragging and the set of operations that can   be performed on that data. The operations can be any bit-wise combination of DND.MOVE_ DND.COPY or   DND.LINK. The type of data that can be transferred is specified by subclasses of Transfer such as   TextTransfer or FileTransfer. The type of data transferred can be a predefined system type or it   can be a type defined by the application. For instructions on how to define your own transfer type_  refer to ByteArrayTransfer.  You may have several DragSources in an application but you can only have one DragSource   per Control. Data dragged from this DragSource can be dropped on a site within this application   or it can be dropped on another application such as an external Text editor.    The application supplies the content of the data being transferred by implementing the  DragSourceListener and associating it with the DragSource via DragSource#addDragListener.    When a successful move operation occurs_ the application is required to take the appropriate   action to remove the data from its display and remove any associated operating system resources or  internal references. Typically in a move operation_ the drop target makes a copy of the data   and the drag source deletes the original. However_ sometimes copying the data can take a long   time (such as copying a large file). Therefore_ on some platforms_ the drop target may actually   move the data in the operating system rather than make a copy. This is usually only done in   file transfers. In this case_ the drag source is informed in the DragEnd event that a  DROP_TARGET_MOVE was performed. It is the responsibility of the drag source at this point to clean   up its displayed information. No action needs to be taken on the operating system resources.  The following example shows a Label widget that allows text to be dragged from it.      // Enable a label as a Drag Source  Label label = new Label(shell_ SWT.NONE);  // This example will allow text to be dragged  Transfer[] types = new Transfer[] {TextTransfer.getInstance()};  // This example will allow the text to be copied or moved to the drop target  int operations = DND.DROP_MOVE | DND.DROP_COPY;    DragSource source = new DragSource(label_ operations);  source.setTransfer(types);  source.addDragListener(new DragSourceListener() {  public void dragStart(DragSourceEvent e) {  // Only start the drag if there is actually text in the  // label - this text will be what is dropped on the target.  if (label.getText().length() == 0) {  event.doit = false;  }  };  public void dragSetData(DragSourceEvent event) {  // A drop has been performed_ so provide the data of the   // requested type.  // (Checking the type of the requested data is only   // necessary if the drag source supports more than   // one data type but is shown here as an example).  if (TextTransfer.getInstance().isSupportedType(event.dataType)){  event.data = label.getText();  }  }  public void dragFinished(DragSourceEvent event) {  // A Move operation has been performed so remove the data  // from the source  if (event.detail == DND.DROP_MOVE)  label.setText("""");  }  });    Styles  DND.DROP_NONE_ DND.DROP_COPY_ DND.DROP_MOVE_ DND.DROP_LINK  Events  DND.DragStart_ DND.DragSetData_ DND.DragEnd  See Also:  Drag and Drop snippets_  SWT Example: DNDExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
383,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DropTargetListener.html,extends org.eclipse.swt.internal.SWTEventListener The DropTargetListener class provides event notification to the application   for DropTarget events.  As the user moves the cursor into_ over and out of a Control that has been designated   as a DropTarget_ events indicate what operation can be performed and what data can be   transferred if a drop where to occur at that point.  The application can respond to these events and change the type of data that will   be dropped by modifying event.currentDataType_ or change the operation that will be performed   by modifying the event.detail field or stop any drop from happening on the current target  by setting the event.detail field to DND_DROP_NONE.  When the user causes a drop to happen by releasing the mouse over a valid drop target_   the application has one last chance to change the data type of the drop through the   DropAccept event. If the drop is still allowed_ the DropAccept event is immediately   followed by the Drop event. In the Drop event_ the application can still change the  operation that is performed but the data type is fixed.  See Also:  DropTargetEvent    
384,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DropTarget.html,extends Widget Class DropTarget defines the target object for a drag and drop transfer.  IMPORTANT: This class is not intended to be subclassed.  This class identifies the Control over which the user must position the cursor  in order to drop the data being transferred. It also specifies what data types can be dropped on   this control and what operations can be performed. You may have several DropTragets in an   application but there can only be a one to one mapping between a Control and a DropTarget.  The DropTarget can receive data from within the same application or from other applications   (such as text dragged from a text editor like Word).    int operations = DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK;  Transfer[] types = new Transfer[] {TextTransfer.getInstance()};  DropTarget target = new DropTarget(label_ operations);  target.setTransfer(types);    The application is notified of data being dragged over this control and of when a drop occurs by   implementing the interface DropTargetListener which uses the class   DropTargetEvent. The application can modify the type of drag being performed   on this Control at any stage of the drag by modifying the event.detail field or the   event.currentDataType field. When the data is dropped_ it is the responsibility of   the application to copy this data for its own purposes.    target.addDropListener (new DropTargetListener() {  public void dragEnter(DropTargetEvent event) {};  public void dragOver(DropTargetEvent event) {};  public void dragLeave(DropTargetEvent event) {};  public void dragOperationChanged(DropTargetEvent event) {};  public void dropAccept(DropTargetEvent event) {}  public void drop(DropTargetEvent event) {  // A drop has occurred_ copy over the data  if (event.data == null) { // no data to copy_ indicate failure in event.detail  event.detail = DND.DROP_NONE;  return;  }  label.setText ((String) event.data); // data copied to label text  }  });    Styles  DND.DROP_NONE_ DND.DROP_COPY_ DND.DROP_MOVE_ DND.DROP_LINK  Events  DND.DragEnter_ DND.DragLeave_ DND.DragOver_ DND.DragOperationChanged_   DND.DropAccept_ DND.Drop   See Also:  Drag and Drop snippets_  SWT Example: DNDExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
385,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/OpenStrategy.html,extends Object Implementation of single-click and double-click strategies.    Usage:    OpenStrategy handler = new OpenStrategy(control);  handler.addOpenListener(new IOpenEventListener() {  public void handleOpen(SelectionEvent e) {  ... // code to handle the open event.  }  });        
386,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/TextLayout.html,extends Resource TextLayout is a graphic object that represents  styled text.    Instances of this class provide support for drawing_ cursor  navigation_ hit testing_ text wrapping_ alignment_ tab expansion  line breaking_ etc. These are aspects required for rendering internationalized text.    Application code must explicitly invoke the TextLayout#dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    Since:  3.0  See Also:  TextLayout_ TextStyle snippets_  SWT Example: CustomControlExample_ StyledText tab_  Sample code and further information    
387,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/StyleRange.html,extends TextStyle implements org.eclipse.swt.internal.CloneableCompatibility StyleRange defines a set of styles for a specified  range of text.    The hashCode() method in this class uses the values of the public  fields to compute the hash value. When storing instances of the  class in hashed collections_ do not modify these fields after the  object has been inserted.    See Also:  Sample code and further information    
388,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ModifyListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the events that are generated when text  is modified.    After creating an instance of a class that implements  this interface it can be added to a text widget using the  addModifyListener method and removed using  the removeModifyListener method. When the  text is modified_ the modifyText method will be invoked.    See Also:  ModifyEvent    
389,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IStatusLineManager.html,extends IContributionManager The IStatusLineManager interface provides protocol  for displaying messages on a status line_ for monitoring progress_  and for managing contributions to the status line.    Note: An error message overrides the current message until  the error message is cleared.    This package also provides a concrete status line manager implementation_  StatusLineManager.      
390,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/StatusLineManager.html,"A contribution manager organizes contributions to such UI components  as menus_ toolbars and status lines.    A contribution manager keeps track of a list of contribution  items. Each contribution item may has an optional identifier_ which can be used  to retrieve items from a manager_ and for positioning items relative to  each other. The list of contribution items can be subdivided into named groups   using special contribution items that serve as group markers.      The IContributionManager interface provides general  protocol for adding_ removing_ and retrieving contribution items.  It also provides convenience methods that make it convenient  to contribute actions. This interface should be implemented  by all objects that wish to manage contributions.      There are several implementions of this interface in this package_  including ones for menus (MenuManager)_  tool bars (ToolBarManager)_  and status lines (StatusLineManager).      
extends IContributionManager The IStatusLineManager interface provides protocol  for displaying messages on a status line_ for monitoring progress_  and for managing contributions to the status line.    Note: An error message overrides the current message until  the error message is cleared.    This package also provides a concrete status line manager implementation_  StatusLineManager.      
extends ContributionManager implements IStatusLineManager A status line manager is a contribution manager which realizes itself and its items  in a status line control.    This class may be instantiated; it may also be subclassed if a more  sophisticated layout is required.      "
391,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ICoolBarManager.html,extends IContributionManager The ICoolBarManager interface provides protocol for managing  contributions to a cool bar. A cool bar manager delegates responsibility for  creating child controls to its contribution items by calling  IContributionItem.fill(CoolBar_ int).    This interface is internal to the framework; it should not be implemented  outside the framework. This package provides a concrete cool bar manager  implementation_ CoolBarManager_ which  clients may instantiate or subclass.    Since:  3.0  See Also:  ToolBarContributionItem    
392,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/CoolBarManager.html,"A contribution manager organizes contributions to such UI components  as menus_ toolbars and status lines.    A contribution manager keeps track of a list of contribution  items. Each contribution item may has an optional identifier_ which can be used  to retrieve items from a manager_ and for positioning items relative to  each other. The list of contribution items can be subdivided into named groups   using special contribution items that serve as group markers.      The IContributionManager interface provides general  protocol for adding_ removing_ and retrieving contribution items.  It also provides convenience methods that make it convenient  to contribute actions. This interface should be implemented  by all objects that wish to manage contributions.      There are several implementions of this interface in this package_  including ones for menus (MenuManager)_  tool bars (ToolBarManager)_  and status lines (StatusLineManager).      
extends IContributionManager The ICoolBarManager interface provides protocol for managing  contributions to a cool bar. A cool bar manager delegates responsibility for  creating child controls to its contribution items by calling  IContributionItem.fill(CoolBar_ int).    This interface is internal to the framework; it should not be implemented  outside the framework. This package provides a concrete cool bar manager  implementation_ CoolBarManager_ which  clients may instantiate or subclass.    Since:  3.0  See Also:  ToolBarContributionItem    
extends ContributionManager implements ICoolBarManager A cool bar manager is a contribution manager which realizes itself and its  items in a cool bar control.    This class may be instantiated; it may also be subclassed.    Since:  3.0    "
393,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CLabel.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Canvas A Label which supports aligned text and/or an image and different border styles.    If there is not enough space a CLabel uses the following strategy to fit the   information into the available space:    ignores the indent in left align mode  ignores the image and the gap  shortens the text by replacing the center portion of the label with an ellipsis  shortens the text by removing the center portion of the label        Styles:    LEFT_ RIGHT_ CENTER_ SHADOW_IN_ SHADOW_OUT_ SHADOW_NONE  Events:          This class may be subclassed for the purpose of overriding the default string  shortening algorithm that is implemented in method shortenText().    See Also:  SWT Example: CustomControlExample_  Sample code and further information_  shortenText(GC_ String_ int)    "
394,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ShellListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with changes in state of Shells.    After creating an instance of a class that implements  this interface it can be added to a shell using the  addShellListener method and removed using  the removeShellListener method. When the  state of the shell changes_ the appropriate method will  be invoked.    See Also:  ShellAdapter_  ShellEvent    
395,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/MessageDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends IconAndMessageDialog A dialog for showing messages to the user.    This concrete dialog class can be instantiated as is_ or further subclassed  as required.      Note: This class does not use button IDs from  IDialogConstants. Instead_ the ID is the index of the button in the supplied  array.      "
396,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/PageChangingEvent.html,extends EventObject Event object describing an IDialogPage in the midst of changing.  Since:  3.3  See Also:  IPageChangingListener_  Serialized Form    
397,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IPageChangingListener.html,A listener which is notified when the current page of a multi-page dialog is  changing. Use this listener to perform long-running work that should only be  executed once_ when the page is in the process of changing_ rather then  during validation of page controls.  Since:  3.3  See Also:  PageChangingEvent    
398,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/DataBindingContext.html,extends Object A DataBindingContext is the point of contact for the creation and management  of bindings_ and aggregates validation statuses of its  bindings_ or more generally_ its validation status providers.    A DataBindingContext provides the following abilities:    Ability to create bindings between  observable values.  Ability to create bindings between  observable lists.  Access to the bindings created by the instance.  Access to the list of validation status providers (this includes all  bindings).      Multiple contexts can be used at any point in time. One strategy for the  management of contexts is the aggregation of validation statuses. For example  an IWizardPage could use a single context and the statuses  could be aggregated to set the page status and fulfillment. Each page in the  IWizard would have its own context instance.    Since:  1.0    
399,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/ValidationStatusProvider.html,extends Object A validation status provider tracks the state of zero or more target  observables and zero or more model observables and produces a validation  result.  Since:  1.1    
400,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/TitleAreaDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends TrayDialog A dialog that has a title area for displaying a title and an image as well as  a common area for displaying a description_ a message_ or an error message.    This dialog class may be subclassed.    "
401,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/ControlDecoration.html,extends Object ControlDecoration renders an image decoration near a control. It allows  clients to specify an image and a position for the image relative to the  control. A ControlDecoration may be assigned description text_ which can  optionally be shown when the user hovers over the image. Clients can decorate  any kind of control.    Decoration images always appear on the left or right side of the field_ never  above or below it. Decorations can be positioned at the top_ center_ or  bottom of either side of the control. Future implementations may provide  additional positioning options for decorations.    ControlDecoration renders the image adjacent to the specified (already  created) control_ with no guarantee that it won't be clipped or otherwise  obscured or overlapped by adjacent controls_ including another  ControlDecoration placed in the same location. Clients should ensure that  there is adequate space adjacent to the control to show the decoration  properly.    Clients using ControlDecoration should typically ensure that enough margin  space is reserved for a decoration by altering the layout data margins_  although this is not assumed or required by the ControlDecoration  implementation.    This class is intended to be instantiated and used by clients. It is not  intended to be subclassed by clients.  Since:  3.3  See Also:  FieldDecoration_  FieldDecorationRegistry  Restriction:  This class is not intended to be subclassed by clients.    
402,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/FieldDecoration.html,extends Object FieldDecoration is a simple data structure class for specifying a decoration  for a field. A decoration may be rendered in different ways depending on the  type of field it is used with.  Since:  3.2  See Also:  FieldDecorationRegistry    
403,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/IPreferencePage.html,extends IDialogPage An interface for a preference page. This interface  is used primarily by the page's container    
404,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferencePage.html,"Interface for a page in a multi-page dialog.    
Minimal interface to a message provider. Used for dialog pages which can  provide a message with an icon.  Since:  2.0    
extends IDialogPage An interface for a preference page. This interface  is used primarily by the page's container    
extends DialogPage implements IPreferencePage Abstract base implementation for all preference page implementations.    Subclasses must implement the createContents framework  method to supply the page's main control.      Subclasses should extend the doComputeSize framework  method to compute the size of the page's control.      Subclasses may override the performOk_ performApply_   performDefaults_ performCancel_ and performHelp  framework methods to react to the standard button events.      Subclasses may call the noDefaultAndApplyButton framework  method before the page's control has been created to suppress  the standard Apply and Defaults buttons.      "
405,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/EditingSupport.html,extends Object EditingSupport is the abstract superclass of the support for cell editing.  Since:  3.3    
406,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends StructuredViewer The ColumnViewer is the abstract superclass of viewers that have columns  (e.g._ AbstractTreeViewer and AbstractTableViewer). Concrete subclasses of  ColumnViewer should implement a matching concrete subclass of ViewerColumn.    This class is not intended to be subclassed outside of the JFace  viewers framework.  Since:  3.3    "
407,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CellEditor.html,extends Object Abstract base class for cell editors. Implements property change listener  handling_ and SWT window management.    Subclasses implement particular kinds of cell editors. This package contains  various specialized cell editors:    TextCellEditor - for simple text strings  ColorCellEditor - for colors  ComboBoxCellEditor - value selected from drop-down combo  box  CheckboxCellEditor - boolean valued checkbox  DialogCellEditor - value from arbitrary dialog      
408,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/ChangeEvent.html,extends ObservableEvent Generic change event denoting that the state of an IObservable object  has changed. This event does not carry information about the kind of change  that occurred.  Since:  1.0  See Also:  Serialized Form    
409,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/StructuredViewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends ContentViewer implements IPostSelectionProvider Abstract base implementation for structure-oriented viewers (trees_ lists_  tables). Supports custom sorting_ filtering_ and rendering.    Any number of viewer filters can be added to this viewer (using  addFilter). When the viewer receives an update_ it asks each  of its filters if it is out of date_ and refilters elements as required.    See Also:  ViewerFilter_  ViewerComparator    "
410,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ICheckable.html,Interface for objects that support elements with a checked state.  See Also:  ICheckStateListener_  CheckStateChangedEvent    
411,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CheckboxTableViewer.html,"Interface for objects that support elements with a checked state.  See Also:  ICheckStateListener_  CheckStateChangedEvent    
Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends TableViewer implements ICheckable A concrete viewer based on an SWT Table  control with checkboxes on each node.  This class supports setting an ICheckStateProvider to   set the checkbox states. To see standard SWT behavior_ view  SWT Snippet274.    This class is not intended to be subclassed outside the viewer framework.   It is designed to be instantiated with a pre-existing SWT table control and configured  with a domain-specific content provider_ label provider_ element filter (optional)_  and element sorter (optional).    Restriction:  This class is not intended to be subclassed by clients.    "
412,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CheckboxTreeViewer.html,"Interface for objects that support elements with a checked state.  See Also:  ICheckStateListener_  CheckStateChangedEvent    
Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends TreeViewer implements ICheckable A concrete tree-structured viewer based on an SWT Tree  control with checkboxes on each node.  This class supports setting an ICheckStateProvider to   set the checkbox states. To see standard SWT behavior_ view  SWT Snippet274.    This class is not intended to be subclassed outside the viewer framework.   It is designed to be instantiated with a pre-existing SWT tree control and configured  with a domain-specific content provider_ label provider_ element filter (optional)_  and element sorter (optional).    Restriction:  This class is not intended to be subclassed by clients.    "
413,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/AbstractTreeViewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends ColumnViewer Abstract base implementation for tree-structure-oriented viewers (trees and  table trees).    Nodes in the tree can be in either an expanded or a collapsed state_  depending on whether the children on a node are visible. This class  introduces public methods for controlling the expanding and collapsing of  nodes.      As of 3.2_ AbstractTreeViewer supports multiple equal elements (each with a  different parent chain) in the tree. This support requires that clients  enable the element map by calling setUseHashLookup(true).      Content providers for abstract tree viewers must implement one of the  interfaces ITreeContentProvider or (as of 3.2_ to support  multiple equal elements) ITreePathContentProvider.    See Also:  TreeViewer    "
414,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/IWizardPage.html,extends IDialogPage Interface for a wizard page.    The class WizardPage provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if WizardPage does not suit their needs.      
415,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/WizardPage.html,"Interface for a page in a multi-page dialog.    
Minimal interface to a message provider. Used for dialog pages which can  provide a message with an icon.  Since:  2.0    
extends IDialogPage Interface for a wizard page.    The class WizardPage provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if WizardPage does not suit their needs.      
extends DialogPage implements IWizardPage An abstract base implementation of a wizard page.    Subclasses must implement the createControl method  to create the specific controls for the wizard page.      Subclasses may call the following methods to configure the wizard page:    setDescription  setErrorMessage  setImageDescriptor  setMessage  setPageComplete  setPreviousPage  setTitle      Subclasses may override these methods if required:    performHelp - may be reimplemented to display help for the page  canFlipToNextPage - may be extended or reimplemented  isPageComplete - may be extended   setDescription - may be extended   setTitle - may be extended   dispose - may be extended to dispose additional allocated SWT resources      Note that clients are free to implement IWizardPage from scratch  instead of subclassing WizardPage. Correct implementations of  IWizardPage will work with any correct implementation of   IWizard.      "
416,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerLabel.html,extends Object The ViewerLabel is the class that is passed to a viewer to handle updates of  labels. It keeps track of both original and updates text.  Since:  3.0  See Also:  IViewerLabelProvider    
417,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/LabelProviderChangedEvent.html,extends EventObject Event object describing a label provider state change.  See Also:  ILabelProviderListener_  Serialized Form    
418,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILabelProviderListener.html,A listener which is notified when a label provider's state changes.  See Also:  IBaseLabelProvider.addListener(org.eclipse.jface.viewers.ILabelProviderListener)_  IBaseLabelProvider.removeListener(org.eclipse.jface.viewers.ILabelProviderListener)    
419,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/DateTime.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class are selectable user interface  objects that allow the user to enter and modify date  or time values.    Note that although this class is a subclass of Composite_  it does not make sense to add children to it_ or set a layout on it.    Styles:  DATE_ TIME_ CALENDAR_ SHORT_ MEDIUM_ LONG_ DROP_DOWN  Events:  DefaultSelection_ Selection    Note: Only one of the styles DATE_ TIME_ or CALENDAR may be specified_  and only one of the styles SHORT_ MEDIUM_ or LONG may be specified.  The DROP_DOWN style is a HINT_ and it is only valid with the DATE style.    IMPORTANT: This class is not intended to be subclassed.    Since:  3.3  See Also:  DateTime snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
420,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/swt/ISWTObservable.html,extends IObservable IObservable observing an SWT widget.  Since:  1.1    
421,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/swt/ISWTObservableValue.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable A value whose changes can be tracked by value change listeners.  Since:  1.0  See Also:  AbstractObservableValue  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends IObservable IObservable observing an SWT widget.  Since:  1.1    
extends ISWTObservable_ IObservableValue IObservableValue observing an SWT widget.  Since:  1.1    "
422,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/swt/ISWTObservableList.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    
extends List_ IObservableCollection A list whose changes can be tracked by list change listeners.  Since:  1.0  See Also:  AbstractObservableList_  ObservableList  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the framework classes  that implement this interface. Note that direct implementers of  this interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends IObservable IObservable observing an SWT widget.  Since:  1.1    
extends ISWTObservable_ IObservableList IObservableList observing an SWT widget.  Since:  1.3    "
423,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IElementComparer.html,This interface is used to compare elements in a viewer for equality_  and to provide the hash code for an element.  This allows the client of the viewer to specify different equality criteria  and a different hash code implementation than the   equals and hashCode implementations of the  elements themselves.  See Also:  StructuredViewer.setComparer(org.eclipse.jface.viewers.IElementComparer)    
424,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CheckStateChangedEvent.html,extends EventObject Event object describing a change to the checked state  of a viewer element.  See Also:  ICheckStateListener_  Serialized Form    
425,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/AbstractListViewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends StructuredViewer Abstract base class for viewers that contain lists of items (such as a combo or list).  Most of the viewer implementation is in this base class_ except for the minimal code that  actually communicates with the underlying widget.  Since:  3.0  See Also:  ListViewer_  ComboViewer    "
426,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/IViewerUpdater.html,A strategy interface for updating the elements in a StructuredViewer.  Many structured viewer classes have similar methods for adding and removing  elements_ few of which are defined in common ancestor classes. This interface  serves as a universal adapter for updating the elements in a viewer  Since:  1.3  See Also:  ObservableListContentProvider.ObservableListContentProvider(IViewerUpdater)_  ObservableSetContentProvider.ObservableSetContentProvider(IViewerUpdater)    
427,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/TreeStructureAdvisor.html,extends Object Instances of this class can be used to improve accuracy and performance of an  ObservableListTreeContentProvider or an  ObservableSetTreeContentProvider. This class is intended to be  subclassed by clients.  Since:  1.2    
428,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/AbstractTableViewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends ColumnViewer This is a widget independent class implementors of  Table like widgets can use to provide a  viewer on top of their widget implementations.  Since:  3.3    "
429,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/IViewerObservable.html,extends IObservable IObservable observing a JFace Viewer.  Since:  1.2    
430,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/IViewerObservableSet.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    
extends Set_ IObservableCollection A set whose changes can be tracked by set change listeners.  Since:  1.0  See Also:  AbstractObservableSet_  ObservableSet  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends IObservable IObservable observing a JFace Viewer.  Since:  1.2    
extends IObservableSet_ IViewerObservable IObservableSet observing a JFace Viewer.  Since:  1.2    "
431,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/IScopeContext.html,Clients implement this interface to provide context to a   particular scope. Instances of implementations of this interface are   passed to the IPreferencesService for use in   preference searching.    Clients may implement this interface.    Since:  3.0  See Also:  IPreferencesService    
432,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/browser/IWebBrowser.html,An opened Web browser instance (either internal or external).    This interface is not intended to be implemented by clients.    Since:  3.1  See Also:  IWorkbenchBrowserSupport  Restriction:  This interface is not intended to be implemented by clients.    
433,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IMemento.html,Interface to a memento used for saving the important state of an object in a  form that can be persisted in the file system.    Mementos were designed with the following requirements in mind:    Certain objects need to be saved and restored across platform sessions.  When an object is restored_ an appropriate class for an object might not  be available. It must be possible to skip an object in this case.  When an object is restored_ the appropriate class for the object may be  different from the one when the object was originally saved. If so_ the new  class should still be able to read the old form of the data.      Mementos meet these requirements by providing support for storing a mapping  of arbitrary string keys to primitive values_ and by allowing mementos to  have other mementos as children (arranged into a tree). A robust external  storage format based on XML is used.      The key for an attribute may be any alpha numeric value that doesn't start  with a number. eg: [A-Za-z][A-Za-z0-9]* Using '.' is unsupported. However_  the value of TAG_ID is reserved for internal use.      The default implementation can throw a DOMException for createChild  and put operations. See XMLMemento.      This interface is not intended to be implemented or extended by clients.    See Also:  IPersistableElement_  IElementFactory_  XMLMemento  Restriction:  This interface is not intended to be implemented by clients.    
434,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/browser/IWorkbenchBrowserSupport.html,"Web browser support. This class allows you to open URLs using internal or  external Web browsers. Implementers may provide varying levels of support.  The most rudimentary support that must be provided is to open URLs in an  external web browser window. Everything else is a hint that browser support  implementation may choose to honor but is not required (although a good  implementation should aspire to support all the styles if possible on the  given platform).    The support has a two-phase approach to opening URLs. A browser instance is  created first_ then openURL is called on it. This provides for  browser instance reuse for as long as needed. The step of creating the  browser instance encourages reuse itself by not creating new instances of  browsers if one with the same id is already open. It also makes it possible  to reuse browser instances restored after workbench is restarted.    The simplest way to open a URL is:      IWorkbenchSupport.createBrowser(""myId"").openURL(url);        The call above will show the provided URL by reusing the browser instance  with the matching id_ or creating a new one if one does not exist already.    When more advanced control over the behavior of a browser instance is  required_ it is recommended to create the instance first_ then reuse it as  needed.    This interface is not intended to be implemented by clients.  Since:  3.1  See Also:  IWebBrowser  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
435,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/XMLMemento.html,"Interface to a memento used for saving the important state of an object in a  form that can be persisted in the file system.    Mementos were designed with the following requirements in mind:    Certain objects need to be saved and restored across platform sessions.  When an object is restored_ an appropriate class for an object might not  be available. It must be possible to skip an object in this case.  When an object is restored_ the appropriate class for the object may be  different from the one when the object was originally saved. If so_ the new  class should still be able to read the old form of the data.      Mementos meet these requirements by providing support for storing a mapping  of arbitrary string keys to primitive values_ and by allowing mementos to  have other mementos as children (arranged into a tree). A robust external  storage format based on XML is used.      The key for an attribute may be any alpha numeric value that doesn't start  with a number. eg: [A-Za-z][A-Za-z0-9]* Using '.' is unsupported. However_  the value of TAG_ID is reserved for internal use.      The default implementation can throw a DOMException for createChild  and put operations. See XMLMemento.      This interface is not intended to be implemented or extended by clients.    See Also:  IPersistableElement_  IElementFactory_  XMLMemento  Restriction:  This interface is not intended to be implemented by clients.    
extends Object implements IMemento This class represents the default implementation of the  IMemento interface.    This class is not intended to be extended by clients.    See Also:  IMemento    "
436,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/SWTError.html,"extends Error This error is thrown whenever an unrecoverable error  occurs internally in SWT. The message text and error code   provide a further description of the problem. The exception  has a throwable field which holds the underlying  throwable that caused the problem (if this information is  available (i.e. it may be null)).    SWTErrors are thrown when something fails internally which  either leaves SWT in an unknown state (eg. the o/s call to  remove an item from a list returns an error code) or when SWT  is left in a known-to-be-unrecoverable state (eg. it runs out  of callback resources). SWTErrors should not occur in typical  programs_ although ""high reliability"" applications should  still catch them.    This class also provides support methods used by SWT to match  error codes to the appropriate exception class (SWTError_   SWTException_ or IllegalArgumentException) and to provide  human readable strings for SWT error codes.    See Also:  SWTException_  SWT.error(int)_  Sample code and further information_  Serialized Form    "
437,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/Browser.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class implement the browser user interface  metaphor. It allows the user to visualize and navigate through  HTML documents.    Note that although this class is a subclass of Composite_  it does not make sense to set a layout on it.    Styles:  MOZILLA_ WEBKIT  Events:  CloseWindowListener_ LocationListener_ OpenWindowListener_ ProgressListener_ StatusTextListener_ TitleListener_ VisibilityWindowListener    Note: At most one of the styles MOZILLA and WEBKIT may be specified.      IMPORTANT: This class is not intended to be subclassed.    Since:  3.0  See Also:  Browser snippets_  SWT Examples: ControlExample_ BrowserExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
438,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/StatusTextEvent.html,extends TypedEvent A StatusTextEvent is sent by a Browser to  StatusTextListener's when the status text is changed.  The status text is typically displayed in the status bar of  a browser application.  Since:  3.0  See Also:  Sample code and further information_  Serialized Form    
439,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/WindowEvent.html,"extends TypedEvent A WindowEvent is sent by a Browser when  a new window needs to be created or when an existing window needs to be  closed. This notification occurs when a javascript command such as  window.open or window.close gets executed by  a Browser.    The following example shows how WindowEvent's are typically  handled.      public static void main(String[] args) {  Display display = new Display();  Shell shell = new Shell(display);  shell.setText(""Main Window"");  shell.setLayout(new FillLayout());  Browser browser = new Browser(shell_ SWT.NONE);  initialize(display_ browser);  shell.open();  browser.setUrl(""http://www.eclipse.org"");  while (!shell.isDisposed()) {  if (!display.readAndDispatch())  display.sleep();  }  display.dispose();  }  static void initialize(final Display display_ Browser browser) {  browser.addOpenWindowListener(new OpenWindowListener() {  public void open(WindowEvent event) {  // Certain platforms can provide a default full browser.  // simply return in that case if the application prefers  // the default full browser to the embedded one set below.  if (!event.required) return;  // Embed the new window  Shell shell = new Shell(display);  shell.setText(""New Window"");  shell.setLayout(new FillLayout());  Browser browser = new Browser(shell_ SWT.NONE);  initialize(display_ browser);  event.browser = browser;  }  });  browser.addVisibilityWindowListener(new VisibilityWindowListener() {  public void hide(WindowEvent event) {  Browser browser = (Browser)event.widget;  Shell shell = browser.getShell();  shell.setVisible(false);  }  public void show(WindowEvent event) {  Browser browser = (Browser)event.widget;  Shell shell = browser.getShell();  if (event.location != null) shell.setLocation(event.location);  if (event.size != null) {  Point size = event.size;  shell.setSize(shell.computeSize(size.x_ size.y));  }  if (event.addressBar || event.menuBar || event.statusBar || event.toolBar) {  // Create widgets for the address bar_ menu bar_ status bar and/or tool bar  // leave enough space in the Shell to accommodate a Browser of the size  // given by event.size  }  shell.open();  }  });  browser.addCloseWindowListener(new CloseWindowListener() {  public void close(WindowEvent event) {  Browser browser = (Browser)event.widget;  Shell shell = browser.getShell();  shell.close();  }  });  }      The following notifications are emitted when the user selects a hyperlink that targets a new window  or as the result of a javascript that executes window.open.     Main Browser    User selects a link that opens in a new window or javascript requests a new window  OpenWindowListener.open() notified  Application creates a new Shell and a second Browser inside that Shell  Application registers WindowListener's on that second Browser_ such as VisibilityWindowListener  Application returns the second Browser as the host for the new window content      Second Browser    VisibilityWindowListener.show() notified  Application sets navigation tool bar_ status bar_ menu bar and Shell size    Application makes the Shell hosting the second Browser visible    User now sees the new window        Since:  3.0  See Also:  CloseWindowListener_  OpenWindowListener_  VisibilityWindowListener_  Sample code and further information_  Serialized Form    "
440,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/ProgressEvent.html,extends TypedEvent A ProgressEvent is sent by a Browser to  ProgressListener's when a progress is made during the  loading of the current URL or when the loading of the current  URL has been completed.  Since:  3.0  See Also:  Sample code and further information_  Serialized Form    
441,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/LocationEvent.html,extends TypedEvent A LocationEvent is sent by a Browser to  LocationListener's when the Browser  navigates to a different URL. This notification typically   occurs when the application navigates to a new location with   Browser.setUrl(String) or when the user activates a  hyperlink.  Since:  3.0  See Also:  Sample code and further information_  Serialized Form    
442,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/TitleEvent.html,extends TypedEvent A TitleEvent is sent by a Browser to  TitleListener's when the title of the current document  is available or when it is modified.  Since:  3.0  See Also:  Sample code and further information_  Serialized Form    
443,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPageService.html,A page service tracks the page and perspective lifecycle events  within a workbench window.    This service can be acquired from your service locator:    IPageService service = (IPageService) getSite().getService(IPageService.class);    This service is not available globally_ only from the workbench window level down.    See Also:  IWorkbenchWindow_  IPageListener_  IPerspectiveListener_  IServiceLocator.getService(Class)  Restriction:  This interface is not intended to be implemented by clients.    
444,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/operation/IRunnableContext.html,Interface for UI components which can execute a long-running operation  in the form of an IRunnableWithProgress.  The context is responsible for displaying a progress indicator and Cancel  button to the end user while the operation is in progress; the context  supplies a progress monitor to be used from code running inside the operation.  Note that an IRunnableContext is not a runnable itself.    For examples of UI components which implement this interface_  see ApplicationWindow_ ProgressMonitorDialog_  and WizardDialog.    See Also:  IRunnableWithProgress_  ApplicationWindow_  ProgressMonitorDialog_  WizardDialog    
445,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/IServiceLocator.html, A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2    
446,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchWindow.html,"A page service tracks the page and perspective lifecycle events  within a workbench window.    This service can be acquired from your service locator:    IPageService service = (IPageService) getSite().getService(IPageService.class);    This service is not available globally_ only from the workbench window level down.    See Also:  IWorkbenchWindow_  IPageListener_  IPerspectiveListener_  IServiceLocator.getService(Class)  Restriction:  This interface is not intended to be implemented by clients.    
Interface for UI components which can execute a long-running operation  in the form of an IRunnableWithProgress.  The context is responsible for displaying a progress indicator and Cancel  button to the end user while the operation is in progress; the context  supplies a progress monitor to be used from code running inside the operation.  Note that an IRunnableContext is not a runnable itself.    For examples of UI components which implement this interface_  see ApplicationWindow_ ProgressMonitorDialog_  and WizardDialog.    See Also:  IRunnableWithProgress_  ApplicationWindow_  ProgressMonitorDialog_  WizardDialog    
 A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends IPageService_ IRunnableContext_ IServiceLocator_ IShellProvider A workbench window is a top level window in a workbench. Visually_ a  workbench window has a menubar_ a toolbar_ a status bar_ and a main area for  displaying a single page consisting of a collection of views and editors.    Each workbench window has a collection of 0 or more pages; the active page is  the one that is being presented to the end user; at most one page is active  in a window at a time.      The workbench window supports a few services by  default. If these services are used to allocate resources_ it is important to  remember to clean up those resources after you are done with them. Otherwise_  the resources will exist until the workbench window is closed. The supported  services are:    ICommandService  IContextService  IHandlerService  IBindingService. Resources allocated through this service will  not be cleaned up until the workbench shuts down.    This interface is not intended to be implemented by clients.    See Also:  IWorkbenchPage  Restriction:  This interface is not intended to be implemented by clients.    "
447,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ScrollBar.html,extends Widget Instances of this class are selectable user interface  objects that represent a range of positive_ numeric values.     At any given moment_ a given scroll bar will have a   single 'selection' that is considered to be its  value_ which is constrained to be within the range of  values the scroll bar represents (that is_ between its  minimum and maximum values).    Typically_ scroll bars will be made up of five areas:    an arrow button for decrementing the value  a page decrement area for decrementing the value by a larger amount  a thumb for modifying the value by mouse dragging  a page increment area for incrementing the value by a larger amount  an arrow button for incrementing the value  Based on their style_ scroll bars are either HORIZONTAL  (which have a left facing button for decrementing the value and a  right facing button for incrementing it) or VERTICAL  (which have an upward facing button for decrementing the value  and a downward facing buttons for incrementing it).    On some platforms_ the size of the scroll bar's thumb can be  varied relative to the magnitude of the range of values it  represents (that is_ relative to the difference between its  maximum and minimum values). Typically_ this is used to  indicate some proportional value such as the ratio of the  visible area of a document to the total amount of space that  it would take to display it. SWT supports setting the thumb  size even if the underlying platform does not_ but in this  case the appearance of the scroll bar will not change.    Scroll bars are created by specifying either H_SCROLL_  V_SCROLL or both when creating a Scrollable.  They are accessed from the Scrollable using  getHorizontalBar and getVerticalBar.    Note: Scroll bars are not Controls. On some platforms_ scroll bars  that appear as part of some standard controls such as a text or list  have no operating system resources and are not children of the control.  For this reason_ scroll bars are treated specially. To create a control  that looks like a scroll bar but has operating system resources_ use  Slider.     Styles:  HORIZONTAL_ VERTICAL  Events:  Selection    Note: Only one of the styles HORIZONTAL and VERTICAL may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Slider_  Scrollable_  Scrollable.getHorizontalBar()_  Scrollable.getVerticalBar()_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
448,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IActionBars.html,"Used by a part to access its menu_ toolbar_ and status line managers.     Within the workbench each part_ editor or view_ has a private set of action  bars. This set_ which contains a menu_ toolbar_ and status line_ appears  in the local toolbar for a view and in the window for an editor. The view  may provide an implementation for pre-existing actions or add new actions to  the action bars.    In a workbench window there are a number of actions which are applicable to  all parts. Some common examples are CUT_ COPY and   PASTE. These actions_ known as ""global actions""_ are contributed to   the workbench window by the window itself and shared by all parts. The  presentation is owned by the window. The implementation is delegated to the  active part.     To participate in the global action design an IWorkbenchPart should   register a handler for each global action which is implemented by the part. This   can be done by calling setGlobalActionHandler. For convenience_ the   standard global actions are defined in   org.eclipse.ui.IWorkbenchActionConstants.     Additional work is required for the Delete global action. In  this case the accelerator is defined in the menu item text but is not hooked   on the window. This is to support text editors where the Delete   key is functional even when the Delete action is disabled (no text   is selected). An implementation for this accelerator must be defined locally_   in each part_ by listening for Delete key events.    A part may also contribute new actions to the action bars as required. To do  this_ call getMenuManager_ getToolBarManager_ or  getStatusLineManager as appropriate to get the action target.  Add the action(s) to the target and call update to commit  any changes to the underlying widgets.    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    "
449,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPartService.html,A part service tracks the creation and activation of parts within a  workbench page.    This service can be acquired from your service locator:    IPartService service = (IPartService) getSite().getService(IPartService.class);    This service is not available globally_ only from the workbench window level down.    See Also:  IWorkbenchPage_  IServiceLocator.getService(Class)  Restriction:  This interface is not intended to be implemented by clients.    
450,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISelectionService.html,A selection service tracks the selection within an object.    A listener that wants to be notified when the selection becomes  null must implement the INullSelectionListener  interface.      This service can be acquired from your service locator:    ISelectionService service = (ISelectionService) getSite().getService(ISelectionService.class);    This service is not available globally_ only from the workbench window level down.    See Also:  ISelectionListener_  INullSelectionListener_  IServiceLocator.getService(Class)  Restriction:  This interface is not intended to be implemented by clients.    
451,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPage.html,"A part service tracks the creation and activation of parts within a  workbench page.    This service can be acquired from your service locator:    IPartService service = (IPartService) getSite().getService(IPartService.class);    This service is not available globally_ only from the workbench window level down.    See Also:  IWorkbenchPage_  IServiceLocator.getService(Class)  Restriction:  This interface is not intended to be implemented by clients.    
A selection service tracks the selection within an object.    A listener that wants to be notified when the selection becomes  null must implement the INullSelectionListener  interface.      This service can be acquired from your service locator:    ISelectionService service = (ISelectionService) getSite().getService(ISelectionService.class);    This service is not available globally_ only from the workbench window level down.    See Also:  ISelectionListener_  INullSelectionListener_  IServiceLocator.getService(Class)  Restriction:  This interface is not intended to be implemented by clients.    
extends IPartService_ ISelectionService_ org.eclipse.ui.internal.ICompatibleWorkbenchPage A workbench page consists of an arrangement of views and editors intended to  be presented together to the user in a single workbench window.    A page can contain 0 or more views and 0 or more editors. These views and  editors are contained wholly within the page and are not shared with other  pages. The layout and visible action set for the page is defined by a  perspective.    The number of views and editors within a page is restricted to simplify part  management for the user. In particular:    Unless a view explicitly allows for multiple instances in its plug-in  declaration there will be only one instance in a given workbench page.  Only one editor can exist for each editor input within a page.            This interface is not intended to be implemented by clients.    See Also:  IPerspectiveDescriptor_  IEditorPart_  IViewPart  Restriction:  This interface is not intended to be implemented by clients.    "
452,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISaveablePart.html,Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
453,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPart.html,extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
454,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorPart.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    "
455,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/program/Program.html,extends Object Instances of this class represent programs and  their associated file extensions in the operating  system.  See Also:  Program snippets_  Sample code and further information    
456,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/TextTransfer.html,"provides a platform specific mechanism   for converting plain text represented as a java String   to a platform specific representation of the data and vice versa.    An example of a java String containing plain text is shown   below:      String textData = ""Hello World"";      Note the TextTransfer does not change the content of the text  data. For a better integration with the platform_ the application should convert  the line delimiters used in the text data to the standard line delimiter used by the  platform.    See Also:  Transfer    "
457,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorInput.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable IEditorInput is a light weight descriptor of editor input_  like a file name but more abstract. It is not a model. It is a description of  the model source for an IEditorPart.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs that are  the same. The IWorbenchPage.openEditor APIs are dependent on  this to find an editor with the same input.      Clients should extend this interface to declare new types of editor inputs.      An editor input is passed to an editor via the IEditorPart.init  method. Due to the wide range of valid editor inputs_ it is not possible to  define generic methods for getting and setting bytes.      Editor input must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.      Please note that it is important that the editor input be light weight.  Within the workbench_ the navigation history tends to hold on to editor  inputs as a means of reconstructing the editor at a later time. The  navigation history can hold on to quite a few inputs (i.e._ the default is  fifty). The actual data model should probably not be held in the input.    See Also:  IEditorPart_  IWorkbenchPage.openEditor(IEditorInput_ String)_  IWorkbenchPage.openEditor(IEditorInput_ String_ boolean)    "
458,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPartSite.html,extends IWorkbenchSite The primary interface between a workbench part and the workbench.    This interface is not intended to be implemented or extended by clients.    Restriction:  This interface is not intended to be implemented by clients.    
459,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchSite.html,extends IAdaptable_ IShellProvider_ IServiceLocator The common interface between the workbench and its parts_ including pages  within parts.    The workbench site supports a few services by  default. If these services are used to allocate resources_ it is important to  remember to clean up those resources after you are done with them. Otherwise_  the resources will exist until the workbench site is disposed. The supported  services are:    ICommandService  IContextService  IHandlerService  IBindingService. Resources allocated through this service will  not be cleaned up until the workbench shuts down.    This interface is not intended to be implemented or extended by clients.    Since:  2.0  See Also:  IWorkbenchPartSite_  IPageSite  Restriction:  This interface is not intended to be implemented by clients.    
460,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorSite.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
 A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends IWorkbenchSite The primary interface between a workbench part and the workbench.    This interface is not intended to be implemented or extended by clients.    Restriction:  This interface is not intended to be implemented by clients.    
extends IAdaptable_ IShellProvider_ IServiceLocator The common interface between the workbench and its parts_ including pages  within parts.    The workbench site supports a few services by  default. If these services are used to allocate resources_ it is important to  remember to clean up those resources after you are done with them. Otherwise_  the resources will exist until the workbench site is disposed. The supported  services are:    ICommandService  IContextService  IHandlerService  IBindingService. Resources allocated through this service will  not be cleaned up until the workbench shuts down.    This interface is not intended to be implemented or extended by clients.    Since:  2.0  See Also:  IWorkbenchPartSite_  IPageSite  Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkbenchPartSite The primary interface between an editor part and the workbench.    The workbench exposes its implemention of editor part sites via this   interface_ which is not intended to be implemented or extended by clients.    Restriction:  This interface is not intended to be implemented by clients.    "
461,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPathEditorInput.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable IEditorInput is a light weight descriptor of editor input_  like a file name but more abstract. It is not a model. It is a description of  the model source for an IEditorPart.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs that are  the same. The IWorbenchPage.openEditor APIs are dependent on  this to find an editor with the same input.      Clients should extend this interface to declare new types of editor inputs.      An editor input is passed to an editor via the IEditorPart.init  method. Due to the wide range of valid editor inputs_ it is not possible to  define generic methods for getting and setting bytes.      Editor input must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.      Please note that it is important that the editor input be light weight.  Within the workbench_ the navigation history tends to hold on to editor  inputs as a means of reconstructing the editor at a later time. The  navigation history can hold on to quite a few inputs (i.e._ the default is  fifty). The actual data model should probably not be held in the input.    See Also:  IEditorPart_  IWorkbenchPage.openEditor(IEditorInput_ String)_  IWorkbenchPage.openEditor(IEditorInput_ String_ boolean)    
extends IEditorInput This interface defines an editor input based on the local file system path  of a file.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs  that are the same. The IWorkbenchPage.openEditor APIs  are dependent on this to find an editor with the same input.    Path-oriented editors should support this as a valid input type_ and  can allow full read-write editing of its content.    All editor inputs must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    Since:  3.0  See Also:  IPath    "
462,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorRegistry.html,"Registry of editors known to the workbench.    An editor can be created in one of two ways:    An editor can be defined by an extension to the workbench.  The user manually associates an editor with a given resource extension  type. This will override any default workbench or platform association.        The registry does not keep track of editors that are ""implicitly"" determined.  For example a bitmap (.bmp) file will typically not have a   registered editor. Instead_ when no registered editor is found_ the   underlying OS is consulted.      This interface is not intended to be implemented by clients.    See Also:  IWorkbench.getEditorRegistry()  Restriction:  This interface is not intended to be implemented by clients.    "
463,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPartDescriptor.html,Description of a workbench part. The part descriptor contains   the information needed to create part instances.    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    
464,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorDescriptor.html,"Description of a workbench part. The part descriptor contains   the information needed to create part instances.    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkbenchPartDescriptor Description of an editor in the workbench editor registry. The  editor descriptor contains the information needed to create editor instances.    An editor descriptor typically represents one of three types of editors:    a file editor extension for a specific file extension.  a file editor added by the user (via the workbench preference page)  a general editor extension which works on objects other than files.      This interface is not intended to be implemented or extended by clients.    See Also:  IEditorRegistry  Restriction:  This interface is not intended to be implemented by clients.    "
465,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPersistable.html,Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
466,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPersistableElement.html,"Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IPersistable Interface for asking an object to store its state in a memento.    This interface is typically included in interfaces where   persistance is required.    When the workbench is shutdown objects which implement this interface   will be persisted. At this time the getFactoryId method   is invoked to discover the id of the element factory that will be used   to re-create the object from a memento. Then the saveState   method is invoked to store the element data into a newly created memento.   The resulting mementos are collected up and written out to a single file.      During workbench startup these mementos are read from the file. The  factory Id for each is retrieved and mapped to an IElementFactory   which has been registered in the element factory extension point. If a   factory exists for the Id it will be engaged to re-create the original   object.    See Also:  IAdaptable_  IMemento_  IElementFactory    "
467,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TableLayout.html,extends Layout A layout for a table. Call addColumnData to add columns.  The TableLayout ColumnLayoutData is only valid until the table  is resized. To keep the proportions constant when the table is resized   see TableColumnLayout    
468,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/ProgressMonitorDialog.html,"Interface for UI components which can execute a long-running operation  in the form of an IRunnableWithProgress.  The context is responsible for displaying a progress indicator and Cancel  button to the end user while the operation is in progress; the context  supplies a progress monitor to be used from code running inside the operation.  Note that an IRunnableContext is not a runnable itself.    For examples of UI components which implement this interface_  see ApplicationWindow_ ProgressMonitorDialog_  and WizardDialog.    See Also:  IRunnableWithProgress_  ApplicationWindow_  ProgressMonitorDialog_  WizardDialog    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends IconAndMessageDialog implements IRunnableContext A modal dialog that displays progress during a long running operation.    This concrete dialog class can be instantiated as is_ or further subclassed  as required.      Typical usage is:          try {  IRunnableWithProgress op = ...;  new ProgressMonitorDialog(activeShell).run(true_ true_ op);  } catch (InvocationTargetException e) {  // handle exception  } catch (InterruptedException e) {  // handle cancelation  }              Note that the ProgressMonitorDialog is not intended to be used with multiple  runnables - this dialog should be discarded after completion of one  IRunnableWithProgress and a new one instantiated for use by a second or  sebsequent IRunnableWithProgress to ensure proper initialization.      Note that not forking the process will result in it running in the UI which  may starve the UI. The most obvious symptom of this problem is non  responsiveness of the cancel button. If you are running within the UI Thread  you should do the bulk of your work in another Thread to prevent starvation.  It is recommended that fork is set to true in most cases.      "
469,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbench.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
 A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2    
extends IAdaptable_ IServiceLocator A workbench is the root object for the Eclipse Platform user interface.    A workbench has one or more main windows which present to the end  user information based on some underlying model_ typically on resources in an  underlying workspace. A workbench usually starts with a single open window_  and automatically closes when its last window closes.      Each workbench window has a collection of pages; the active  page is the one that is being presented to the end user; at most one page is  active in a window at a time.      Each workbench page has a collection of workbench parts_ of which  there are two kinds: views and editors. A page's parts are arranged (tiled or  stacked) for presentation on the screen. The arrangement is not fixed; the  user can arrange the parts as they see fit. A perspective is a  template for a page_ capturing a collection of parts and their arrangement.      The platform creates a workbench when the workbench plug-in is activated;  since this happens at most once during the life of the running platform_  there is only one workbench instance. Due to its singular nature_ it is  commonly referred to as the workbench.      The workbench supports a few services by default. If  these services are used to allocate resources_ it is important to remember to  clean up those resources after you are done with them. Otherwise_ the  resources will exist until the workbench shuts down. The supported services  are:    IBindingService  ICommandService  IContextService  IHandlerService    This interface is not intended to be implemented by clients.    See Also:  PlatformUI.getWorkbench()  Restriction:  This interface is not intended to be implemented by clients.    "
470,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ScrolledPageBook.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends SharedScrolledComposite ScrolledPageBook is a class that is capable of stacking several composites  (pages)_ while showing one at a time. The content is scrolled if there is  not enough space to fit it in the client area.  Since:  3.0    "
471,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/FormToolkit.html,extends Object The toolkit is responsible for creating SWT controls adapted to work in  Eclipse forms. In addition to changing their presentation properties (fonts_  colors etc.)_ various listeners are attached to make them behave correctly in  the form context.    In addition to being the control factory_ the toolkit is also responsible for  painting flat borders for select controls_ managing hyperlink groups and  control colors.    The toolkit creates some of the most common controls used to populate Eclipse  forms. Controls that must be created using their constructors_  adapt() method is available to change its properties in the  same way as with the supported toolkit controls.    Typically_ one toolkit object is created per workbench part (for example_ an  editor or a form wizard). The toolkit is disposed when the part is disposed.  To conserve resources_ it is possible to create one color object for the  entire plug-in and share it between several toolkits. The plug-in is  responsible for disposing the colors (disposing the toolkit that uses shared  color object will not dispose the colors).    FormToolkit is normally instantiated_ but can also be subclassed if some of  the methods needs to be modified. In those cases_ super must  be called to preserve normal behaviour.  Since:  3.0    
472,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/IManagedForm.html,Managed form wraps a form widget and adds life cycle methods for form parts.  A form part is a portion of the form that participates in form life cycle  events.    There is no 1/1 mapping between widgets and form parts. A widget like Section  can be a part by itself_ but a number of widgets can gather around one form  part.    This interface should not be extended or implemented. New form instances  should be created using ManagedForm.  Since:  3.0  See Also:  ManagedForm  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
473,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorActionBarContributor.html,A editor action bar contributor defines the actions for one or more editors.    Within the workbench there may be more than one open editor of a particular  type. For instance_ there may be 1 or more open Java Editors. To avoid the  creation of duplicate actions and action images the editor concept has been  split into two. An action contributor is responsible for the creation of  actions. The editor is responsible for action implementation. Furthermore_  the contributor is shared by each open editor. As a result of this design  there is only 1 set of actions for 1 or more open editors.      The relationship between editor and contributor is defined by the  org.eclipse.ui.editors extension point in the plugin registry.      This interface should not be implemented directly. An implementation of this  interface has been created in EditorActionBarContributor.  Implementors should subclass this and specialize as required.    See Also:  IEditorActionBarContributor    
474,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ScrolledForm.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends SharedScrolledComposite ScrolledForm is a control that is capable of scrolling an instance of the  Form class. It should be created in a parent that will allow it to use all  the available area (for example_ a shell_ a view or an editor).    Children of the form should typically be created using FormToolkit to match  the appearance and behaviour. When creating children_ use a form body as a  parent by calling 'getBody()' on the form instance. Example:      FormToolkit toolkit = new FormToolkit(parent.getDisplay());  ScrolledForm form = toolkit.createScrolledForm(parent);  form.setText(""Sample form"");  form.getBody().setLayout(new GridLayout());  toolkit.createButton(form.getBody()_ ""Checkbox""_ SWT.CHECK);        No layout manager has been set on the body. Clients are required to set the  desired layout manager explicitly.    Although the class is not final_ it is not expected to be be extended.  Since:  3.0  Restriction:  This class is not intended to be subclassed by clients.    "
475,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/Hyperlink.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends AbstractHyperlink Hyperlink is a concrete implementation of the abstract base class that draws  text in the client area. Text can be wrapped and underlined. Hyperlink is  typically added to the hyperlink group so that certain properties are managed  for all the hyperlinks that belong to it.    Hyperlink can be extended.      Styles:  SWT.WRAP  Since:  3.0  See Also:  HyperlinkGroup    "
476,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/Section.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends ExpandableComposite A variation of the expandable composite that adds optional description below  the title. Section is often used as a basic building block in forms because  it provides for logical grouping of information.    In case of the TITLE_BAR style_ Section renders the title bar in a way  compatible with the rest of the workbench. Since it is a widget_ all the  colors must be supplied directly. When created by the form toolkit_ these  colors are supplied by the toolkit. The toolkit initializes these colors  based on the system colors. For this reason_ it is recommended to create the  section by the toolkit instead of through its own constructor.    Since 3.1_ it is possible to set a control to be used for section  description. If used_ DESCRIPTION style should not be set. A  typical way to take advantage of the new method is to set an instance of  FormText to provide for hyperlinks and images in the  description area.  Since:  3.0    "
477,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/events/ExpansionEvent.html,extends TypedEvent Notifies listeners when expandable controls change expansion state.  Since:  3.0  See Also:  Serialized Form    
478,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/events/IHyperlinkListener.html,Classes that implement this interface will be notified when hyperlinks are  entered_ exited and activated.  Since:  3.0  See Also:  Hyperlink_  ImageHyperlink_  FormText    
479,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/events/HyperlinkEvent.html,extends TypedEvent Notifies listeners about a hyperlink change.  Since:  3.0  See Also:  Serialized Form    
480,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/events/IExpansionListener.html,Classes that implement this interface will be notified before and after the  expandable control's expansion state changes.  Since:  3.0    
481,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/IMessageManager.html,This interface provides for managing typed messages in a form. Typed messages  are messages associated with a type that indicates their severity (error_  warning_ information). The interface is responsible for:  Bridging the concept of typed messages and control decorations  Adding one or more messages per control in a form  Rolling the local messages up to the form header  Adding one or more general messages to the form header    To use it in a form_ do the following:    For each interactive control_ add a listener to it to monitor user input  Every time the input changes_ validate it. If there is a problem_ add a  message with a unique key to the manager. If there is already a message with  the same key in the manager_ its type and message text will be replaced (no  duplicates). Note that you add can messages with different keys to the same  control to track multiple problems with the user input.  If the problem has been cleared_ remove the message using the key  (attempting to remove a message that is not in the manager is safe).  If something happens in the form that is not related to any control_ use  the other addMessage method.    This interface should only be referenced. It must not be implemented or  extended.    Since:  3.3  See Also:  IMessageProvider_  IManagedForm  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
482,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/HyperlinkSettings.html,extends Object Manages color and underline mode settings for a group of hyperlinks. The  class is extended by HyperlinkGroup but is otherwise not intended to be  subclassed.  Since:  3.0  Restriction:  This class is not intended to be subclassed by clients.    
483,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TypedListener.html,"Implementers of Listener provide a simple   handleEvent() method that is used internally   by SWT to dispatch events.    After creating an instance of a class that implements this interface  it can be added to a widget using the   addListener(int eventType_ Listener handler) method and  removed using the   removeListener (int eventType_ Listener handler) method.   When the specified event occurs_ handleEvent(...) will  be sent to the instance.      Classes which implement this interface are described within SWT as  providing the untyped listener API. Typically_ widgets will  also provide a higher-level typed listener API_ that is based  on the standard java.util.EventListener pattern.        Note that_ since all internal SWT event dispatching is based on untyped  listeners_ it is simple to build subsets of SWT for use on memory   constrained_ small footprint devices_ by removing the classes and  methods which implement the typed listener API.    See Also:  Widget.addListener(int_ org.eclipse.swt.widgets.Listener)_  EventListener_  org.eclipse.swt.events    
extends Object implements Listener Instances of this class are internal SWT implementation  objects which provide a mapping between the typed and untyped   listener mechanisms that SWT supports.    IMPORTANT: This class is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Listener_  Sample code and further information    "
484,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/ScrolledComposite.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite A ScrolledComposite provides scrollbars and will scroll its content when the user  uses the scrollbars.  There are two ways to use the ScrolledComposite:      1) Set the size of the control that is being scrolled and the ScrolledComposite   will show scrollbars when the contained control can not be fully seen.    2) The second way imitates the way a browser would work. Set the minimum size of  the control and the ScrolledComposite will show scroll bars if the visible area is   less than the minimum size of the control and it will expand the size of the control   if the visible area is greater than the minimum size. This requires invoking   both setMinWidth()_ setMinHeight() and setExpandHorizontal()_ setExpandVertical().      public static void main (String [] args) {  Display display = new Display ();  Color red = display.getSystemColor(SWT.COLOR_RED);  Color blue = display.getSystemColor(SWT.COLOR_BLUE);  Shell shell = new Shell (display);  shell.setLayout(new FillLayout());    // set the size of the scrolled content - method 1  final ScrolledComposite sc1 = new ScrolledComposite(shell_ SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER);  final Composite c1 = new Composite(sc1_ SWT.NONE);  sc1.setContent(c1);  c1.setBackground(red);  GridLayout layout = new GridLayout();  layout.numColumns = 4;  c1.setLayout(layout);  Button b1 = new Button (c1_ SWT.PUSH);  b1.setText(""first button"");  c1.setSize(c1.computeSize(SWT.DEFAULT_ SWT.DEFAULT));    // set the minimum width and height of the scrolled content - method 2  final ScrolledComposite sc2 = new ScrolledComposite(shell_ SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER);  sc2.setExpandHorizontal(true);  sc2.setExpandVertical(true);  final Composite c2 = new Composite(sc2_ SWT.NONE);  sc2.setContent(c2);  c2.setBackground(blue);  layout = new GridLayout();  layout.numColumns = 4;  c2.setLayout(layout);  Button b2 = new Button (c2_ SWT.PUSH);  b2.setText(""first button"");  sc2.setMinSize(c2.computeSize(SWT.DEFAULT_ SWT.DEFAULT));    Button add = new Button (shell_ SWT.PUSH);  add.setText(""add children"");  final int[] index = new int[]{0};  add.addListener(SWT.Selection_ new Listener() {  public void handleEvent(Event e) {  index[0]++;  Button button = new Button(c1_ SWT.PUSH);  button.setText(""button ""+index[0]);  // reset size of content so children can be seen - method 1  c1.setSize(c1.computeSize(SWT.DEFAULT_ SWT.DEFAULT));  c1.layout();    button = new Button(c2_ SWT.PUSH);  button.setText(""button ""+index[0]);  // reset the minimum width and height so children can be seen - method 2  sc2.setMinSize(c2.computeSize(SWT.DEFAULT_ SWT.DEFAULT));  c2.layout();  }  });    shell.open ();  while (!shell.isDisposed ()) {  if (!display.readAndDispatch ()) display.sleep ();  }  display.dispose ();  }    Styles:  H_SCROLL_ V_SCROLL    See Also:  ScrolledComposite snippets_  Sample code and further information    "
485,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/FormColors.html,extends Object Manages colors that will be applied to forms and form widgets. The colors are  chosen to make the widgets look correct in the editor area. If a different  set of colors is needed_ subclass this class and override 'initialize' and/or  'initializeColors'.  Since:  3.0    
486,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/HyperlinkGroup.html,extends HyperlinkSettings Manages a group of hyperlinks. It tracks activation_ updates normal and  active colors and updates underline state depending on the underline  preference. Hyperlink labels are added to the group after creation and are  automatically removed from the group when they are disposed.  Since:  3.0    
487,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/Form.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Form is a custom control that renders a title and an optional background  image above the body composite. It can be used alone when part of parents  that are scrolled. If scrolling is required_ use ScrolledForm  instead because it has an instance of Form and adds scrolling  capability.    Form can have a title if set. If not set_ title area will not be left empty -  form body will be resized to fill the entire form. In addition_ an optional  title image can be set and is rendered to the left of the title (since 3.2).    Form can have a title drop down menu if the menu bar manager is not empty  (since 3.3).    Form title can support drag and drop if drag and drop support methods are  invoked. When used_ additional decoration is rendered behind the title to  reinforce the drag and drop ability (since 3.3).    The form supports status messages. These messages can have various severity  (error_ warning_ info or none). If status hyperlink handler is specified_ the  messages with the specified severity other than none will be rendered as  hyperlinks.    Form can have a background image behind the title text. The image is tiled as  many times as needed to fill the title area. Alternatively_ gradient  background can be painted vertically or horizontally.    Form can be put in a 'busy' state. While in this state_ title image is  replaced with an animation that lasts as long as the 'busy' state is active.    It is possible to create an optional head client control. When created_ this  control is placed in the form heading as a second row.    Form has a custom layout manager that is wrap-enabled. If a form is placed in  a composite whose layout manager implements ILayoutExtension_ the body of the  form will participate in wrapping as long as its layout manager implements  ILayoutExtension as well.    Children of the form should typically be created using FormToolkit to match  the appearance and behaviour. When creating children_ use the form body as a  parent by calling 'getBody()' on the form instance. Example:      FormToolkit toolkit = new FormToolkit(parent.getDisplay());  Form form = toolkit.createForm(parent);  form.setText(""Sample form"");  form.getBody().setLayout(new GridLayout());  toolkit.createButton(form.getBody()_ ""Checkbox""_ SWT.CHECK);        No layout manager has been set on the body. Clients are required to set the  desired layout manager explicitly.    Although the class is not final_ it should not be subclassed.  Since:  3.0  Restriction:  This class is not intended to be subclassed by clients.    "
488,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/IMessage.html,"Minimal interface to a message provider. Used for dialog pages which can  provide a message with an icon.  Since:  2.0    
extends IMessageProvider This interface encapsulates a single message that can be shown in a form.  Messages can be associated with controls_ or be of a general nature.  Since:  3.3  See Also:  IMessageManager    "
489,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/IMessagePrefixProvider.html,This interface computes the prefix of a message that is created in the  context of a control. Since messages are rolled up to the header in the  message manager_ it is important to create a prefix to indicate the context  of a message in the form. Typically the prefix is computed by looking at the  label that preceeds the control_ if present. Alternative providers may  include other text to further specify the location of the message.  Since:  3.3  See Also:  IMessageManager_  IMessage    
490,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/ISchedulingRule.html,Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)    
491,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResource.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)    
extends IAdaptable_ ISchedulingRule The workspace analog of file system files  and directories. There are exactly four types of resource:  files_ folders_ projects and the workspace root.    File resources are similar to files in that they  hold data directly. Folder resources are analogous to directories in that they  hold other resources but cannot directly hold data. Project resources  group files and folders into reusable clusters. The workspace root is the  top level resource under which all others reside.      Features of resources:    IResource objects are handles to state maintained  by a workspace. That is_ resource objects do not actually contain data  themselves but rather represent resource state and give it behavior. Programmers  are free to manipulate handles for resources that do not exist in a workspace   but must keep in mind that some methods and operations require that an actual   resource be available.  Resources have two different kinds of properties as detailed below. All   properties are keyed by qualified names.  Session properties: Session properties live for the lifetime of one execution of  the workspace. They are not stored on disk. They can carry arbitrary  object values. Clients should be aware that these values are kept in memory  at all times and_ as such_ the values should not be large.  Persistent properties: Persistent properties have string values which are stored  on disk across platform sessions. The value of a persistent property is a   string which should be short (i.e._ under 2KB).     Resources are identified by type and by their path_ which is similar to a file system   path. The name of a resource is the last segment of its path. A resource's parent   is located by removing the last segment (the resource's name) from the resource's full path.  Resources can be local or non-local. A non-local resource is one whose  contents and properties have not been fetched from a repository.  Phantom resources represent incoming additions or outgoing deletions  which have yet to be reconciled with a synchronization partner.       Resources implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IWorkspace_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
492,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/bookmarkexplorer/BookmarkPropertiesDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends org.eclipse.ui.views.markers.internal.DialogMarkerProperties Shows the properties of a new or existing bookmark  This class was made public in 3.3.  Since:  3.3    "
493,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IAdvancedUndoableOperation.html, IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
494,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IAdvancedUndoableOperation2.html, IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
495,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IUndoableOperation.html, IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
496,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/CreateMarkersOperation.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractWorkspaceOperation A CreateMarkersOperation represents an undoable operation for creating one or  more markers on one or more resources in the workspace. Clients may call the  public API from a background thread.    This class is intended to be instantiated and used by clients. It is not  intended to be subclassed by clients.  Since:  3.3    "
497,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IContainer.html,extends IResource_ IAdaptable Interface for resources which may contain  other resources (termed its members). While the   workspace itself is not considered a container in this sense_ the  workspace root resource is a container.    Containers implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()_  IProject_  IFolder_  IWorkspaceRoot  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
498,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IProject.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IResource_ IAdaptable Interface for resources which may contain  other resources (termed its members). While the   workspace itself is not considered a container in this sense_ the  workspace root resource is a container.    Containers implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()_  IProject_  IFolder_  IWorkspaceRoot  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)    
extends IAdaptable_ ISchedulingRule The workspace analog of file system files  and directories. There are exactly four types of resource:  files_ folders_ projects and the workspace root.    File resources are similar to files in that they  hold data directly. Folder resources are analogous to directories in that they  hold other resources but cannot directly hold data. Project resources  group files and folders into reusable clusters. The workspace root is the  top level resource under which all others reside.      Features of resources:    IResource objects are handles to state maintained  by a workspace. That is_ resource objects do not actually contain data  themselves but rather represent resource state and give it behavior. Programmers  are free to manipulate handles for resources that do not exist in a workspace   but must keep in mind that some methods and operations require that an actual   resource be available.  Resources have two different kinds of properties as detailed below. All   properties are keyed by qualified names.  Session properties: Session properties live for the lifetime of one execution of  the workspace. They are not stored on disk. They can carry arbitrary  object values. Clients should be aware that these values are kept in memory  at all times and_ as such_ the values should not be large.  Persistent properties: Persistent properties have string values which are stored  on disk across platform sessions. The value of a persistent property is a   string which should be short (i.e._ under 2KB).     Resources are identified by type and by their path_ which is similar to a file system   path. The name of a resource is the last segment of its path. A resource's parent   is located by removing the last segment (the resource's name) from the resource's full path.  Resources can be local or non-local. A non-local resource is one whose  contents and properties have not been fetched from a repository.  Phantom resources represent incoming additions or outgoing deletions  which have yet to be reconciled with a synchronization partner.       Resources implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IWorkspace_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)    
extends IContainer_ IAdaptable A project is a type of resource which groups resources  into buildable_ reusable units.     Features of projects include:    A project collects together a set of files and folders.  A project's location controls where the project's resources are   stored in the local file system.  A project's build spec controls how building is done on the project.  A project can carry session and persistent properties.  A project can be open or closed; a closed project is  passive and has a minimal in-memory footprint.  A project can have one or more project build configurations.  A project can carry references to other project build configurations.  A project can have one or more project natures.      Projects implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
499,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/Job.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends org.eclipse.core.internal.jobs.InternalJob implements IAdaptable Jobs are units of runnable work that can be scheduled to be run with the job  manager. Once a job has completed_ it can be scheduled to run again (jobs are  reusable).    Jobs have a state that indicates what they are currently doing. When constructed_  jobs start with a state value of NONE. When a job is scheduled  to be run_ it moves into the WAITING state. When a job starts  running_ it moves into the RUNNING state. When execution finishes  (either normally or through cancelation)_ the state changes back to   NONE.     A job can also be in the SLEEPING state. This happens if a user  calls Job.sleep() on a waiting job_ or if a job is scheduled to run after a specified  delay. Only jobs in the WAITING state can be put to sleep.   Sleeping jobs can be woken at any time using Job.wakeUp()_ which will put the  job back into the WAITING state.    Jobs can be assigned a priority that is used as a hint about how the job should  be scheduled. There is no guarantee that jobs of one priority will be run before  all jobs of lower priority. The javadoc for the various priority constants provide  more detail about what each priority means. By default_ jobs start in the   LONG priority class.  Since:  3.0  See Also:  IJobManager    "
500,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceRuleFactory.html,A resource rule factory returns scheduling rules for API methods  that modify the workspace. These rules can be used when creating jobs  or other operations that perform a series of modifications on the workspace.  This allows clients to implement two phase commit semantics_ where all  necessary rules are obtained prior to executing a long running operation.    Note that simple use of the workspace APIs does not require use of scheduling  rules. All workspace API methods that modify the workspace will automatically  obtain any scheduling rules needed to perform the modification. However_ if you  are aggregating a set of changes to the workspace using WorkspaceJob  or IWorkspaceRunnable you can use scheduling rules to lock a   portion of the workspace for the duration of the job or runnable. If you  provide a non-null scheduling rule_ a runtime exception will occur if you try to   modify a portion of the workspace that is not covered by the rule for the runnable or job.    If more than one rule is needed_ they can be aggregated using the  MultiRule.combine method. Simplifying a group of rules does not change  the set of resources that are covered_ but can improve job scheduling performance.    Note that null is a valid scheduling rule (indicating that no  resources need to be locked)_ and thus all methods in this class may   return null.  Since:  3.0  See Also:  WorkspaceJob_  IWorkspace.run(IWorkspaceRunnable_ ISchedulingRule_ int_ org.eclipse.core.runtime.IProgressMonitor)_  MultiRule.combine(ISchedulingRule_ ISchedulingRule)  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
501,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceChangeEvent.html,Resource change events describe changes to resources.    There are currently five different types of resource change events:      Before-the-fact batch reports of arbitrary creations_   deletions and modifications to one or more resources expressed  as a hierarchical resource delta. Event type is  PRE_BUILD_ and getDelta returns  the hierarchical delta rooted at the workspace root.   The getBuildKind method returns  the kind of build that is about to occur_ and the getSource  method returns the scope of the build (either the workspace or a single project).  These events are broadcast to interested parties immediately   before each build operation. If autobuilding is not enabled_ these events still   occur at times when autobuild would have occurred. The workspace is open   for change during notification of these events. The delta reported in this event   cycle is identical across all listeners registered for this type of event.  Resource changes attempted during a PRE_BUILD callback  must be done in the thread doing the notification.      After-the-fact batch reports of arbitrary creations_   deletions and modifications to one or more resources expressed  as a hierarchical resource delta. Event type is  POST_BUILD_ and getDelta returns  the hierarchical delta rooted at the workspace root.  The getBuildKind method returns  the kind of build that occurred_ and the getSource  method returns the scope of the build (either the workspace or a single project).  These events are broadcast to interested parties at the end of every build operation.  If autobuilding is not enabled_ these events still occur at times when autobuild  would have occurred. The workspace is open for change during notification of   these events. The delta reported in this event cycle is identical across  all listeners registered for this type of event.  Resource changes attempted during a POST_BUILD callback  must be done in the thread doing the notification.      After-the-fact batch reports of arbitrary creations_   deletions and modifications to one or more resources expressed  as a hierarchical resource delta. Event type is  POST_CHANGE_ and getDelta returns  the hierarchical delta. The resource delta is rooted at the   workspace root. These events are broadcast to interested parties after  a set of resource changes and happen whether or not autobuilding is enabled.   The workspace is closed for change during notification of these events.  The delta reported in this event cycle is identical across all listeners registered for   this type of event.      Before-the-fact reports of the impending closure of a single  project. Event type is PRE_CLOSE_   and getResource returns the project being closed.  The workspace is closed for change during notification of these events.      Before-the-fact reports of the impending deletion of a single  project. Event type is PRE_DELETE_   and getResource returns the project being deleted.  The workspace is closed for change during notification of these events.      Before-the-fact reports of the impending refresh of a single project or the workspace.   Event type is PRE_REFRESH and the getSource  method returns the scope of the refresh (either the workspace or a single project).  If the event is fired by a project refresh the getResource  method returns the project being refreshed.  The workspace is closed for changes during notification of these events.      In order to handle additional event types that may be introduced  in future releases of the platform_ clients should do not write code  that presumes the set of event types is closed.    Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
502,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceDelta.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable A resource delta represents changes in the state of a resource tree  between two discrete points in time.    Resource deltas implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IResource_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
503,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/IResourceChangeDescriptionFactory.html,This factory is used to build a resource delta that represents a proposed change  that can then be passed to the ResourceChangeValidator.validateChange(IResourceDelta_ IProgressMonitor)  method in order to validate the change with any model providers stored in those resources.  The deltas created by calls to the methods of this interface will be the same as   those generated by the workspace if the proposed operations were performed.    This factory does not validate that the proposed operation is valid given the current  state of the resources and any other proposed changes. It only records the  delta that would result.  Since:  3.2  See Also:  ResourceChangeValidator_  ModelProvider  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
504,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/MessageDialogWithToggle.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends MessageDialog  A message dialog which also allows the user to adjust a toggle setting. If a  preference store is provided and the user selects the toggle_ then the user's  answer (yes/ok or no) will be persisted in the store. If no store is  provided_ then this information can be queried after the dialog closes.      This type of dialog should be used whenever you want to user to be able to  avoid being prompted in the future. It is strongly   recommended that a cancel option be provided_ so that the user has the option  of making the decision at a later point in time. The semantic for a cancel  button should be to cancel the operation (if it has not yet started)_ or stop  the operation (if it has already started).      It is the responsibility of the developer to provide a mechanism for the user  to change this preference at some later point in time (e.g._ through a  preference page).    Since:  3.0    "
505,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspace.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable Workspaces are the basis for Eclipse Platform resource management. There is  only one workspace per running platform. All resources exist in the context  of this workspace.    A workspace corresponds closely to discreet areas in the local file system.  Each project in a workspace maps onto a specific area of the file system. The  folders and files within a project map directly onto the corresponding  directories and files in the file system. One sub-directory_ the workspace  metadata area_ contains internal information about the workspace and its  resources. This metadata area should be accessed only by the Platform or via  Platform API calls.      Workspaces add value over using the file system directly in that they allow  for comprehensive change tracking (through IResourceDelta s)_  various forms of resource metadata (e.g._ markers and properties) as well as  support for managing application/tool state (e.g._ saving and restoring).      The workspace as a whole is thread safe and allows one writer concurrent with  multiple readers. It also supports mechanisms for saving and snapshotting the  current resource state.      The workspace is provided by the Resources plug-in and is automatically  created when that plug-in is activated. The default workspace data area  (i.e._ where its resources are stored) overlap exactly with the platform's  data area. That is_ by default_ the workspace's projects are found directly  in the platform's data area. Individual project locations can be specified  explicitly.      The workspace resource namespace is always case-sensitive and   case-preserving. Thus the workspace allows multiple sibling resources to exist  with names that differ only in case. The workspace also imposes no  restrictions on valid characters in resource names_ the length of resource names_  or the size of resources on disk. In situations where one or more resources  are stored in a file system that is not case-sensitive_ or that imposes restrictions  on resource names_ any failure to store or retrieve those resources will  be propagated back to the caller of workspace API.      Workspaces implement the IAdaptable interface; extensions are  managed by the platform's adapter manager.    Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
506,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/filesystem/IFileInfo.html,extends Comparable_ Cloneable A file info is a simple structure holding information about a file or directory.  The information contained here is static; changes to this object will  not cause corresponding changes to any file on disk_ and changes to files  on disk are not reflected in this object. At best_ an IFileInfo represents a snapshot  of the state of a file at a particular moment in time.  Since:  org.eclipse.core.filesystem 1.0  See Also:  IFileStore.fetchInfo(int_ IProgressMonitor)_  IFileStore.putInfo(IFileInfo_ int_ IProgressMonitor)  Restriction:  This interface is not intended to be implemented by clients. File store  implementations should use the concrete class FileStore    
507,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspaceRoot.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IResource_ IAdaptable Interface for resources which may contain  other resources (termed its members). While the   workspace itself is not considered a container in this sense_ the  workspace root resource is a container.    Containers implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()_  IProject_  IFolder_  IWorkspaceRoot  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)    
extends IAdaptable_ ISchedulingRule The workspace analog of file system files  and directories. There are exactly four types of resource:  files_ folders_ projects and the workspace root.    File resources are similar to files in that they  hold data directly. Folder resources are analogous to directories in that they  hold other resources but cannot directly hold data. Project resources  group files and folders into reusable clusters. The workspace root is the  top level resource under which all others reside.      Features of resources:    IResource objects are handles to state maintained  by a workspace. That is_ resource objects do not actually contain data  themselves but rather represent resource state and give it behavior. Programmers  are free to manipulate handles for resources that do not exist in a workspace   but must keep in mind that some methods and operations require that an actual   resource be available.  Resources have two different kinds of properties as detailed below. All   properties are keyed by qualified names.  Session properties: Session properties live for the lifetime of one execution of  the workspace. They are not stored on disk. They can carry arbitrary  object values. Clients should be aware that these values are kept in memory  at all times and_ as such_ the values should not be large.  Persistent properties: Persistent properties have string values which are stored  on disk across platform sessions. The value of a persistent property is a   string which should be short (i.e._ under 2KB).     Resources are identified by type and by their path_ which is similar to a file system   path. The name of a resource is the last segment of its path. A resource's parent   is located by removing the last segment (the resource's name) from the resource's full path.  Resources can be local or non-local. A non-local resource is one whose  contents and properties have not been fetched from a repository.  Phantom resources represent incoming additions or outgoing deletions  which have yet to be reconciled with a synchronization partner.       Resources implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IWorkspace_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)    
extends IContainer_ IAdaptable A root resource represents the top of the resource hierarchy in a workspace.  There is exactly one root in a workspace. The root resource has the following  behavior:   It cannot be moved or copied   It always exists.  Deleting the root deletes all of the children under the root but leaves the root itself  It is always local.  It is never a phantom.    Workspace roots implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
508,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IFolder.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IResource_ IAdaptable Interface for resources which may contain  other resources (termed its members). While the   workspace itself is not considered a container in this sense_ the  workspace root resource is a container.    Containers implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()_  IProject_  IFolder_  IWorkspaceRoot  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)    
extends IAdaptable_ ISchedulingRule The workspace analog of file system files  and directories. There are exactly four types of resource:  files_ folders_ projects and the workspace root.    File resources are similar to files in that they  hold data directly. Folder resources are analogous to directories in that they  hold other resources but cannot directly hold data. Project resources  group files and folders into reusable clusters. The workspace root is the  top level resource under which all others reside.      Features of resources:    IResource objects are handles to state maintained  by a workspace. That is_ resource objects do not actually contain data  themselves but rather represent resource state and give it behavior. Programmers  are free to manipulate handles for resources that do not exist in a workspace   but must keep in mind that some methods and operations require that an actual   resource be available.  Resources have two different kinds of properties as detailed below. All   properties are keyed by qualified names.  Session properties: Session properties live for the lifetime of one execution of  the workspace. They are not stored on disk. They can carry arbitrary  object values. Clients should be aware that these values are kept in memory  at all times and_ as such_ the values should not be large.  Persistent properties: Persistent properties have string values which are stored  on disk across platform sessions. The value of a persistent property is a   string which should be short (i.e._ under 2KB).     Resources are identified by type and by their path_ which is similar to a file system   path. The name of a resource is the last segment of its path. A resource's parent   is located by removing the last segment (the resource's name) from the resource's full path.  Resources can be local or non-local. A non-local resource is one whose  contents and properties have not been fetched from a repository.  Phantom resources represent incoming additions or outgoing deletions  which have yet to be reconciled with a synchronization partner.       Resources implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IWorkspace_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)    
extends IContainer_ IAdaptable Folders may be leaf or non-leaf resources and may contain files and/or other folders.  A folder resource is stored as a directory in the local file system.    Folders_ like other resource types_ may exist in the workspace but  not be local; non-local folder resources serve as place-holders for  folders whose properties have not yet been fetched from a repository.      Folders implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
509,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IEncodedStorage.html,extends IStorage A storage that knows how its contents are encoded.    The IEncodedStorage interface extends IStorage  in order to provide access to the charset to be used when decoding its   contents.     Clients may implement this interface.    Since:  3.0    
510,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IStorage.html,extends IAdaptable A storage object represents a set of bytes which can be accessed.  These may be in the form of an IFile or IFileState  or any other object supplied by user code. The main role of an IStorage  is to provide a uniform API for access to_ and presentation of_ its content.    Storage objects implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    Clients may implement this interface.        
511,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IFile.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IStorage A storage that knows how its contents are encoded.    The IEncodedStorage interface extends IStorage  in order to provide access to the charset to be used when decoding its   contents.     Clients may implement this interface.    Since:  3.0    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)    
extends IAdaptable_ ISchedulingRule The workspace analog of file system files  and directories. There are exactly four types of resource:  files_ folders_ projects and the workspace root.    File resources are similar to files in that they  hold data directly. Folder resources are analogous to directories in that they  hold other resources but cannot directly hold data. Project resources  group files and folders into reusable clusters. The workspace root is the  top level resource under which all others reside.      Features of resources:    IResource objects are handles to state maintained  by a workspace. That is_ resource objects do not actually contain data  themselves but rather represent resource state and give it behavior. Programmers  are free to manipulate handles for resources that do not exist in a workspace   but must keep in mind that some methods and operations require that an actual   resource be available.  Resources have two different kinds of properties as detailed below. All   properties are keyed by qualified names.  Session properties: Session properties live for the lifetime of one execution of  the workspace. They are not stored on disk. They can carry arbitrary  object values. Clients should be aware that these values are kept in memory  at all times and_ as such_ the values should not be large.  Persistent properties: Persistent properties have string values which are stored  on disk across platform sessions. The value of a persistent property is a   string which should be short (i.e._ under 2KB).     Resources are identified by type and by their path_ which is similar to a file system   path. The name of a resource is the last segment of its path. A resource's parent   is located by removing the last segment (the resource's name) from the resource's full path.  Resources can be local or non-local. A non-local resource is one whose  contents and properties have not been fetched from a repository.  Phantom resources represent incoming additions or outgoing deletions  which have yet to be reconciled with a synchronization partner.       Resources implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IWorkspace_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)    
extends IAdaptable A storage object represents a set of bytes which can be accessed.  These may be in the form of an IFile or IFileState  or any other object supplied by user code. The main role of an IStorage  is to provide a uniform API for access to_ and presentation of_ its content.    Storage objects implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    Clients may implement this interface.        
extends IResource_ IEncodedStorage_ IAdaptable Files are leaf resources which contain data.  The contents of a file resource is stored as a file in the local  file system.    Files_ like folders_ may exist in the workspace but  not be local; non-local file resources serve as place-holders for  files whose content and properties have not yet been fetched from  a repository.      Files implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
512,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/filesystem/IFileStore.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable A file store is responsible for storage and retrieval of a single file in some file system.   The actual protocols and media used for communicating with the file system  are abstracted away by this interface_ apart from the store's ability  to represent itself as a hierarchical URI.    File store instances are lightweight handle objects; a store knows how to access  and store file information_ but does not retain a large memory footprint or  operating system connections such as sockets or file handles. The presence  of a file store instance does not imply the existence of a corresponding file  in the file system represented by that store. A store that has a  corresponding file in its file system is said to exist.      As much as possible_ implementations of this API maintain the characteristics of the  underlying file system represented by this store. For example_ store instances  will be case-sensitive and case-preserving only when representing case-sensitive  and case-preserving file systems.    Since:  org.eclipse.core.filesystem 1.0  Restriction:  This interface is not intended to be implemented by clients. File store  implementations must subclass FileStore rather than implementing  this interface directly.    "
513,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/dialogs/ImportTypeDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends TrayDialog Dialog to let the user customise how files and resources are created in a project  hierarchy after the user drag and drop items on a workspace container.    Files and folders can be created either by copying the source objects_ creating  linked resources_ and/or creating virtual folders.  Since:  3.6  Restriction:  This class is not intended to be subclassed by clients.    "
514,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IInputValidator.html,The IInputValidator is the interface for simple validators.  See Also:  InputDialog    
515,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/InputDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends Dialog A simple input dialog for soliciting an input string from the user.    This concrete dialog class can be instantiated as is_ or further subclassed as  required.      "
516,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/AbstractWorkspaceOperation.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractOperation implements IAdvancedUndoableOperation_ IAdvancedUndoableOperation2 An AbstractWorkspaceOperation represents an undoable operation that affects  the workspace. It handles common workspace operation activities such as  tracking which resources are affected by an operation_ prompting the user  when there are possible side effects of operations_ building execution  exceptions from core exceptions_ etc. Clients may call the public API from a  background thread.    This class is not intended to be subclassed by clients.    Since:  3.3  Restriction:  This class is not intended to be subclassed by clients.    "
517,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/CopyResourcesOperation.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractWorkspaceOperation A CopyResourcesOperation represents an undoable operation for copying one or  more resources in the workspace. Clients may call the public API from a  background thread.      This operation can track any overwritten resources and restore them when the  copy is undone. It is up to clients to determine whether overwrites are  allowed. If a resource should not be overwritten_ it should not be included  in this operation. In addition to checking for overwrites_ the target  location for the copy is assumed to have already been validated by the  client. It will not be revalidated on undo and redo.        This class is intended to be instantiated and used by clients. It is not  intended to be subclassed by clients.    Since:  3.3  Restriction:  This class is not intended to be subclassed by clients.    "
518,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/IOverwriteQuery.html,Implementors of this interface answer one of the prescribed return codes  when asked whether to overwrite a certain path string (which could  represent a resource path_ a file system path_ etc).    
519,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/operation/IThreadListener.html,A thread listener is an object that is interested in receiving notifications  of thread changes. For example_ a thread listener can be used to notify a   runnable of the thread that will execute it_ allowing the runnable to transfer  thread-local state from the calling thread before control passes to the new thread.  Since:  3.1    
520,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/datatransfer/ImportOperation.html,"The IRunnableWithProgress interface should be implemented by any  class whose instances are intended to be executed as a long-running operation.  Long-running operations are typically presented at the UI via a modal dialog  showing a progress indicator and a Cancel button.  The class must define a run method that takes a progress monitor.  The run method is usually not invoked directly_ but rather by  passing the IRunnableWithProgress to the run method of  an IRunnableContext_ which provides the UI for the progress monitor  and Cancel button.  See Also:  IRunnableContext    
A thread listener is an object that is interested in receiving notifications  of thread changes. For example_ a thread listener can be used to notify a   runnable of the thread that will execute it_ allowing the runnable to transfer  thread-local state from the calling thread before control passes to the new thread.  Since:  3.1    
extends WorkspaceModifyOperation An operation which does the actual work of copying objects from the local file  system into the workspace.    This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    "
521,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IProjectDescription.html,"A project description contains the meta-data required to define  a project. In effect_ a project description is a project's ""content"".  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
522,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ProjectLocationSelectionDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends SelectionStatusDialog The ProjectLocationSelectionDialog is the dialog used to select the name and  location of a project for copying.    "
523,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ContainerSelectionDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends SelectionDialog A standard selection dialog which solicits a container resource from the user.  The getResult method returns the selected container resource.    This class may be instantiated; it is not intended to be subclassed.      Example:    ContainerSelectionDialog dialog =  new ContainerSelectionDialog(getShell()_ initialSelection_ allowNewContainerName()_ msg);  dialog.open();  Object[] result = dialog.getResult();        Restriction:  This class is not intended to be subclassed by clients.    "
524,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/IWizard.html,Interface for a wizard. A wizard maintains a list of wizard pages_  stacked on top of each other in card layout fashion.    The class Wizard provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if Wizard does not suit their needs.    See Also:  Wizard    
525,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/INewWizard.html,"extends IWorkbenchWizard Interface for creation wizards.    Clients should implement this interface and include the name of their class  in a wizard contributed to the workbench's creation wizard extension point   (named ""org.eclipse.ui.newWizards"").  For example_ the plug-in's XML markup might contain:    <extension point=""org.eclipse.ui.newWizards"">  <wizard  id=""com.example.myplugin.new.blob""  name=""Blob""  class=""com.example.myplugin.BlobCreator""  icon=""icons/new_blob_wiz.gif"">  <description>Create a new BLOB file</description>  <selection class=""org.eclipse.core.resources.IResource"" />   </wizard>  </extension>      See Also:  IWizard    "
526,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchWizard.html,extends IWizard Implementors represent creation wizards that are to be  contributed to the workbench's creation wizard extension point.  See Also:  IWizard    
527,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/newresource/BasicNewFileResourceWizard.html,"Interface for a wizard. A wizard maintains a list of wizard pages_  stacked on top of each other in card layout fashion.    The class Wizard provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if Wizard does not suit their needs.    See Also:  Wizard    
extends IWorkbenchWizard Interface for creation wizards.    Clients should implement this interface and include the name of their class  in a wizard contributed to the workbench's creation wizard extension point   (named ""org.eclipse.ui.newWizards"").  For example_ the plug-in's XML markup might contain:    <extension point=""org.eclipse.ui.newWizards"">  <wizard  id=""com.example.myplugin.new.blob""  name=""Blob""  class=""com.example.myplugin.BlobCreator""  icon=""icons/new_blob_wiz.gif"">  <description>Create a new BLOB file</description>  <selection class=""org.eclipse.core.resources.IResource"" />   </wizard>  </extension>      See Also:  IWizard    
extends IWizard Implementors represent creation wizards that are to be  contributed to the workbench's creation wizard extension point.  See Also:  IWizard    
extends BasicNewResourceWizard Standard workbench wizard that create a new file resource in the workspace.    This class may be instantiated and used without further configuration;  this class is not intended to be subclassed.      Example:    IWorkbenchWizard wizard = new BasicNewFileResourceWizard();  wizard.init(workbench_ selection);  WizardDialog dialog = new WizardDialog(shell_ wizard);  dialog.open();    During the call to open_ the wizard dialog is presented to the  user. When the user hits Finish_ a file resource at the user-specified  workspace path is created_ the dialog closes_ and the call to  open returns.    Restriction:  This class is not intended to be subclassed by clients.    "
528,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IPageChangeProvider.html,Minimal interface to a page change provider. Used for dialogs which can  switch between multiple pages.  Since:  3.1    
529,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/IWizardContainer.html,extends IRunnableContext Interface for containers that can host a wizard. It displays  wizard pages_ at most one of which is considered  the current page. getCurrentPage returns the  current page; showPage programmatically changes the  the current page. Note that the pages need not all belong  to the same wizard.    The class WizardDialog provides a fully functional   implementation of this interface which will meet the needs of  most clients. However_ clients are also free to implement this   interface if WizardDialog does not suit their needs.      Implementors are responsible for disposing of their wizards.    See Also:  IWizardContainer2    
530,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/IWizardContainer2.html,extends IWizardContainer IWizardContainer2 is a supplement to   IWizardContainer that adds a method for updating the size of   the wizard shell based on the contents of the current page.    The class WizardDialog provides a fully functional   implementation of this interface which will meet the needs of  most clients. However_ clients are also free to implement this   interface if WizardDialog does not suit their needs.    Since:  3.0  See Also:  IWizardContainer    
531,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/WizardDialog.html,"Minimal interface to a page change provider. Used for dialogs which can  switch between multiple pages.  Since:  3.1    
Interface for UI components which can execute a long-running operation  in the form of an IRunnableWithProgress.  The context is responsible for displaying a progress indicator and Cancel  button to the end user while the operation is in progress; the context  supplies a progress monitor to be used from code running inside the operation.  Note that an IRunnableContext is not a runnable itself.    For examples of UI components which implement this interface_  see ApplicationWindow_ ProgressMonitorDialog_  and WizardDialog.    See Also:  IRunnableWithProgress_  ApplicationWindow_  ProgressMonitorDialog_  WizardDialog    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends IRunnableContext Interface for containers that can host a wizard. It displays  wizard pages_ at most one of which is considered  the current page. getCurrentPage returns the  current page; showPage programmatically changes the  the current page. Note that the pages need not all belong  to the same wizard.    The class WizardDialog provides a fully functional   implementation of this interface which will meet the needs of  most clients. However_ clients are also free to implement this   interface if WizardDialog does not suit their needs.      Implementors are responsible for disposing of their wizards.    See Also:  IWizardContainer2    
extends IWizardContainer IWizardContainer2 is a supplement to   IWizardContainer that adds a method for updating the size of   the wizard shell based on the contents of the current page.    The class WizardDialog provides a fully functional   implementation of this interface which will meet the needs of  most clients. However_ clients are also free to implement this   interface if WizardDialog does not suit their needs.    Since:  3.0  See Also:  IWizardContainer    
extends TitleAreaDialog implements IWizardContainer2_ IPageChangeProvider A dialog to show a wizard to the end user.    In typical usage_ the client instantiates this class with a particular  wizard. The dialog serves as the wizard container and orchestrates the  presentation of its pages.    The standard layout is roughly as follows: it has an area at the top  containing both the wizard's title_ description_ and image; the actual wizard  page appears in the middle; below that is a progress indicator (which is made  visible if needed); and at the bottom of the page is message line and a  button bar containing Help_ Next_ Back_ Finish_ and Cancel buttons (or some  subset).      Clients may subclass WizardDialog_ although this is rarely  required.      "
532,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/newresource/BasicNewFolderResourceWizard.html,"Interface for a wizard. A wizard maintains a list of wizard pages_  stacked on top of each other in card layout fashion.    The class Wizard provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if Wizard does not suit their needs.    See Also:  Wizard    
extends IWorkbenchWizard Interface for creation wizards.    Clients should implement this interface and include the name of their class  in a wizard contributed to the workbench's creation wizard extension point   (named ""org.eclipse.ui.newWizards"").  For example_ the plug-in's XML markup might contain:    <extension point=""org.eclipse.ui.newWizards"">  <wizard  id=""com.example.myplugin.new.blob""  name=""Blob""  class=""com.example.myplugin.BlobCreator""  icon=""icons/new_blob_wiz.gif"">  <description>Create a new BLOB file</description>  <selection class=""org.eclipse.core.resources.IResource"" />   </wizard>  </extension>      See Also:  IWizard    
extends IWizard Implementors represent creation wizards that are to be  contributed to the workbench's creation wizard extension point.  See Also:  IWizard    
extends BasicNewResourceWizard Standard workbench wizard that create a new folder resource in the workspace.    This class may be instantiated and used without further configuration;  this class is not intended to be subclassed.      Example:    IWorkbenchWizard wizard = new BasicNewFolderResourceWizard();  wizard.init(workbench_ selection);  WizardDialog dialog = new WizardDialog(shell_ wizard);  dialog.open();    During the call to open_ the wizard dialog is presented to the  user. When the user hits Finish_ a folder resource at the user-specified  workspace path is created_ the dialog closes_ and the call to  open returns.    Restriction:  This class is not intended to be subclassed by clients.    "
533,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ProjectLocationMoveDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends SelectionDialog The ProjectLocationMoveDialog is the dialog used to select the location of a  project for moving.    "
534,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISharedImages.html,A registry for common images used by the workbench which may be useful   to other plug-ins.    This class provides Image and ImageDescriptors  for each named image in the interface. All Image objects provided   by this class are managed by this class and must never be disposed   by other clients.      This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
535,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/IWizardCategory.html,A wizard category may contain other categories or wizard elements.     This interface is not intended to be implemented by clients.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.    
536,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/IWizardDescriptor.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Description of a workbench part. The part descriptor contains   the information needed to create part instances.    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkbenchPartDescriptor_ IAdaptable Base interface for all wizards defined via workbench extension points.    This interface is not intended to be implemented by clients.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.    "
537,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/content/IContentTypeSettings.html,Gives access to the user settings for a content type.    This interface is not intended to be implemented by clients.    Since:  3.1  See Also:  IContentType_  IContentType.getSettings(IScopeContext)    
538,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/content/IContentType.html,"Gives access to the user settings for a content type.    This interface is not intended to be implemented by clients.    Since:  3.1  See Also:  IContentType_  IContentType.getSettings(IScopeContext)    
extends IContentTypeSettings Content types represent and provide information on file types_ such as   associated file names/extensions_ default charset_ etc.    This interface is not intended to be implemented by clients.    Since:  3.0    "
539,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IFileEditorInput.html,extends IStorageEditorInput This interface defines a file-oriented input to an editor.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs  that are the same. The IWorbenchPage.openEditor APIs  are dependent on this to find an editor with the same input.    File-oriented editors should support this as a valid input type_ and allow  full read-write editing of its content.    A default implementation of this interface is provided by   org.eclipse.ui.part.FileEditorInput.     All editor inputs must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IFile    
540,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IStorageEditorInput.html,"extends IEditorInput Interface for a IStorage input to an editor.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs  that are the same. The IWorbenchPage.openEditor APIs  are dependent on this to find an editor with the same input.    Clients should implement this interface to declare new types of   IStorage editor inputs.    File-oriented editors should support this as a valid input type_ and display  its content for viewing (but not allow modification).  Within the editor_ the ""save"" and ""save as"" operations should create a new   file resource within the workspace.    All editor inputs must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.      "
541,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IURIEditorInput.html,extends IEditorInput This interface defines an editor input based on a URI.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs  that are the same. The IWorkbenchPage.openEditor APIs  are dependent on this to find an editor with the same input.    Path-oriented editors should support this as a valid input type_ and  can allow full read-write editing of its content.    All editor inputs must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    Since:  3.3  See Also:  URI    
542,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/FileEditorInput.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable IEditorInput is a light weight descriptor of editor input_  like a file name but more abstract. It is not a model. It is a description of  the model source for an IEditorPart.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs that are  the same. The IWorbenchPage.openEditor APIs are dependent on  this to find an editor with the same input.      Clients should extend this interface to declare new types of editor inputs.      An editor input is passed to an editor via the IEditorPart.init  method. Due to the wide range of valid editor inputs_ it is not possible to  define generic methods for getting and setting bytes.      Editor input must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.      Please note that it is important that the editor input be light weight.  Within the workbench_ the navigation history tends to hold on to editor  inputs as a means of reconstructing the editor at a later time. The  navigation history can hold on to quite a few inputs (i.e._ the default is  fifty). The actual data model should probably not be held in the input.    See Also:  IEditorPart_  IWorkbenchPage.openEditor(IEditorInput_ String)_  IWorkbenchPage.openEditor(IEditorInput_ String_ boolean)    
extends IStorageEditorInput This interface defines a file-oriented input to an editor.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs  that are the same. The IWorbenchPage.openEditor APIs  are dependent on this to find an editor with the same input.    File-oriented editors should support this as a valid input type_ and allow  full read-write editing of its content.    A default implementation of this interface is provided by   org.eclipse.ui.part.FileEditorInput.     All editor inputs must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IFile    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable IEditorInput is a light weight descriptor of editor input_  like a file name but more abstract. It is not a model. It is a description of  the model source for an IEditorPart.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs that are  the same. The IWorbenchPage.openEditor APIs are dependent on  this to find an editor with the same input.      Clients should extend this interface to declare new types of editor inputs.      An editor input is passed to an editor via the IEditorPart.init  method. Due to the wide range of valid editor inputs_ it is not possible to  define generic methods for getting and setting bytes.      Editor input must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.      Please note that it is important that the editor input be light weight.  Within the workbench_ the navigation history tends to hold on to editor  inputs as a means of reconstructing the editor at a later time. The  navigation history can hold on to quite a few inputs (i.e._ the default is  fifty). The actual data model should probably not be held in the input.    See Also:  IEditorPart_  IWorkbenchPage.openEditor(IEditorInput_ String)_  IWorkbenchPage.openEditor(IEditorInput_ String_ boolean)    
extends IEditorInput This interface defines an editor input based on the local file system path  of a file.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs  that are the same. The IWorkbenchPage.openEditor APIs  are dependent on this to find an editor with the same input.    Path-oriented editors should support this as a valid input type_ and  can allow full read-write editing of its content.    All editor inputs must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    Since:  3.0  See Also:  IPath    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IPersistable Interface for asking an object to store its state in a memento.    This interface is typically included in interfaces where   persistance is required.    When the workbench is shutdown objects which implement this interface   will be persisted. At this time the getFactoryId method   is invoked to discover the id of the element factory that will be used   to re-create the object from a memento. Then the saveState   method is invoked to store the element data into a newly created memento.   The resulting mementos are collected up and written out to a single file.      During workbench startup these mementos are read from the file. The  factory Id for each is retrieved and mapped to an IElementFactory   which has been registered in the element factory extension point. If a   factory exists for the Id it will be engaged to re-create the original   object.    See Also:  IAdaptable_  IMemento_  IElementFactory    
extends IEditorInput Interface for a IStorage input to an editor.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs  that are the same. The IWorbenchPage.openEditor APIs  are dependent on this to find an editor with the same input.    Clients should implement this interface to declare new types of   IStorage editor inputs.    File-oriented editors should support this as a valid input type_ and display  its content for viewing (but not allow modification).  Within the editor_ the ""save"" and ""save as"" operations should create a new   file resource within the workspace.    All editor inputs must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.      
extends IEditorInput This interface defines an editor input based on a URI.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs  that are the same. The IWorkbenchPage.openEditor APIs  are dependent on this to find an editor with the same input.    Path-oriented editors should support this as a valid input type_ and  can allow full read-write editing of its content.    All editor inputs must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    Since:  3.3  See Also:  URI    
extends PlatformObject implements IFileEditorInput_ IPathEditorInput_ IURIEditorInput_ IPersistableElement Adapter for making a file resource a suitable input for an editor.    This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    "
543,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/ResourceAttributes.html,extends Object This class represents platform specific attributes of files.  Any attributes can be added_ but only the attributes that are   supported by the platform will be used. These methods do not set the   attributes in the file system.  Since:  3.1  See Also:  IResource.getResourceAttributes()_  IResource.setResourceAttributes(ResourceAttributes)  Restriction:  This class is not intended to be subclassed by clients.    
544,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/WorkspaceJob.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends org.eclipse.core.internal.resources.InternalWorkspaceJob A job that makes an atomic modification to the workspace. Clients must  implement the abstract method runInWorkspace instead  of the usual Job.run method.    After running a method that modifies resources in the workspace_  registered listeners receive after-the-fact notification of  what just transpired_ in the form of a resource change event.  This method allows clients to call a number of  methods that modify resources and only have resource  change event notifications reported at the end of the entire  batch. This mechanism is used to avoid unnecessary builds   and notifications.      Platform may decide to perform notifications during the operation.  The reason for this is that it is possible for multiple threads   to be modifying the workspace concurrently. When one thread finishes modifying   the workspace_ a notification is required to prevent responsiveness problems_   even if the other operation has not yet completed.      A WorkspaceJob is the asynchronous equivalent of IWorkspaceRunnable      Note that the workspace is not locked against other threads during the execution   of a workspace job. Other threads can be modifying the workspace concurrently   with a workspace job. To obtain exclusive access to a portion of the workspace_   set the scheduling rule on the job to be a resource scheduling rule. The  interface IResourceRuleFactory is used to create a scheduling rule   for a particular workspace modification operation.    Since:  3.0  See Also:  IWorkspaceRunnable_  IResourceRuleFactory_  IWorkspace.run(IWorkspaceRunnable_ ISchedulingRule_ int_ IProgressMonitor)    "
545,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/MoveResourcesOperation.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractWorkspaceOperation A MoveResourcesOperation represents an undoable operation for moving one or  more resources in the workspace. Clients may call the public API from a  background thread.    This operation can track any overwritten resources and restore them when the  move is undone. It is up to clients to determine whether overwrites are  allowed. If a resource should not be overwritten_ it should not be included  in this operation. In addition to checking for overwrites_ the target  location for the move is assumed to have already been validated by the  client. It will not be revalidated on undo and redo.      This class is intended to be instantiated and used by clients. It is not  intended to be subclassed by clients.    Since:  3.3  Restriction:  This class is not intended to be subclassed by clients.    "
546,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdapterManager.html,"An adapter manager maintains a registry of adapter factories. Clients  directly invoke methods on an adapter manager to register and unregister  adapters. All adaptable objects (that is_ objects that implement the IAdaptable  interface) funnel IAdaptable.getAdapter invocations to their  adapter manager's IAdapterManger.getAdapter method. The  adapter manager then forwards this request unmodified to the IAdapterFactory.getAdapter  method on one of the registered adapter factories.    Adapter factories can be registered programmatically using the registerAdapters  method. Alternatively_ they can be registered declaratively using the   org.eclipse.core.runtime.adapters extension point. Factories registered  with this extension point will not be able to provide adapters until their  corresponding plugin has been activated.    The following code snippet shows how one might register an adapter of type  com.example.acme.Sticky on resources in the workspace.        IAdapterFactory pr = new IAdapterFactory() {  public Class[] getAdapterList() {  return new Class[] { com.example.acme.Sticky.class };  }  public Object getAdapter(Object adaptableObject_ Class adapterType) {  IResource res = (IResource) adaptableObject;  QualifiedName key = new QualifiedName(""com.example.acme""_ ""sticky-note"");  try {  com.example.acme.Sticky v = (com.example.acme.Sticky) res.getSessionProperty(key);  if (v == null) {  v = new com.example.acme.Sticky();  res.setSessionProperty(key_ v);  }  } catch (CoreException e) {  // unable to access session property - ignore  }  return v;  }  }  Platform.getAdapterManager().registerAdapters(pr_ IResource.class);        This interface can be used without OSGi running.    This interface is not intended to be implemented by clients.    See Also:  IAdaptable_  IAdapterFactory  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
547,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/ResourceMapping.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends PlatformObject A resource mapping supports the transformation of an application model   object into its underlying file system resources. It provides the  bridge between a logical element and the physical resource(s) into which it  is stored but does not provide more comprehensive model access or  manipulations.    Mappings provide two means of model traversal. The accept(org.eclipse.core.resources.mapping.ResourceMappingContext_ org.eclipse.core.resources.IResourceVisitor_ org.eclipse.core.runtime.IProgressMonitor) method  can be used to visit the resources that constitute the model object. Alternatively_  a set or traversals can be obtained by calling getTraversals(org.eclipse.core.resources.mapping.ResourceMappingContext_ org.eclipse.core.runtime.IProgressMonitor). A traversal  contains a set of resources and a depth. This allows clients (such a repository providers)  to do optimal traversals of the resources w.r.t. the operation that is being performed  on the model object.      This class may be subclassed by clients.    Since:  3.2  See Also:  IResource_  ResourceTraversal    "
548,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspaceRunnable.html,A runnable which executes as a batch operation within the workspace.  The IWorkspaceRunnable interface should be implemented  by any class whose instances are intended to be run by  IWorkspace.run.    Clients may implement this interface.    See Also:  IWorkspace.run(IWorkspaceRunnable_ IProgressMonitor)    
549,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ICheckStateListener.html,A listener which is notified of changes to the checked  state of items in checkbox viewers.  See Also:  CheckStateChangedEvent    
550,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/WorkbenchViewerComparator.html,extends ViewerComparator A viewer comparator that sorts elements with registered workbench adapters by  their text property. Note that capitalization differences are not considered  by this sorter_ so a > B > c  Since:  3.3  See Also:  IWorkbenchAdapter    
551,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkingSet.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IPersistable Interface for asking an object to store its state in a memento.    This interface is typically included in interfaces where   persistance is required.    When the workbench is shutdown objects which implement this interface   will be persisted. At this time the getFactoryId method   is invoked to discover the id of the element factory that will be used   to re-create the object from a memento. Then the saveState   method is invoked to store the element data into a newly created memento.   The resulting mementos are collected up and written out to a single file.      During workbench startup these mementos are read from the file. The  factory Id for each is retrieved and mapped to an IElementFactory   which has been registered in the element factory extension point. If a   factory exists for the Id it will be engaged to re-create the original   object.    See Also:  IAdaptable_  IMemento_  IElementFactory    
extends IPersistableElement_ IAdaptable A working set holds a number of IAdaptable elements.   A working set is intended to group elements for presentation to   the user or for operations on a set of elements.  Since:  2.0 initial version_ 3.0 now extends IPersistableElement_ 3.2 now extends IAdaptable  Restriction:  This interface is not intended to be implemented by clients.    "
552,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/Preferences.html,"extends Object A table of preference settings_ mapping named properties to values. Property  names are non-empty strings; property values can be either booleans_  non-null strings_ or values of one of the primitive number types.  The table consists of two_ sparse_ layers: the lower layer holds default values   for properties_ and the upper layer holds explicitly set values for properties.  Normal retrieval looks for an explicitly set value for the given property in  the upper layer; if there is nothing for that property in the upper layer_ it  next looks for a default value for the given property in the lower layer; if  there is nothing for that property in the lower layer_ it returns a standard  default-default value. The default-default values for the primitive types are  as follows:  boolean = false  double = 0.0  float = 0.0f  int = 0  long = 0L  String = """" (the empty string)    Internally_ all properties values (in both layers) are stored as strings.  Standard conversions to and from numeric and boolean types are performed on  demand.      The typical usage is to establish the defaults for all known properties  and then restore previously stored values for properties whose values   were explicitly set. The existing settings can be changed and new properties  can be set (setValue). If the values specified is the same as   the default value_ the explicit setting is deleted from the top layer.  It is also possible to reset a property value back to the default value   using setToDefault. After the properties have been modified_   the properties with explicit settings are written to disk. The default values  are never saved. This two-tiered approach  to saving and restoring property setting minimizes the number of properties  that need to be persisted; indeed_ the normal starting state does not require  storing any properties at all. It also makes it easy to use different   default settings in different environments while maintaining just those  property settings the user has adjusted.      A property change event is reported whenever a property's value actually  changes (either through setValue_ setToDefault).  Note_ however_ that manipulating default values (with setDefault)  does not cause any events to be reported.      Clients may instantiate this class.      The implementation is based on a pair of internal   java.util.Properties objects_ one holding explicitly set values  (set using setValue)_ the other holding the default values  (set using setDefaultValue). The load and  store methods persist the non-default property values to   streams (the default values are not saved).      If a client sets a default value to be equivalent to the default-default for that  type_ the value is still known to the preference store as having a default value.  That is_ the name will still be returned in the result of the defaultPropertyNames  and contains methods.    Since:  2.0  Restriction:  This class is not intended to be subclassed by clients.    "
553,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/WorkspaceModifyOperation.html,"The IRunnableWithProgress interface should be implemented by any  class whose instances are intended to be executed as a long-running operation.  Long-running operations are typically presented at the UI via a modal dialog  showing a progress indicator and a Cancel button.  The class must define a run method that takes a progress monitor.  The run method is usually not invoked directly_ but rather by  passing the IRunnableWithProgress to the run method of  an IRunnableContext_ which provides the UI for the progress monitor  and Cancel button.  See Also:  IRunnableContext    
A thread listener is an object that is interested in receiving notifications  of thread changes. For example_ a thread listener can be used to notify a   runnable of the thread that will execute it_ allowing the runnable to transfer  thread-local state from the calling thread before control passes to the new thread.  Since:  3.1    
extends Object implements IRunnableWithProgress_ IThreadListener An operation which potentially makes changes to the workspace. All resource  modification should be performed using this operation. The primary  consequence of using this operation is that events which typically occur as a  result of workspace changes (such as the firing of resource deltas_  performance of autobuilds_ etc.) are generally deferred until the outermost operation  has successfully completed. The platform may still decide to broadcast  periodic resource change notifications during the scope of the operation  if the operation runs for a long time or another thread modifies the workspace  concurrently.    If a scheduling rule is provided_ the operation will obtain that scheduling  rule for the duration of its execute method. If no scheduling  rule is provided_ the operation will obtain a scheduling rule that locks  the entire workspace for the duration of the operation.      Subclasses must implement execute to do the work of the  operation.    See Also:  ISchedulingRule_  IWorkspace.run(IWorkspaceRunnable_ IProgressMonitor)    "
554,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IProjectNatureDescriptor.html,A project nature descriptor contains information about a project nature  obtained from the plug-in manifest (plugin.xml) file.    Nature descriptors are platform-defined objects that exist  independent of whether that nature's plug-in has been started.   In contrast_ a project nature's runtime object (IProjectNature)   generally runs plug-in-defined code.    Since:  2.0  See Also:  IProjectNature_  IWorkspace.getNatureDescriptor(String)  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
555,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceProxy.html,"A lightweight interface for requesting information about a resource.  All of the ""get"" methods on a resource proxy have trivial performance cost.   Requesting the full path or the actual resource handle will cause extra objects   to be created and will thus have greater cost.    When a resource proxy is used within an IResourceProxyVisitor_  it is a transient object that is only valid for the duration of a single visit method.   A proxy should not be referenced once the single resource visit is complete.   The equals and hashCode methods should not be relied on.      A proxy can also be created using IResource.createProxy(). In  this case the proxy is valid indefinitely_ but will not remain in sync with  the state of the corresponding resource.    Since:  2.1  See Also:  IResourceProxyVisitor  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
556,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IFileEditorMapping.html,An association between a file name/extension and a list of known editors for   files of that type.    The name and extension can never empty or null. The name may contain  the single wild card character (*) to indicate the editor applies to  all files with the same extension (e.g. *.doc). The name can never  embed the wild card character within itself (i.e. rep*)      This interface is not intended to be implemented by clients.    See Also:  IEditorRegistry.getFileEditorMappings()  Restriction:  This interface is not intended to be implemented by clients.    
557,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/CompositeImageDescriptor.html,extends ImageDescriptor Abstract base class for image descriptors that synthesize an image from other  images in order to simulate the effect of custom drawing. For example_ this  could be used to superimpose a red bar dexter symbol across an image to  indicate that something was disallowed.    Subclasses must implement the getSize and fill  methods. Little or no work happens until the image descriptor's image is  actually requested by a call to createImage (or to  getImageData directly).      
558,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/SelectionAdapter.html,"extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated when selection  occurs in a control.    After creating an instance of a class that implements  this interface it can be added to a control using the  addSelectionListener method and removed using  the removeSelectionListener method. When  selection occurs in a control the appropriate method  will be invoked.    See Also:  SelectionAdapter_  SelectionEvent    
extends Object implements SelectionListener This adapter class provides default implementations for the  methods described by the SelectionListener interface.    Classes that wish to deal with SelectionEvents can  extend this class and override only the methods which they are  interested in.    See Also:  SelectionListener_  SelectionEvent_  Sample code and further information    "
559,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/dialogs/PathVariableSelectionDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends SelectionDialog A selection dialog which shows the path variables defined in the   workspace.  The getResult method returns the name(s) of the   selected path variable(s).    This class may be instantiated; it is not intended to be subclassed.      Example:    PathVariableSelectionDialog dialog =  new PathVariableSelectionDialog(getShell()_ IResource.FOLDER);  dialog.open();  String[] result = (String[]) dialog.getResult();        Since:  3.1    "
560,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IPathVariableManager.html,Manages a collection of path variables and resolves paths containing a  variable reference.    A path variable is a pair of non-null elements (name_value) where name is   a case-sensitive string (containing only letters_ digits and the underscore  character_ and not starting with a digit)_ and value is an absolute  IPath object.      Path variables allow for the creation of relative paths whose exact  location in the file system depends on the value of a variable. A variable  reference may only appear as the first segment of a relative path.    Since:  2.1  See Also:  IPath  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
561,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IMarker.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable Markers are a general mechanism for associating notes and meta-data with  resources.    Markers themselves are handles in the same way as IResources  are handles. Instances of IMarker do not hold the attributes  themselves but rather uniquely refer to the attribute container. As such_  their state may change underneath the handle with no warning to the holder  of the handle.    The Resources plug-in provides a general framework for   defining and manipulating markers and provides several standard marker types.      Each marker has:  a type string_ specifying its type (e.g.   ""org.eclipse.core.resources.taskmarker"")_   an identifier which is unique (relative to a particular resource)  Specific types of markers may carry additional information.      The resources plug-in defines five standard types:    org.eclipse.core.resources.marker  org.eclipse.core.resources.taskmarker  org.eclipse.core.resources.problemmarker  org.eclipse.core.resources.bookmark  org.eclipse.core.resources.textmarker  The plug-in also provides an extension point (  org.eclipse.core.resources.markers) into which other  plug-ins can install marker type declaration extensions.      Marker types are declared within a multiple inheritance type system.  New markers are defined in the plugin.xml file of the  declaring plug-in. A valid declaration contains elements as defined by  the extension point DTD:    type - the unique name of the marker type  super - the list of marker types of which this marker is to be considered a sub-type  attributes - the list of standard attributes which may be present on this type of marker  persistent - whether markers of this type should be persisted by the platform All markers declared as persistent are saved when the  workspace is saved_ except those explicitly set as transient (the  TRANSIENT attribute is set as true). A plug-in  which defines a persistent marker is not directly involved in saving and  restoring the marker. Markers are not under version and configuration  management_ and cannot be shared via VCM repositories.      Markers implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
562,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IInPlaceEditor.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IEditorPart Interface for editor parts that represent an in-place style editor.    This interface is not intended to be implemented or extended by clients.    Since:  3.0  See Also:  IEditorDescriptor.isOpenInPlace()  Restriction:  This interface is not intended to be implemented by clients.    "
563,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/content/IContentDescription.html,A content description object contains information about the nature of   arbitrary data.    A content description object will always include the content type for the   examined contents_ and may also include information on:    charset;  byte order mark;  other custom properties provided by third-party plug-ins.      Content describers provided by plug-ins will fill in most of the  properties in a content description object_ except for the content type_   what is done by the platform. After a content   description is filled in by a content interpreter_ it is marked as immutable  by the platform_ so calling any of the mutator methods defined in this   interface will cause an IllegalStateException to be thrown.         Default values for properties can be contributed by plug-ins as part of  the content type definition markup.      This interface is not intended to be implemented by clients.    Since:  3.0  See Also:  IContentDescriber    
564,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/FileInfoMatcherDescription.html,extends Object A description of a file info matcher.  Since:  3.6    
565,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceFilterDescription.html,A description of a resource filter.    A filter determines which file system objects will be visible when a local refresh is   performed for an IContainer.  Since:  3.6  See Also:  IContainer.getFilters()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
566,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IMarkerHelpRegistry.html,Registry of F1 help contexts and resolutions for markers.    The information contained in the registry is read from the   org.eclipse.ui.markerhelp and org.eclipse.ui.markerresolution  extension points.    Since:  2.0    
567,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/content/IContentTypeMatcher.html,An object that performs content type matching queries.     This interface is not intended to be implemented by clients.    Since:  3.1  See Also:  IContentTypeManager.getMatcher(IContentTypeManager.ISelectionPolicy_ IScopeContext)    
568,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdapterFactory.html,An adapter factory defines behavioral extensions for  one or more classes that implements the IAdaptable  interface. Adapter factories are registered with an  adapter manager.    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IAdapterManager_  IAdaptable    
569,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/ModelStatus.html,"A status object represents the outcome of an operation.  All CoreExceptions carry a status object to indicate   what went wrong. Status objects are also returned by methods needing   to provide details of failures (e.g._ validation methods).    A status carries the following information:    plug-in identifier (required)  severity (required)  status code (required)  message (required) - localized to current locale  exception (optional) - for problems stemming from a failure at  a lower level  Some status objects_ known as multi-statuses_ have other status objects   as children.      The class Status is the standard public implementation  of status objects; the subclass MultiStatus is the  implements multi-status objects.    This interface can be used without OSGi running.    See Also:  MultiStatus_  Status    
extends Status A status returned by a model from the resource operation validator.  The severity indicates the severity of the possible side effects  of the operation. Any severity other than OK should be  shown to the user. The message should be a human readable message that  will allow the user to make a decision as to whether to continue with the   operation. The model provider id should indicate which model is flagging the  the possible side effects.    Clients may instantiate or subclass this class.    Since:  3.2    "
570,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/IModelProviderDescriptor.html,A model provider descriptor contains information about a model provider  obtained from the plug-in manifest (plugin.xml) file.    Model provider descriptors are platform-defined objects that exist  independent of whether that model provider's plug-in has been started.   In contrast_ a model provider's runtime object (ModelProvider)   generally runs plug-in-defined code.    Since:  3.2  See Also:  ModelProvider  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
571,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/Saveable.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends org.eclipse.ui.internal.InternalSaveable implements IAdaptable A Saveable represents a unit of saveability_ e.g. an editable  subset of the underlying domain model that may contain unsaved changes.  Different workbench parts (editors and views) may present the same saveables  in different ways. This interface allows the workbench to provide more  appropriate handling of operations such as saving and closing workbench  parts. For example_ if two editors sharing the same saveable with unsaved  changes are closed simultaneously_ the user is only prompted to save the  changes once for the shared saveable_ rather than once for each editor.    Workbench parts that work in terms of saveables should implement  ISaveablesSource.    Since:  3.2  See Also:  ISaveablesSource    "
572,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/ResourceTraversal.html,extends Object A resource traversal is simply a set of resources and the depth to which  each is to be traversed. A set of traversals is used to describe the  resources that constitute a model element.    The flags of the traversal indicate which special resources should be  included or excluded from the traversal. The flags used are the same as  those passed to the IResource.accept(IResourceVisitor_ int_ int) method.      This class may be instantiated or subclassed by clients.    Since:  3.2  See Also:  IResource    
573,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPartReference.html,Implements a reference to a IWorkbenchPart.  The IWorkbenchPart will not be instantiated until the part   becomes visible or the API getPart is sent with true;    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    
574,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorReference.html,"Implements a reference to a IWorkbenchPart.  The IWorkbenchPart will not be instantiated until the part   becomes visible or the API getPart is sent with true;    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkbenchPartReference Implements a reference to an editor. The IEditorPart will not be instantiated  until the editor becomes visible or the API getEditor(boolean) is  called with true.    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    "
575,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ReadOnlyStateChecker.html,extends Object The ReadOnlyStateChecker is a helper class that takes a set of resource  some of which may be read only and queries the user as to whether or  not they wish to continue the operation on it.    
576,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/OperationHistoryEvent.html,extends Object  OperationHistoryEvent is used to communicate changes that occur in a  DefaultOperationHistory_ including the addition or removal of operations_ and  the execution_ undo_ and redo of operations.      Operation history listeners must be prepared to receive notifications from a  background thread. Any UI access occurring inside the implementation must be  properly synchronized using the techniques specified by the client's widget  library.    Since:  3.1    
577,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IBundleGroup.html,Bundle groups represent a logical collection of plug-ins (aka bundles). Bundle  groups do not contain their constituents but rather collect them together under  a common label. The main role of a bundle group is to report to the system  (e.g._ the About dialog) what bundles have been installed. They are not intended  for use in managing the set of bundles they represent.    Since the bulk of the branding related information is specific to the consumer_   bundle groups also carry an arbitrary set of properties. The valid set of   key-value pairs and their interpretation defined by the consumer in the   target environment.    The Eclipse UI is the typical consumer of bundle groups and defines various   property keys that it will use_ for example_ to display About information. See  org.eclipse.ui.branding.IBundleGroupConstants.    Since:  3.0  See Also:  IBundleGroupProvider    
578,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/IActionBarConfigurer.html,Interface providing special access for configuring the action bars  of a workbench window.    Note that these objects are only available to the main application  (the plug-in that creates and owns the workbench).      This interface is not intended to be implemented by clients.    Since:  3.0  See Also:  WorkbenchAdvisor.fillActionBars(org.eclipse.ui.IWorkbenchWindow_ org.eclipse.ui.application.IActionBarConfigurer_ int)  Restriction:  This interface is not intended to be implemented by clients.    
579,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ISelectionChangedListener.html,A listener which is notified when a viewer's selection changes.  See Also:  ISelection_  ISelectionProvider_  SelectionChangedEvent    
580,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/BuildAction.html,"An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
A listener which is notified when a viewer's selection changes.  See Also:  ISelection_  ISelectionProvider_  SelectionChangedEvent    
extends WorkspaceAction Standard actions for full and incremental builds of the selected project(s)  and their references project build configurations.    This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    "
581,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/IDisposable.html, The interface that should be implemented by services that make themselves  available through the IAdaptable mechanism. This is the  interface that drives the majority of services provided at the workbench  level.      A service has life-cycle. When the constructor completes_ the service must be  fully functional. When it comes time for the service to go away_ then the  service will receive a dispose() call. At this point_ the service  must release all resources and detach all listeners. A service can only be  disposed once; it cannot be reused.      This interface has nothing to do with OSGi services.      This interface can be extended or implemented by clients.    Since:  3.2    
582,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICommandService.html," The interface that should be implemented by services that make themselves  available through the IAdaptable mechanism. This is the  interface that drives the majority of services provided at the workbench  level.      A service has life-cycle. When the constructor completes_ the service must be  fully functional. When it comes time for the service to go away_ then the  service will receive a dispose() call. At this point_ the service  must release all resources and detach all listeners. A service can only be  disposed once; it cannot be reused.      This interface has nothing to do with OSGi services.      This interface can be extended or implemented by clients.    Since:  3.2    
extends IDisposable  Provides services related to the command architecture within the workbench.  This service can be used to access the set of commands and command  categories.      This service can be acquired from your service locator:    ICommandService service = (ICommandService) getSite().getService(ICommandService.class);    This service is available globally.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
583,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/IServiceWithSources.html,extends IDisposable  A service that responds to changes in one or more sources. These sources can  be plugged into the service. Sources represent a common event framework for  services.      Clients must not extend or implement.    Since:  3.2    
584,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/handlers/IHandlerService.html," The interface that should be implemented by services that make themselves  available through the IAdaptable mechanism. This is the  interface that drives the majority of services provided at the workbench  level.      A service has life-cycle. When the constructor completes_ the service must be  fully functional. When it comes time for the service to go away_ then the  service will receive a dispose() call. At this point_ the service  must release all resources and detach all listeners. A service can only be  disposed once; it cannot be reused.      This interface has nothing to do with OSGi services.      This interface can be extended or implemented by clients.    Since:  3.2    
extends IDisposable  A service that responds to changes in one or more sources. These sources can  be plugged into the service. Sources represent a common event framework for  services.      Clients must not extend or implement.    Since:  3.2    
extends IServiceWithSources  Provides services related to activating and deactivating handlers within the  workbench.      This service can be acquired from your service locator:    IHandlerService service = (IHandlerService) getSite().getService(IHandlerService.class);    This service is available globally.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
585,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/EvaluationContext.html,"An evaluation context is used to manage a set of objects needed during  XML expression evaluation. A context has a parent context_ can manage  a set of named variables and has a default variable. The default variable  is used during XML expression evaluation if no explicit variable is  referenced.    This interface is not intended to be implemented by clients. Clients  are allowed to instantiate EvaluationContext.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
extends Object implements IEvaluationContext A default implementation of an evaluation context.    Clients may instantiate this default context. The class is  not intended to be subclassed by clients.    Since:  3.0  Restriction:  This class is not intended to be subclassed by clients.    "
586,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/PropertyDialogAction.html,"An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
A listener which is notified when a viewer's selection changes.  See Also:  ISelection_  ISelectionProvider_  SelectionChangedEvent    
extends SelectionProviderAction Standard action for opening a Property Pages Dialog on the currently selected  element.    This class may be instantiated; it is not intended to be subclassed.      Generally speaking_ this action is useful in pop-up menus because it allows  the user to browse and change properties of selected elements. When  performed_ the action will bring up a Property Pages Dialog containing  property pages registered with the workbench for elements of the selected  type.      Although the action is capable of calculating if there are any applicable  pages for the current selection_ this calculation is costly because it  require searching the workbench registry. Where performance is critical_ the  action can simply be added to the pop-up menu. In the event of no applicable  pages_ the action will just open an appropriate message dialog.    Restriction:  This class is not intended to be subclassed by clients.    "
587,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/IBindingService.html," The interface that should be implemented by services that make themselves  available through the IAdaptable mechanism. This is the  interface that drives the majority of services provided at the workbench  level.      A service has life-cycle. When the constructor completes_ the service must be  fully functional. When it comes time for the service to go away_ then the  service will receive a dispose() call. At this point_ the service  must release all resources and detach all listeners. A service can only be  disposed once; it cannot be reused.      This interface has nothing to do with OSGi services.      This interface can be extended or implemented by clients.    Since:  3.2    
extends IDisposable  Provides services related to the binding architecture (e.g._ keyboard  shortcuts) within the workbench. This service can be used to access the  currently active bindings_ as well as the current state of the binding  architecture.      This service can be acquired from your service locator:    IBindingService service = (IBindingService) getSite().getService(IBindingService.class);    This service is available globally.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
588,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkingSetManager.html,A working set manager stores working sets and provides property   change notification when a working set is added or removed.    The workbench working set manager can be accessed using   IWorkbench#getWorkingSetManager()      This interface is not intended to be implemented by clients.    Since:  2.0 initial version_ 3.0 added createWorkingSet(IMemento)  See Also:  IWorkingSet  Restriction:  This interface is not intended to be implemented by clients.    
589,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/IWorkingSetSelectionDialog.html,A working set selection dialog displays the list of working  sets available in the workbench.    Use org.eclipse.ui.IWorkingSetManager#createWorkingSetSelectionDialog(Shell)  to create an instance of this dialog.      This interface is not intended to be implemented by clients.    Since:  2.0  See Also:  IWorkingSetManager  Restriction:  This interface is not intended to be implemented by clients.    
590,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspaceDescription.html,A workspace description represents the workspace preferences. It can be  used to query the current preferences and set new ones. The workspace  preference values are stored in the preference store and are also accessible  via the preference mechanism. Constants for the preference keys are found  on the ResourcesPlugin class.  See Also:  IWorkspace.getDescription()_  IWorkspace.setDescription(IWorkspaceDescription)_  IWorkspace.newProjectDescription(String)  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
591,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ExpandableComposite.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Canvas This composite is capable of expanding or collapsing a single client that is  its direct child. The composite renders an expansion toggle affordance  (according to the chosen style)_ and a title that also acts as a hyperlink  (can be selected and is traversable). The client is layed out below the title  when expanded_ or hidden when collapsed.    The widget can be instantiated as-is_ or subclassed to modify some aspects of  it. *    Since 3.1_ left/right arrow keys can be used to control the expansion state.  If several expandable composites are created in the same parent_ up/down  arrow keys can be used to traverse between them. Expandable text accepts  mnemonics and mnemonic activation will toggle the expansion state.      While expandable composite recognize that different styles can be used to  render the title bar_ and even defines the constants for these styles (TITLE_BAR  and SHORT_TITLE_BAR the actual painting is done in the  subclasses.  Since:  3.0  See Also:  Section    "
592,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/preferences/SettingsTransfer.html,extends Object The SettingsTransfer is the abstract superclass of settings transfers  used when switching workspaces.  Since:  3.3    
593,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IDecoration.html,Defines the result of decorating an element.    This interface is not meant to be implemented and will be provided to  instances of ILightweightLabelDecorator.  Restriction:  This interface is not intended to be implemented by clients.    
594,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IContributorResourceAdapter.html,The IContributorResourceAdapter is an interface that defines  the API required to get a resource that an object adapts to  for use of object contributions_ decorators and property  pages that have adaptable = true.  Implementors of this interface are typically registered with an  IAdapterFactory for lookup via the getAdapter() mechanism.    
595,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ListSelectionDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends SelectionDialog A standard dialog which solicits a list of selections from the user.  This class is configured with an arbitrary data model represented by content  and label provider objects. The getResult method returns the  selected elements.    This class may be instantiated; it is not intended to be subclassed.      Example:    ListSelectionDialog dlg =  new ListSelectionDialog(  getShell()_  input_  new BaseWorkbenchContentProvider()_  new WorkbenchLabelProvider()_  ""Select the resources to save:"");  dlg.setInitialSelections(dirtyEditors);  dlg.setTitle(""Save Resources"");  dlg.open();      Restriction:  This class is not intended to be subclassed by clients.    "
596,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ActionFactory.IWorkbenchAction.html,extends IAction Interface for a workbench action.    
597,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/GlobalBuildAction.html,"An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
extends IAction Interface for a workbench action.    
extends Action implements ActionFactory.IWorkbenchAction Standard action for full and incremental builds of all projects within the  workspace.    This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    "
598,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/equinox/p2/engine/IProfileRegistry.html,This encapsulates the access to the profile registry.   It deals with persistence in a transparent way.  Since:  2.0  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
599,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/equinox/p2/engine/IProfile.html,extends IQueryable<IInstallableUnit> Represents the state of a profile in a profile registry at a given moment in time.  Note this object contains only a snapshot of a particular profile state_ and will  never be updated if subsequent changes are made to this profile. A client should  never retain an IProfile instance_ but rather retain the profile id and obtain  the current state of the profile from the profile registry only when required.  Since:  2.0  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
600,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/equinox/p2/query/IQueryResult.html,T> extends IQueryable<T>_ Iterable<T> An IQueryResult represents the results of a query.  Since:  2.0    
601,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/equinox/p2/metadata/IVersionedId.html,An interface representing a (id_version) pair.  Since:  2.0    
602,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/equinox/p2/metadata/IInstallableUnit.html,"An interface representing a (id_version) pair.  Since:  2.0    
extends IVersionedId_ Comparable<IInstallableUnit> An installable unit represents an atomic_ indivisible unit of installable functionality  in a provisioned system. Everything that can be installed or uninstalled in a system_   including both concrete artifacts and instructions describing steps to be performed  during install_ must be expressed as one or more installable units. Thus the set of  installable units present in a system_ together with the existing environment   (operating system_ etc)_ completely describes the initial installed state of that system.    Installable units may have dependencies on functionality provided by other installable  units_ such that the unit cannot be installed unless some other installable unit  is present in the installed system that provides a matching capability. Such   dependencies are referred to as required capabilities. Conversely_  installable units may declared provided capabilities_ describing the  capabilities that they make available to other units in the system. Note the  weak coupling at work here: installable units never directly depend on each other_  but instead depend on abstract capabilities that any other installable unit may provide.      Instances of this class are handle objects and do not necessarily  reflect entities that exist in any particular profile or repository. These handle   objects can be created using MetadataFactory.    Since:  2.0  See Also:  MetadataFactory.createInstallableUnit(org.eclipse.equinox.p2.metadata.MetadataFactory.InstallableUnitDescription)  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
603,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/service/resolver/PlatformAdmin.html,Framework service which allows bundle programmers to inspect the bundles and  packages known to the Framework. The PlatformAdmin service also allows bundles  with sufficient privileges to update the state of the framework by committing a new  configuration of bundles and packages.  If present_ there will only be a single instance of this service  registered with the Framework.    This interface is not intended to be implemented by clients.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.    
604,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/service/resolver/State.html,The state of a system as reported by a resolver. This includes all bundles  presented to the resolver relative to this state (i.e._ both resolved and  unresolved).    This interface is not intended to be implemented by clients. The  StateObjectFactory should be used to construct instances.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.    
605,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/service/resolver/BaseDescription.html,This class represents a base description object for a state. All description  objects in a state have a name and a version.    This interface is not intended to be implemented by clients. The  StateObjectFactory should be used to construct instances.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.    
606,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/service/resolver/BundleDescription.html,"This class represents a base description object for a state. All description  objects in a state have a name and a version.    This interface is not intended to be implemented by clients. The  StateObjectFactory should be used to construct instances.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.    
extends BaseDescription_ BundleRevision This class represents a specific version of a bundle in the system.    This interface is not intended to be implemented by clients. The  StateObjectFactory should be used to construct instances.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.    "
607,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/PreferenceLinkArea.html,extends Object The PreferenceLinkArea is the link area used to open a specific preference  page.  Since:  3.1    
608,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/layout/TreeColumnLayout.html,extends AbstractColumnLayout The TreeColumnLayout is the Layout used to maintain TreeColumn sizes in a   Tree.      You can only add the Layout to a container whose only  child is the Tree control you want the Layout applied to.  Don't assign the layout directly the Tree    Since:  3.3    
609,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/OpenFileAction.html,"An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
A listener which is notified when a viewer's selection changes.  See Also:  ISelection_  ISelectionProvider_  SelectionChangedEvent    
extends OpenSystemEditorAction Standard action for opening an editor on the currently selected file   resource(s).    Note that there is a different action for opening closed projects:  OpenResourceAction.      This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    "
610,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/OpenWithMenu.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
extends ContributionItem A menu for opening files in the workbench.    An OpenWithMenu is used to populate a menu with  ""Open With"" actions. One action is added for each editor which is applicable  to the selected file. If the user selects one of these items_ the corresponding  editor is opened on the file.      This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    "
611,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TableViewerColumn.html,extends ViewerColumn ViewerColumn implementation for TableViewer to enable column-specific label  providers and editing support.  Since:  3.3    
612,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/layout/TableColumnLayout.html,extends AbstractColumnLayout The TableColumnLayout is the Layout used to maintain  TableColumn sizes in a Table.      You can only add the Layout to a container whose only child  is the Table control you want the Layout applied to. Don't  assign the layout directly the Table    Since:  3.3    
613,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TabItem.html,extends Item Instances of this class represent a selectable user interface object  corresponding to a tab for a page in a tab folder.  Styles:  (none)  Events:  (none)    IMPORTANT: This class is not intended to be subclassed.    See Also:  TabFolder_ TabItem snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
614,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/progress/IProgressService.html,"Interface for UI components which can execute a long-running operation  in the form of an IRunnableWithProgress.  The context is responsible for displaying a progress indicator and Cancel  button to the end user while the operation is in progress; the context  supplies a progress monitor to be used from code running inside the operation.  Note that an IRunnableContext is not a runnable itself.    For examples of UI components which implement this interface_  see ApplicationWindow_ ProgressMonitorDialog_  and WizardDialog.    See Also:  IRunnableWithProgress_  ApplicationWindow_  ProgressMonitorDialog_  WizardDialog    
extends IRunnableContext The progress service is the primary interface to the workbench progress  support. It can be obtained from the workbench and then used to show progress  for both background operations and operations that run in the UI thread.    All methods on the progress service must be called from the UI thread.      This service can be acquired from your service locator:    IProgressService service = (IProgressService) getSite().getService(IProgressService.class);    This service is available globally.      NOTE The progress service must be referenced at least once  before it will become the progress provider for the IJobManager in  the workbench. This connection is done lazily so that RCP applications will  not have to use the IProgressService as the ProgressProvider  to the jobs framework if they do not wish to reference it.    Since:  3.0  See Also:  IWorkbench.getProgressService()_  IJobManager.setProgressProvider(org.eclipse.core.runtime.jobs.ProgressProvider)_  IServiceLocator.getService(Class)  Restriction:  This interface is not intended to be implemented by clients.    "
615,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TableEditor.html,"extends ControlEditor A TableEditor is a manager for a Control that appears above a cell in a Table and tracks with the  moving and resizing of that cell. It can be used to display a text widget above a cell  in a Table so that the user can edit the contents of that cell. It can also be used to display  a button that can launch a dialog for modifying the contents of the associated cell.  Here is an example of using a TableEditor:    final Table table = new Table(shell_ SWT.FULL_SELECTION | SWT.HIDE_SELECTION);  TableColumn column1 = new TableColumn(table_ SWT.NONE);  TableColumn column2 = new TableColumn(table_ SWT.NONE);  for (int i = 0; i < 10; i++) {  TableItem item = new TableItem(table_ SWT.NONE);  item.setText(new String[] {""item "" + i_ ""edit this value""});  }  column1.pack();  column2.pack();    final TableEditor editor = new TableEditor(table);  //The editor must have the same size as the cell and must  //not be any smaller than 50 pixels.  editor.horizontalAlignment = SWT.LEFT;  editor.grabHorizontal = true;  editor.minimumWidth = 50;  // editing the second column  final int EDITABLECOLUMN = 1;    table.addSelectionListener(new SelectionAdapter() {  public void widgetSelected(SelectionEvent e) {  // Clean up any previous editor control  Control oldEditor = editor.getEditor();  if (oldEditor != null) oldEditor.dispose();    // Identify the selected row  TableItem item = (TableItem)e.item;  if (item == null) return;    // The control that will be the editor must be a child of the Table  Text newEditor = new Text(table_ SWT.NONE);  newEditor.setText(item.getText(EDITABLECOLUMN));  newEditor.addModifyListener(new ModifyListener() {  public void modifyText(ModifyEvent e) {  Text text = (Text)editor.getEditor();  editor.getItem().setText(EDITABLECOLUMN_ text.getText());  }  });  newEditor.selectAll();  newEditor.setFocus();  editor.setEditor(newEditor_ item_ EDITABLECOLUMN);  }  });    See Also:  TableEditor snippets_  Sample code and further information    "
616,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/filesystem/IFileSystem.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable This is the main interface to a single file system. Each file system instance  manages interaction with all files in the backing store represented by a   particular URI scheme.    File systems are registered using the ""filesystems"" extension point.    Since:  org.eclipse.core.filesystem 1.0  See Also:  EFS.getFileSystem(String)  Restriction:  This interface is not intended to be implemented by clients. File system  implementations must subclass FileSystem rather than implementing  this interface directly.    "
617,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeExpansionEvent.html,extends EventObject Event object describing a tree node being expanded  or collapsed. The source of these events is the tree viewer.  See Also:  ITreeViewerListener_  Serialized Form    
618,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/IEditorAssociationOverride.html,Allows to override editor associations for the IDE.    This interface is implemented by org.eclipse.ui.ide.editorAssociationOverride  extensions.      Clients may implement this interface.    Since:  3.8    
619,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/fileSystem/FileSystemContributor.html,extends Object The abstract base class for all UI file system contributors. This class  provides the infrastructure for defining a contributor and fulfills the contract  specified by the org.eclipse.ui.ide.filesystemSupport   extension point.  Since:  3.2  See Also:  IFileSystem    
620,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/dynamichelpers/IExtensionTracker.html,An extension tracker keeps associations between extensions and their derived objects on an extension basis.  All extensions being added in a tracker will automatically be removed when the extension is uninstalled from the registry.  Users interested in extension removal can register a handler that will let them know when an object is being removed.    This interface can be used without OSGi running.    This interface is not intended to be implemented by clients.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.    
621,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/ILog.html,A log to which status events can be written. Logs appear on individual  plug-ins and on the platform itself. Clients can register log listeners which  will receive notification of all log events as they come in.    XXX Need to create a new log interface on common plugin. That interface should be a super interface of this ILog.  getBundle() would stay here. In the super interface we would have getName()    Restriction:  This interface is not intended to be implemented by clients.    
622,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IViewPart.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ IPersistable A view is a visual component within a workbench page. It is typically used to  navigate a hierarchy of information (like the workspace)_ open an editor_ or  display properties for the active editor. Modifications made in a view are  saved immediately (in contrast to an editor part_ which conforms to a more  elaborate open-save-close lifecycle).    Only one instance of a particular view type may exist within a workbench  page. This policy is designed to simplify part management for a user.      This interface may be implemented directly. For convenience_ a base  implementation is defined in ViewPart.      A view is added to the workbench in two steps:    A view extension is contributed to the workbench registry. This  extension defines the extension id and extension class.  The view is included in the default layout for a perspective.  Alternatively_ the user may open the view from the Perspective menu.      Views implement the IAdaptable interface; extensions are  managed by the platform's adapter manager.      As of 3.4_ views may optionally adapt to ISizeProvider if they have  a preferred size. The default presentation will make a best effort to  allocate the preferred size to a view if it is the only part in a stack. If  there is more than one part in the stack_ the constraints will be disabled  for that stack. The size constraints are adjusted for the size of the tab and  border trim. Note that this is considered to be a hint to the presentation_  and not all presentations may honor size constraints.    See Also:  IWorkbenchPage.showView(java.lang.String)_  ViewPart_  ISizeProvider    "
623,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IRegistryChangeEvent.html,Registry change events describe changes to the extension registry.     This interface can be used without OSGi running.    This interface is not intended to be implemented by clients.    Since:  3.0  See Also:  IExtensionRegistry_  IRegistryChangeListener  Restriction:  This interface is not intended to be implemented by clients.    
624,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceChangeListener.html,extends EventListener A resource change listener is notified of changes to resources  in the workspace.   These changes arise from direct manipulation of resources_ or   indirectly through re-synchronization with the local file system.    Clients may implement this interface.    See Also:  IResourceDelta_  IWorkspace.addResourceChangeListener(IResourceChangeListener_ int)    
625,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IWorkbenchActivitySupport.html,An instance of this interface provides support for managing   IWorkbench activities. An instance of this interface may be  obtained via IWorkbench.getActivitySupport().     This interface is not intended to be extended or implemented by clients.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    
626,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPluginContribution.html,An interface that descriptor classes may implement in addition to their  descriptor interface. This indicates that they may or may not originate from  a plugin contribution. This is useful in various activity filtering  scenarios.  Since:  3.0    
627,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ITriggerPoint.html,A trigger point represents a place within the Workbench that has the  potential to enable activities. Instances of this class may be obtained from  ITriggerPointManager.getTriggerPoint(String).  Instances of this interface are passed as a parameter to  ITriggerPointAdvisor.allow(ITriggerPoint_ IIdentifier)  and may be used by the advisor to determine policy.    This interface is not intended to be extended or implemented by clients.    Since:  3.1  See Also:  ITriggerPointAdvisor_  ITriggerPointManager  Restriction:  This interface is not intended to be implemented by clients.    
628,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/IWorkbenchConfigurer.html,Interface providing special access for configuring the workbench.    Note that these objects are only available to the main application  (the plug-in that creates and owns the workbench).      This interface is not intended to be implemented by clients.    Since:  3.0  See Also:  WorkbenchAdvisor.initialize(org.eclipse.ui.application.IWorkbenchConfigurer)  Restriction:  This interface is not intended to be implemented by clients.    
629,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/statushandlers/StatusAdapter.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends Object implements IAdaptable  The StatusAdapter wraps an instance of IStatus subclass and can hold  additional information either by using properties or by adding a new adapter. Used during  status handling process.    Since:  3.3    "
630,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/progress/UIJob.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends Job The UIJob is a Job that runs within the UI Thread via an asyncExec.  Since:  3.0    "
631,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/DrillDownComposite.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Class DrillDownComposite implements a simple web  style navigation metaphor. Home_ back_ and ""drill into"" buttons are  added to a tree viewer for easier navigation.    To use the DrillDownComposite..    Create an instance of DrillDownComposite.  Create a tree viewer.   Pass the second tree viewer into the composite by   calling setChildTree.    "
632,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/QualifiedName.html,extends Object Qualified names are two-part names: qualifier and local name.  The qualifier must be in URI form (see RFC2396).   Note however that the qualifier may be null if  the default name space is being used. The empty string is not   a valid local name.    This class can be used without OSGi running.    This class is not intended to be subclassed by clients.      
633,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/IContributorResourceAdapter2.html,"The IContributorResourceAdapter is an interface that defines  the API required to get a resource that an object adapts to  for use of object contributions_ decorators and property  pages that have adaptable = true.  Implementors of this interface are typically registered with an  IAdapterFactory for lookup via the getAdapter() mechanism.    
extends IContributorResourceAdapter An extension to the IContributorResourceAdapter that adapts   a model object to a ResourceMapping.  Since:  3.2    "
634,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/ResourceMappingContext.html,extends Object A resource mapping context is provided to a resource mapping when traversing  the resources of the mapping. The type of context may determine what resources  are included in the traversals of a mapping.    There are currently two resource mapping contexts: the local mapping context  (represented by the singleton LOCAL_CONTEXT)_  and RemoteResourceMappingContext. Implementors of ResourceMapping  should not assume that these are the only valid contexts (in order to allow future   extensibility). Therefore_ if the provided context is not of one of the above mentioned types_  the implementor can assume that the context is a local context.      This class may be subclassed by clients; this class is not intended to be   instantiated directly.    Since:  3.2  See Also:  ResourceMapping_  RemoteResourceMappingContext    
635,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IMarkerResolutionGenerator.html,Creates resolutions for a given marker.   When run_ a resolution would typically eliminate   the need for the marker.  Since:  2.0    
636,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IFileState.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IStorage A storage that knows how its contents are encoded.    The IEncodedStorage interface extends IStorage  in order to provide access to the charset to be used when decoding its   contents.     Clients may implement this interface.    Since:  3.0    
extends IAdaptable A storage object represents a set of bytes which can be accessed.  These may be in the form of an IFile or IFileState  or any other object supplied by user code. The main role of an IStorage  is to provide a uniform API for access to_ and presentation of_ its content.    Storage objects implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    Clients may implement this interface.        
extends IEncodedStorage_ IAdaptable A previous state of a file stored in the workspace's local history.     Certain methods for updating_ deleting_ or moving a file cause the  ""before"" contents of the file to be copied to an internal area of the  workspace called the local history area thus providing   a limited history of earlier states of a file.      Moving or copying a file will cause a copy of its local history to appear  at the new location as well as at the original location. Subsequent  changes to either file will only affect the local history of the file  changed. Deleting a file and creating another one at the  same path does not affect the history. If the original file had  history_ that same history will be available for the new one.      The local history does not track resource properties.  File states are volatile; the platform does not guarantee that a   certain state will always be in the local history.      File state objects implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IFile_  IStorage_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
637,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IOperationHistoryListener.html, This interface is used to listen to notifications from an IOperationHistory.  The supplied OperationHistoryEvent describes the particular notification.      Operation history listeners must be prepared to receive notifications from a  background thread. Any UI access occurring inside the implementation must be  properly synchronized using the techniques specified by the client's widget  library.    Since:  3.1    
638,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IOperationHistory.html, IOperationHistory tracks a history of operations that can be undone or  redone. Operations are added to the history once they have been initially  executed. Clients may choose whether to have the operations history perform  the initial execution or to simply add an already-executed operation to the  history.      Once operations are added to the history_ the methods  canRedo(IUndoContext) and canUndo(IUndoContext) are used to  determine whether there is an operation available for undo and redo in a  given undo context. The context-based protocol implies that there is only one  operation that can be undone or redone at a given time in a given context.  This is typical of a linear undo model_ when only the most recently executed  operation is available for undo. When this protocol is used_ a linear model  is enforced by the history.      It is up to clients to determine how to maintain a history that is invalid or  stale. For example_ when the most recent operation for a context cannot be  performed_ clients may wish to dispose the history for that context.      Additional protocol allows direct undo and redo of a specified operation_  regardless of its position in the history. When a more flexible undo model is  supported_ these methods can be implemented to undo and redo directly  specified operations. If an implementer of IOperationHistory does not allow  direct undo and redo_ these methods can return a status indicating that it is  not allowed.      Listeners (IOperationHistoryListener) can listen for notifications  about changes in the history (operations added or removed)_ and for  notification before and after any operation is executed_ undone or redone.  Notification of operation execution only occurs when clients direct the  history to execute the operation. If the operation is added after it is  executed_ there can be no notification of its execution.      IOperationApprover defines an interface for approving an undo or redo  before it occurs. This is useful for injecting policy-decisions into the undo  model - whether direct undo and redo are supported_ or warning the user about  certain kinds of operations. It can also be used when clients maintain state  related to an operation and need to determine whether an undo or redo will  cause any conflicts with their local state.    Since:  3.1    
639,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/IMenuService.html," The interface that should be implemented by services that make themselves  available through the IAdaptable mechanism. This is the  interface that drives the majority of services provided at the workbench  level.      A service has life-cycle. When the constructor completes_ the service must be  fully functional. When it comes time for the service to go away_ then the  service will receive a dispose() call. At this point_ the service  must release all resources and detach all listeners. A service can only be  disposed once; it cannot be reused.      This interface has nothing to do with OSGi services.      This interface can be extended or implemented by clients.    Since:  3.2    
extends IDisposable  A service that responds to changes in one or more sources. These sources can  be plugged into the service. Sources represent a common event framework for  services.      Clients must not extend or implement.    Since:  3.2    
extends IServiceWithSources  Provides services related to the menu architecture within the workbench. It  can be used to contribute additional items to the menu_ tool bar and status  line.      This service can be acquired from your service locator:    IMenuService service = (IMenuService) getSite().getService(IMenuService.class);    This service is available globally.    Since:  3.3  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
640,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ActionContributionItem.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
extends ContributionItem A contribution item which delegates to an action.    This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    "
641,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/Separator.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
extends AbstractGroupMarker A separator is a special kind of contribution item which acts  as a visual separator and_ optionally_ acts as a group marker.  Unlike group markers_ separators do have a visual representation for  menus and toolbars.    This class may be instantiated; it is not intended to be   subclassed outside the framework.    Restriction:  This class is not intended to be subclassed by clients.    "
642,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/CommandContributionItemParameter.html,extends Object A help class for the various parameters that can be used with command  contributions. Mandatory parameters are in the constructor_ and public fields  can be set to fill in other parameters.  Since:  3.4    
643,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/MarkerFieldFilter.html,extends Object A MarkerFieldFilter is a filter on a particular marker field.  Since:  3.4    
644,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/MarkerItem.html,extends Object The MarkerItem class is the class that represents the objects displayed a   MarkerSupportView. This class is not intended to be sub-classed by clients_  Since:  3.4    
645,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/ObjectUndoContext.html," An undo context is used to ""tag"" operations as being applicable to a certain  context. The undo context is used to filter the history of operations  available for undo or redo so that only operations appropriate for a given  undo context are shown when the application is presenting that context.      The scope of an undo context is defined by the application that is making  undo and redo of operations available. Undo contexts may be related to  application models_ or may be associated with UI objects that are providing  undo and redo support.      An undo context may be defined as ""matching"" another context. This allows  applications to provide specialized implementations of an undo context that  will appear in the operation history for their matching context.  Since:  3.1    
extends UndoContext  An undo context that can be used to represent any given object. Clients  can add matching contexts to this context. This class may be instantiated  by clients.    Since:  3.1    "
646,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/MarkerField.html,extends Object MarkerField is the abstract superclass of the definition of the content  providers for columns in a Markers View.  Since:  3.4    
647,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/progress/IWorkbenchSiteProgressService.html,"Interface for UI components which can execute a long-running operation  in the form of an IRunnableWithProgress.  The context is responsible for displaying a progress indicator and Cancel  button to the end user while the operation is in progress; the context  supplies a progress monitor to be used from code running inside the operation.  Note that an IRunnableContext is not a runnable itself.    For examples of UI components which implement this interface_  see ApplicationWindow_ ProgressMonitorDialog_  and WizardDialog.    See Also:  IRunnableWithProgress_  ApplicationWindow_  ProgressMonitorDialog_  WizardDialog    
extends IRunnableContext The progress service is the primary interface to the workbench progress  support. It can be obtained from the workbench and then used to show progress  for both background operations and operations that run in the UI thread.    All methods on the progress service must be called from the UI thread.      This service can be acquired from your service locator:    IProgressService service = (IProgressService) getSite().getService(IProgressService.class);    This service is available globally.      NOTE The progress service must be referenced at least once  before it will become the progress provider for the IJobManager in  the workbench. This connection is done lazily so that RCP applications will  not have to use the IProgressService as the ProgressProvider  to the jobs framework if they do not wish to reference it.    Since:  3.0  See Also:  IWorkbench.getProgressService()_  IJobManager.setProgressProvider(org.eclipse.core.runtime.jobs.ProgressProvider)_  IServiceLocator.getService(Class)  Restriction:  This interface is not intended to be implemented by clients.    
Interface for UI components which can execute a long-running operation  in the form of an IRunnableWithProgress.  The context is responsible for displaying a progress indicator and Cancel  button to the end user while the operation is in progress; the context  supplies a progress monitor to be used from code running inside the operation.  Note that an IRunnableContext is not a runnable itself.    For examples of UI components which implement this interface_  see ApplicationWindow_ ProgressMonitorDialog_  and WizardDialog.    See Also:  IRunnableWithProgress_  ApplicationWindow_  ProgressMonitorDialog_  WizardDialog    
extends IProgressService IWorkbenchPartProgressService is an IProgressService that adds API for jobs  that change the state in a IWorkbenchPartSite while they are being run.    This service can be acquired from your service locator (IWorkbenchPartSite):        IWorkbenchSiteProgressService service = (IWorkbenchSiteProgressService) getSite().getService(IWorkbenchSiteProgressService.class);        This service is not available globally_ only at the part site level.      WorkbenchParts may access an instance of IWorkbenchSiteProgressService by  calling  getSite().getAdapter(IWorkbenchSiteProgressService.class); _  although getSite().getService(IWorkbenchSiteProgressService.class) is  preferred.    Since:  3.0  See Also:  IAdaptable.getAdapter(Class)_  IServiceLocator.getService(Class)  Restriction:  This interface is not intended to be implemented by clients.    "
648,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExecutableExtension.html,Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
649,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPart2.html,extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
650,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPart3.html,extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
651,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IWorkbenchPartOrientation.html,The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
652,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/MarkerSupportView.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ IPersistable A view is a visual component within a workbench page. It is typically used to  navigate a hierarchy of information (like the workspace)_ open an editor_ or  display properties for the active editor. Modifications made in a view are  saved immediately (in contrast to an editor part_ which conforms to a more  elaborate open-save-close lifecycle).    Only one instance of a particular view type may exist within a workbench  page. This policy is designed to simplify part management for a user.      This interface may be implemented directly. For convenience_ a base  implementation is defined in ViewPart.      A view is added to the workbench in two steps:    A view extension is contributed to the workbench registry. This  extension defines the extension id and extension class.  The view is included in the default layout for a perspective.  Alternatively_ the user may open the view from the Perspective menu.      Views implement the IAdaptable interface; extensions are  managed by the platform's adapter manager.      As of 3.4_ views may optionally adapt to ISizeProvider if they have  a preferred size. The default presentation will make a best effort to  allocate the preferred size to a view if it is the only part in a stack. If  there is more than one part in the stack_ the constraints will be disabled  for that stack. The size constraints are adjusted for the size of the tab and  border trim. Note that this is considered to be a hint to the presentation_  and not all presentations may honor size constraints.    See Also:  IWorkbenchPage.showView(java.lang.String)_  ViewPart_  ISizeProvider    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
extends org.eclipse.ui.internal.views.markers.ExtendedMarkersView The MarkerSupportView is a view that supports the extensions  in the markerSupport extension point.  Since:  3.4    "
653,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IMarkerDelta.html,A marker delta describes the change to a single marker.  A marker can either be added_ removed or changed.  Marker deltas give access to the state of the marker as it  was (in the case of deletions and changes) before the modifying  operation occurred.  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
654,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeViewerColumn.html,extends ViewerColumn ViewerColumn implementation for TreeViewer to enable column-specific label  providers and editing support.  Since:  3.3    
655,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/help/IContext.html,"A context registered for context-sensitive help.    This interface models the context-sensitive help that can be associated with  SWT menus_ menu items_ and controls_ and with JFace actions. A help context  provides the text description of the object with which it is associated with_  as well as topic links that contain more related information. This  information would be displayed to the user when context sensitive help (F1)  is requested.      In the current implementation of the Help system_ valid contexts can be  contributed through the contexts element of the  ""org.eclipse.help.contexts"" extension point. The  IHelp.findContext(String) method is used at runtime to create  or fetch IContext objects using there fully qualified contextIds. If there is  a need to override this behavior_ then this IContext interface could be  implemented by a client and registered with the SWT control or JFace action.      "
656,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPartListener2.html,Interface for listening to part lifecycle events.    This is a replacement for IPartListener.    As of 3.5_ if the implementation of this listener also implements  IPageChangedListener then it will also be notified about  PageChangedEvents from parts that implement  IPageChangeProvider.      This interface may be implemented by clients.    See Also:  IPartService.addPartListener(IPartListener2)    
657,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IViewSite.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
 A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends IWorkbenchSite The primary interface between a workbench part and the workbench.    This interface is not intended to be implemented or extended by clients.    Restriction:  This interface is not intended to be implemented by clients.    
extends IAdaptable_ IShellProvider_ IServiceLocator The common interface between the workbench and its parts_ including pages  within parts.    The workbench site supports a few services by  default. If these services are used to allocate resources_ it is important to  remember to clean up those resources after you are done with them. Otherwise_  the resources will exist until the workbench site is disposed. The supported  services are:    ICommandService  IContextService  IHandlerService  IBindingService. Resources allocated through this service will  not be cleaned up until the workbench shuts down.    This interface is not intended to be implemented or extended by clients.    Since:  2.0  See Also:  IWorkbenchPartSite_  IPageSite  Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkbenchPartSite The primary interface between a view part and the workbench.    The workbench exposes its implemention of view part sites via this interface_  which is not intended to be implemented or extended by clients.    Restriction:  This interface is not intended to be implemented by clients.    "
658,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/FilterConfigurationArea.html,extends Object FilterConfigurationArea is the area that the user can configure a filter in.  Since:  3.4    
659,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/FiltersContributionParameters.html,extends Object A MarkerFieldParameters is a class that specifies a Map of parameters  to be passed to a MarkerFieldFilter.  Since:  3.4    
660,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITableLabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider Extends IBaseLabelProvider with the methods  to provide the text and/or image for each column of a given element.   Used by table viewers.  See Also:  TableViewer    "
661,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/Wizard.html,"Interface for a wizard. A wizard maintains a list of wizard pages_  stacked on top of each other in card layout fashion.    The class Wizard provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if Wizard does not suit their needs.    See Also:  Wizard    
extends Object implements IWizard An abstract base implementation of a wizard. A typical client subclasses  Wizard to implement a particular wizard.    Subclasses may call the following methods to configure the wizard:    addPage  setHelpAvailable  setDefaultPageImageDescriptor  setDialogSettings  setNeedsProgressMonitor  setTitleBarColor  setWindowTitle      Subclasses may override these methods if required:    reimplement createPageControls  reimplement performCancel  extend addPages  reimplement performFinish  extend dispose      Note that clients are free to implement IWizard from scratch  instead of subclassing Wizard. Correct implementations of  IWizard will work with any correct implementation of  IWizardPage.      "
662,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IMarkerResolution.html,Resolution for a marker. When run_ a resolution would   typically eliminate the need for the marker.  Since:  2.0    
663,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/FileSystemElement.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends Object implements IAdaptable Instances of this class represent files or file-like entities (eg.- zip file  entries) on the local file system. They do not represent resources within the  workbench. This distinction is made because the representation of a file  system resource is significantly different from that of a workbench resource.    If self represents a collection (eg.- file system directory_ zip directory)  then its icon will be the folderIcon static field. Otherwise (ie.- self  represents a file system file) self's icon is stored in field ""icon""_ and is  determined by the extension of the file that self represents.    This class is adaptable_ and implements one adapter itself_ namely the  IWorkbenchAdapter adapter used for navigation and display in the workbench.    "
664,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/IWorkbenchAdapter.html,This adapter interface provides visual presentation and hierarchical structure  for workbench elements_ allowing them to be displayed in the UI  without having to know the concrete type of the element.    There is an associate label provider and content provider for showing  elements with a registered workbench adapter in JFace structured viewers.    See Also:  WorkbenchLabelProvider_  BaseWorkbenchContentProvider    
665,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/IWorkbenchAdapter2.html,Extension interface for IWorkbenchAdapter that allows for color   and font support.    There is an associate label provider and content provider for showing  elements with a registered workbench adapter in JFace structured viewers.    Since:  3.0  See Also:  IWorkbenchAdapter_  WorkbenchLabelProvider_  BaseWorkbenchContentProvider    
666,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/IWorkbenchAdapter3.html,Extension interface for IWorkbenchAdapter that allows for  StyledString support.  Since:  3.7  See Also:  IWorkbenchAdapter_  WorkbenchLabelProvider_  BaseWorkbenchContentProvider_  DelegatingStyledCellLabelProvider.IStyledLabelProvider    
667,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/AdaptableList.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
This adapter interface provides visual presentation and hierarchical structure  for workbench elements_ allowing them to be displayed in the UI  without having to know the concrete type of the element.    There is an associate label provider and content provider for showing  elements with a registered workbench adapter in JFace structured viewers.    See Also:  WorkbenchLabelProvider_  BaseWorkbenchContentProvider    
Extension interface for IWorkbenchAdapter that allows for color   and font support.    There is an associate label provider and content provider for showing  elements with a registered workbench adapter in JFace structured viewers.    Since:  3.0  See Also:  IWorkbenchAdapter_  WorkbenchLabelProvider_  BaseWorkbenchContentProvider    
Extension interface for IWorkbenchAdapter that allows for  StyledString support.  Since:  3.7  See Also:  IWorkbenchAdapter_  WorkbenchLabelProvider_  BaseWorkbenchContentProvider_  DelegatingStyledCellLabelProvider.IStyledLabelProvider    
extends WorkbenchAdapter implements IAdaptable A modifiable list of IAdaptable objects.  The list is adaptable to IWorkbenchAdapter_ and can be used to  display an arbitrary set of adaptable objects in a viewer.    This class is not intended to be subclassed.    Since:  3.0  See Also:  IWorkbenchAdapter  Restriction:  This class is not intended to be subclassed by clients.    "
668,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/datatransfer/IImportStructureProvider.html,Interface which can provide structure and content information   for an element (for example_ a file system element).  Used by the import wizards to abstract the commonalities  between importing from the file system and importing from an archive.    
669,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/OpenEvent.html,extends EventObject Event object describing an open which may be generated from a   selection or default selection event. The source of these  events is a viewer.  See Also:  IOpenListener_  Serialized Form    
670,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/plugin/AbstractUIPlugin.html,"extends Plugin Abstract base class for plug-ins that integrate with the Eclipse platform UI.    Subclasses obtain the following capabilities:      Preferences    The platform core runtime contains general support for plug-in  preferences (org.eclipse.core.runtime.Preferences).   This class provides appropriate conversion to the older JFace preference   API (org.eclipse.jface.preference.IPreferenceStore).  The method getPreferenceStore returns the JFace preference  store (cf. Plugin.getPluginPreferences which returns  a core runtime preferences object.  Subclasses may reimplement initializeDefaultPreferences  to set up any default values for preferences using JFace API. In this  case_ initializeDefaultPluginPreferences should not be  overridden.  Subclasses may reimplement  initializeDefaultPluginPreferences to set up any default  values for preferences using core runtime API. In this  case_ initializeDefaultPreferences should not be  overridden.  Preferences are also saved automatically on plug-in shutdown.  However_ saving preferences immediately after changing them is  strongly recommended_ since that ensures that preference settings  are not lost even in the event of a platform crash.  Dialogs  The dialog store is read the first time getDialogSettings   is called.  The dialog store allows the plug-in to ""record"" important choices made  by the user in a wizard or dialog_ so that the next time the  wizard/dialog is used the widgets can be defaulted to better values. A  wizard could also use it to record the last 5 values a user entered into  an editable combo - to show ""recent values"".   The dialog store is found in the file whose name is given by the  constant FN_DIALOG_STORE. A dialog store file is first  looked for in the plug-in's read/write state area; if not found there_  the plug-in's install directory is checked.  This allows a plug-in to ship with a read-only copy of a dialog store  file containing initial values for certain settings.  Plug-in code can call saveDialogSettings to cause settings to  be saved in the plug-in's read/write state area. A plug-in may opt to do  this each time a wizard or dialog is closed to ensure the latest   information is always safe on disk.   Dialog settings are also saved automatically on plug-in shutdown.  Images  A typical UI plug-in will have some images that are used very frequently  and so need to be cached and shared. The plug-in's image registry   provides a central place for a plug-in to store its common images.   Images managed by the registry are created lazily as needed_ and will be  automatically disposed of when the plug-in shuts down. Note that the  number of registry images should be kept to a minimum since many OSs  have severe limits on the number of images that can be in memory at once.      For easy access to your plug-in object_ use the singleton pattern. Declare a  static variable in your plug-in class for the singleton. Store the first  (and only) instance of the plug-in class in the singleton when it is created.  Then access the singleton when needed through a static getDefault  method.      See the description on Plugin.      "
671,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MarkerTransfer.html,extends ByteArrayTransfer A MarkerTransfer is used to transfer an array of   IMarkers from one part to another in a drag and drop   operation.    In every drag and drop operation there is a DragSource and   a DropTarget. When a drag occurs a Transfer is   used to marshall the drag data from the source into a byte array. If a drop   occurs another Transfer is used to marshall the byte array into  drop data for the target.    This class can be used for a Viewer or an SWT component directly.  A singleton is provided which may be serially reused (see getInstance).   It is not intended to be subclassed.    See Also:  StructuredViewer_  DropTarget_  DragSource  Restriction:  This class is not intended to be subclassed by clients.    
672,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IElementFactory.html,"A factory for re-creating objects from a previously saved memento.    Clients should implement this interface and include the name of their class  in an extension to the platform extension point named  ""org.eclipse.ui.elementFactories"".  For example_ the plug-in's XML markup might contain:    <extension point=""org.eclipse.ui.elementFactories"">  <factory id=""com.example.myplugin.MyFactory"" class=""com.example.myplugin.MyFactory"" />   </extension>      See Also:  IPersistableElement_  IMemento_  IWorkbench.getElementFactory(java.lang.String)    "
673,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/DeleteMarkersOperation.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractWorkspaceOperation A DeleteMarkersOperation represents an undoable operation for deleting one or  more markers in the workspace. Clients may call the public API from a  background thread.    This class is intended to be instantiated and used by clients. It is not  intended to be subclassed by clients.  Since:  3.3    "
674,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/Dialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends Window A dialog is a specialized window used for narrow-focused communication with  the user.    Dialogs are usually modal. Consequently_ it is generally bad practice to open  a dialog without a parent. A modal dialog without a parent is not prevented  from disappearing behind the application's other windows_ making it very  confusing for the user.      If more than one modal dialog is open_ the second one should be  parented off of the shell of the first one. Otherwise_ it is possible that the  OS will give focus to the first dialog_ potentially blocking the UI.      This class also moves the default button to the right if required_ see  initializeBounds().      "
675,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/tasklist/ITaskListResourceAdapter.html,ITaskListResourceAdapter is an adapter interface that  supplies the resource to query for markers to display in the task list.    The Tasks view checks for this adapter before the IResource  adapter_ allowing the object to provide a resource to the Tasks view without  necessarily exposing it to other components that look for an IResource  adapter.       Implementors of this interface are typically registered with an  IAdapterFactory for lookup via the getAdapter() mechanism.      
676,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IProgressMonitorWithBlocking.html,extends IProgressMonitor An extension to the IProgressMonitor interface for monitors that want to  support feedback when an activity is blocked due to concurrent activity in  another thread.    When a monitor that supports this extension is passed to an operation_ the  operation should call setBlocked whenever it knows that it  must wait for a lock that is currently held by another thread. The operation  should continue to check for and respond to cancelation requests while  blocked. When the operation is no longer blocked_ it must call clearBlocked  to clear the blocked state.    This interface can be used without OSGi running.    Clients may implement this interface.    Since:  3.0  See Also:  IProgressMonitor    
677,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/SubProgressMonitor.html,"The IProgressMonitor interface is implemented  by objects that monitor the progress of an activity; the methods  in this interface are invoked by code that performs the activity.    All activity is broken down into a linear sequence of tasks against  which progress is reported. When a task begins_ a beginTask(String_ int)  notification is reported_ followed by any number and mixture of   progress reports (worked()) and subtask notifications   (subTask(String)). When the task is eventually completed_ a   done() notification is reported. After the done()  notification_ the progress monitor cannot be reused; i.e._   beginTask(String_ int) cannot be called again after the call to   done().      A request to cancel an operation can be signaled using the   setCanceled method. Operations taking a progress  monitor are expected to poll the monitor (using isCanceled)  periodically and abort at their earliest convenience. Operation can however   choose to ignore cancelation requests.      Since notification is synchronous with the activity itself_ the listener should   provide a fast and robust implementation. If the handling of notifications would   involve blocking operations_ or operations which might throw uncaught exceptions_   the notifications should be queued_ and the actual processing deferred (or perhaps  delegated to a separate thread).    This interface can be used without OSGi running.    Clients may implement this interface.      
extends IProgressMonitor An extension to the IProgressMonitor interface for monitors that want to  support feedback when an activity is blocked due to concurrent activity in  another thread.    When a monitor that supports this extension is passed to an operation_ the  operation should call setBlocked whenever it knows that it  must wait for a lock that is currently held by another thread. The operation  should continue to check for and respond to cancelation requests while  blocked. When the operation is no longer blocked_ it must call clearBlocked  to clear the blocked state.    This interface can be used without OSGi running.    Clients may implement this interface.    Since:  3.0  See Also:  IProgressMonitor    
extends ProgressMonitorWrapper For new implementations consider using SubMonitor.    A progress monitor that uses a given amount of work ticks  from a parent monitor. It can be used as follows:    try {  pm.beginTask(""Main Task""_ 100);  doSomeWork(pm_ 30);  SubProgressMonitor subMonitor= new SubProgressMonitor(pm_ 40);  try {  subMonitor.beginTask(""""_ 300);  doSomeWork(subMonitor_ 300);  } finally {  subMonitor.done();  }  doSomeWork(pm_ 30);  } finally {  pm.done();  }      This class can be used without OSGi running.    This class may be instantiated or subclassed by clients.    See Also:  SubMonitor    "
678,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IMarkerResolution2.html,extends IMarkerResolution Extends IMarkerResolution. This interface should be used   in place of IMarkerResolution if a description and/or image   are desired.  Since:  3.0    
679,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/WorkbenchMarkerResolution.html,"Resolution for a marker. When run_ a resolution would   typically eliminate the need for the marker.  Since:  2.0    
extends IMarkerResolution Extends IMarkerResolution. This interface should be used   in place of IMarkerResolution if a description and/or image   are desired.  Since:  3.0    
extends Object implements IMarkerResolution2 WorkbenchMarkerResolution is the resolution that can be grouped  with others that are similar to allow multi selection.  Since:  3.2    "
680,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/IJobChangeListener.html,Callback interface for clients interested in being notified when jobs change state.    A single job listener instance can be added either to the job manager_ for notification  of all scheduled jobs_ or to any set of individual jobs. A single listener instance should  not be added to both the job manager_ and to individual jobs (such a listener may  receive duplicate notifications).    Clients should not rely on the result of the Job#getState()   method on jobs for which notification is occurring. Listeners are notified of   all job state changes_ but whether the state change occurs before_ during_ or   after listeners are notified is unspecified.    Clients may implement this interface.    Since:  3.0  See Also:  JobChangeAdapter_  IJobManager.addJobChangeListener(IJobChangeListener)_  IJobManager.removeJobChangeListener(IJobChangeListener)_  Job.addJobChangeListener(IJobChangeListener)_  Job.getState()_  Job.removeJobChangeListener(IJobChangeListener)    
681,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ActivityManagerEvent.html,extends Object An instance of this class describes changes to an instance of   IActivityManager. This class does not give details as to the   specifics of a change_ only that the given property on the source object has   changed.      This class is not intended to be extended by clients.    Since:  3.0  See Also:  IActivityManagerListener.activityManagerChanged(ActivityManagerEvent)    
682,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/preferences/ViewPreferencesAction.html,"An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
extends Action The ViewPreferencesAction is the action for opening  a view preferences dialog on a class.  Since:  3.1    "
683,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/framelist/FrameList.html,extends EventManager Supports a web-browser style of navigation by maintaining a list  of frames. Each frame holds a snapshot of a view at some point   in time.    The frame list obtains a snapshot of the current frame from a frame source  on creation_ and whenever switching to a different frame.      A property change notification is sent whenever the current page changes.      
684,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ActionContext.html,extends Object An ActionContext represents the context used to determine  which actions are added by an ActionGroup_ and what their   enabled state should be.    This class encapsulates a selection and an input element.  Clients may subclass this class to add more information to the context.      
685,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/CopyFilesAndFoldersOperation.html,extends Object Perform the copy of file and folder resources from the clipboard when paste  action is invoked.    This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    
686,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/MoveFilesAndFoldersOperation.html,extends CopyFilesAndFoldersOperation Moves files and folders.    This class may be instantiated; it is not intended to be subclassed.    Since:  2.1  Restriction:  This class is not intended to be subclassed by clients.    
687,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/framelist/TreeFrame.html,extends Frame Frame for tree viewers. This capture the viewer's input element_ selection_  and expanded elements.    
688,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/ResourceTransfer.html,extends ByteArrayTransfer The ResourceTransfer class is used to transfer an  array of IResources from one part to another in a   drag and drop operation or a cut_ copy_ paste action.    In every drag and drop operation there is a DragSource and   a DropTarget. When a drag occurs a Transfer is   used to marshal the drag data from the source into a byte array. If a drop   occurs another Transfer is used to marshal the byte array into  drop data for the target.       When a CutAction or a CopyAction is performed_   this transfer is used to place references to the selected resources   on the Clipboard. When a PasteAction is performed_ the   references on the clipboard are used to move or copy the resources  to the selected destination.      This class can be used for a Viewer or an SWT component directly.  A singleton is provided which may be serially reused (see getInstance).   It is not intended to be subclassed.    See Also:  StructuredViewer_  DropTarget_  DragSource  Restriction:  This class is not intended to be subclassed by clients.    
689,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/CopyProjectOperation.html,extends Object Implementation class to perform the actual copying of project resources from  the clipboard when paste action is invoked.    This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    
690,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/FileTransfer.html,"provides a platform specific mechanism   for converting a list of files represented as a java String[] to a   platform specific representation of the data and vice versa.   Each String in the array contains the absolute path for a single   file or directory.    An example of a java String[] containing a list of files is shown   below:      File file1 = new File(""C:\temp\file1"");  File file2 = new File(""C:\temp\file2"");  String[] fileData = new String[2];  fileData[0] = file1.getAbsolutePath();  fileData[1] = file2.getAbsolutePath();    See Also:  Transfer    "
691,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerSorter.html,extends ViewerComparator A viewer sorter is used by a StructuredViewer to reorder the elements   provided by its content provider.    The default compare method compares elements using two steps.   The first step uses the values returned from category.   By default_ all elements are in the same category.   The second level is based on a case insensitive compare of the strings obtained   from the content viewer's label provider via ILabelProvider.getText.      Subclasses may implement the isSorterProperty method;  they may reimplement the category method to provide   categorization; and they may override the compare methods  to provide a totally different way of sorting elements.      It is recommended to use ViewerComparator instead.    See Also:  IStructuredContentProvider_  StructuredViewer    
692,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/OpenResourceAction.html,"extends EventListener A resource change listener is notified of changes to resources  in the workspace.   These changes arise from direct manipulation of resources_ or   indirectly through re-synchronization with the local file system.    Clients may implement this interface.    See Also:  IResourceDelta_  IWorkspace.addResourceChangeListener(IResourceChangeListener_ int)    
An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
A listener which is notified when a viewer's selection changes.  See Also:  ISelection_  ISelectionProvider_  SelectionChangedEvent    
extends WorkspaceAction implements IResourceChangeListener Standard action for opening the currently selected project(s).    Note that there is a different action for opening an editor on file  resources: OpenFileAction.      This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    "
693,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILabelDecorator.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider A label decorator decorates the label text and image for some element.  The original label text and image are obtained by some other means_  for example by a label provider.  See Also:  ILabelProvider    "
694,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IShowInSource.html,Parts which need to provide a particular context to a Show In...  target can provide this interface.  The part can either directly implement this interface_ or provide it  via IAdaptable.getAdapter(IShowInSource.class).  Since:  2.1  See Also:  IShowInTarget    
695,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IShowInTarget.html,This interface must be provided by Show In targets (parts listed  in the Show In prompter).  The part can either directly implement this interface_ or provide it  via IAdaptable.getAdapter(IShowInTarget.class).  Since:  2.1  See Also:  IPageLayout.addShowInPart(java.lang.String)    
696,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/ShowInContext.html,extends Object Carries the context for the Show In action.  The default implementation carries an input and a selection.  Subclasses may extend.  Since:  2.1  See Also:  IShowInSource_  IShowInTarget    
697,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/MarkerResolutionSelectionDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends SelectionDialog Dialog to allow the user to select from a list of marker  resolutions.    This dialog may be instantiated_ it is not intented to   be subclassed.    Since:  2.0  Restriction:  This class is not intended to be subclassed by clients.    "
698,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IContainmentAdapter.html,This adapter interface provides a way to test element containment   in a model-independent way.  The workbench uses this interface in certain views  to test if a given resource is part of a working set.  Since:  2.1    
699,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ContainerGenerator.html,"extends Object For creating folder resources that currently do not exist_   along a given workspace path.    This class may be instantiated; it is not intended to be subclassed.      Example usage:    ContainerGenerator gen = new ContainerGenerator(new Path(""/A/B""));  IContainer res = null;  try {  res = gen.getContainer(monitor); // creates project A and folder B if required  } catch (CoreException e) {  // handle failure  } catch (OperationCanceledException e) {  // handle cancelation  }      Restriction:  This class is not intended to be subclassed by clients.    "
700,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPerspectiveDescriptor.html,"A perspective descriptor describes a perspective in an  IPerspectiveRegistry.     A perspective is a template for view visibility_ layout_ and action visibility  within a workbench page. There are two types of perspective: a predefined   perspective and a custom perspective.     A predefined perspective is defined by an extension to the workbench's   perspective extension point (""org.eclipse.ui.perspectives"").  The extension defines a id_ label_ and IPerspectiveFactory.  A perspective factory is used to define the initial layout for a page.    A custom perspective is defined by the user. In this case a predefined  perspective is modified to suit a particular task and saved as a new  perspective. The attributes for the perspective are stored in a separate file   in the workbench's metadata directory.        Within a page the user can open any of the perspectives known  to the workbench's perspective registry_ typically by selecting one from the  workbench's Open Perspective menu. When selected_ the views  and actions within the active page rearrange to reflect the perspective.      This interface is not intended to be implemented by clients.    See Also:  IPerspectiveRegistry  Restriction:  This interface is not intended to be implemented by clients.    "
701,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPerspectiveRegistry.html,"The workbench's global registry of perspectives.     This registry contains a descriptor for each perspectives in the workbench.  It is initially populated with stock perspectives from the workbench's   perspective extension point (""org.eclipse.ui.perspectives"") and   with custom perspectives defined by the user.    This interface is not intended to be implemented by clients.    See Also:  IWorkbench.getPerspectiveRegistry()  Restriction:  This interface is not intended to be implemented by clients.    "
702,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IActivityManager.html,An instance of this interface allows clients to manage activities_ as  defined by the extension point org.eclipse.ui.activities.    This interface is not intended to be extended or implemented by clients.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    
703,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IIdentifier.html,extends Comparable An instance of this interface can be obtained from an instance of   IActivityManagerfor any identifier.    An IIdentifier is an object that offers an easy means to   determine if a given string matches the pattern bindings of any IActivity   objects. Additionaly_ one may query if an identifier is enabled. An   identifier is always considered enabled unless it matches only disabled activities.       The handle-based nature of this API allows it to work well with runtime  plugin activation and deactivation_ which can cause dynamic changes to the  extension registry.      This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  IActivityManager.getIdentifier(String)  Restriction:  This interface is not intended to be implemented by clients.    
704,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/ISetSelectionTarget.html,Interface for views which support reveal and select.    This interface may be implemented by subclasses of ViewPart.  This interface is commonly used by a New wizard to reveal and select a  resource in a workbench part which it has just created.    See Also:  IViewPart_  ViewPart    
705,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/WorkbenchWindowAdvisor.html,extends Object Public base class for configuring a workbench window.    The workbench window advisor object is created in response to a workbench  window being created (one per window)_ and is used to configure the window.      An application should declare a subclass of WorkbenchWindowAdvisor  and override methods to configure workbench windows to suit the needs of the  particular application.      The following advisor methods are called at strategic points in the  workbench window's lifecycle (as with the workbench advisor_ all occur   within the dynamic scope of the call to   PlatformUI.createAndRunWorkbench):    preWindowOpen - called as the window is being opened;   use to configure aspects of the window other than actions bars  postWindowRestore - called after the window has been  recreated from a previously saved state; use to adjust the restored  window  postWindowCreate - called after the window has been created_  either from an initial state or from a restored state; used to adjust the  window  openIntro - called immediately before the window is opened in  order to create the introduction component_ if any.  postWindowOpen - called after the window has been  opened; use to hook window listeners_ etc.  preWindowShellClose - called when the window's shell  is closed by the user; use to pre-screen window closings    Since:  3.1    
706,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/IWorkbenchWindowConfigurer.html,Interface providing special access for configuring workbench windows.    Window configurer objects are in 1-1 correspondence with the workbench  windows they configure. Clients may use get/setData to  associate arbitrary state with the window configurer object.      Note that these objects are only available to the main application  (the plug-in that creates and owns the workbench).      This interface is not intended to be implemented by clients.    Since:  3.0  See Also:  IWorkbenchConfigurer.getWindowConfigurer(org.eclipse.ui.IWorkbenchWindow)_  WorkbenchAdvisor.preWindowOpen(org.eclipse.ui.application.IWorkbenchWindowConfigurer)  Restriction:  This interface is not intended to be implemented by clients.    
707,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/statushandlers/AbstractStatusHandler.html,extends Object  Status handlers are part of the status handling facility. The facility is  responsible for handling errors and other important issues in Eclipse based  applications. The handlers are responsible for presenting this errors by  logging or showing error dialogs.        All status handlers extends  org.eclipse.ui.statushandlers.AbstractStatusHandler. Each  handler implements handle(StatusAdapter status_ int style).  This method handles statuses due to handling style. The style indicates how  status handler should handle a status.        For acceptable styles check StatusManager.        Handlers shoudn't be used directly but through the StatusManager. It  chooses which handler should be used for handling. There are two ways for  adding handlers to the handling flow. First using extension point  org.eclipse.ui.statusHandlers_ second by the workbench  advisor and its method WorkbenchAdvisor.getWorkbenchErrorHandler().  If a handler is associated with a product_ it is used instead of this defined  in advisor.        A status handler has the id and a set of parameters. The handler can use them  during handling. If the handler is added as an extension_ both are set during  initialization of the handler using elements and attributes of  statusHandler element.    Since:  3.3    
708,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/ActionBarAdvisor.html,extends Object Public base class for configuring the action bars of a workbench window.    An application should declare a subclass of ActionBarAdvisor  and override methods to configure a window's action bars to suit the needs of the  particular application.      The following advisor methods are called at strategic points in the  workbench's lifecycle (all occur within the dynamic scope of the call  to PlatformUI.createAndRunWorkbench):    fillActionBars - called after WorkbenchWindowAdvisor.preWindowOpen  to configure a window's action bars    Since:  3.1  See Also:  WorkbenchWindowAdvisor.createActionBarAdvisor(IActionBarConfigurer)    
709,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/FileStoreEditorInput.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable IEditorInput is a light weight descriptor of editor input_  like a file name but more abstract. It is not a model. It is a description of  the model source for an IEditorPart.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs that are  the same. The IWorbenchPage.openEditor APIs are dependent on  this to find an editor with the same input.      Clients should extend this interface to declare new types of editor inputs.      An editor input is passed to an editor via the IEditorPart.init  method. Due to the wide range of valid editor inputs_ it is not possible to  define generic methods for getting and setting bytes.      Editor input must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.      Please note that it is important that the editor input be light weight.  Within the workbench_ the navigation history tends to hold on to editor  inputs as a means of reconstructing the editor at a later time. The  navigation history can hold on to quite a few inputs (i.e._ the default is  fifty). The actual data model should probably not be held in the input.    See Also:  IEditorPart_  IWorkbenchPage.openEditor(IEditorInput_ String)_  IWorkbenchPage.openEditor(IEditorInput_ String_ boolean)    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IPersistable Interface for asking an object to store its state in a memento.    This interface is typically included in interfaces where   persistance is required.    When the workbench is shutdown objects which implement this interface   will be persisted. At this time the getFactoryId method   is invoked to discover the id of the element factory that will be used   to re-create the object from a memento. Then the saveState   method is invoked to store the element data into a newly created memento.   The resulting mementos are collected up and written out to a single file.      During workbench startup these mementos are read from the file. The  factory Id for each is retrieved and mapped to an IElementFactory   which has been registered in the element factory extension point. If a   factory exists for the Id it will be engaged to re-create the original   object.    See Also:  IAdaptable_  IMemento_  IElementFactory    
extends IEditorInput This interface defines an editor input based on a URI.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs  that are the same. The IWorkbenchPage.openEditor APIs  are dependent on this to find an editor with the same input.    Path-oriented editors should support this as a valid input type_ and  can allow full read-write editing of its content.    All editor inputs must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    Since:  3.3  See Also:  URI    
extends Object implements IURIEditorInput_ IPersistableElement Implements an IEditorInput instance appropriate for   IFileStore elements that represent files  that are not part of the current workspace.  Since:  3.3    "
710,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPageLayout.html,"A page layout defines the initial layout for a perspective within a page   in a workbench window.    This interface is not intended to be implemented by clients.      When a perspective is opened_ it creates a new page layout with a single editor area.   This layout is then passed to the perspective factory (implementation of  IPerspectiveFactory.createInitialLayout(IPageLayout)) where   additional views and other content can be added_ using the existing editor area as   the initial point of reference.      In some cases_ multiple instances of a particular view may need to be added  to the same layout. These are disambiguated using a secondary id.   In layout methods taking a view id_ the id can have the compound form:   primaryId [':' secondaryId].  If a secondary id is given_ the view must allow multiple instances by  having specified allowMultiple=""true"" in its extension.  View placeholders may also have a secondary id.      Wildcards are permitted in placeholder ids (but not regular view ids).   '*' matches any substring_ '?' matches any single character.   Wildcards can be specified for the primary id_ the secondary id_ or both.   For example_ the placeholder ""someView:*"" will match any occurrence of the view   that has primary id ""someView"" and that also has some non-null secondary id.  Note that this placeholder will not match the view if it has no secondary id_  since the compound id in this case is simply ""someView"".      Example of populating a layout with standard workbench views:    IPageLayout layout = ...  // Get the editor area.  String editorArea = layout.getEditorArea();  // Top left: Project Explorer view and Bookmarks view placeholder  IFolderLayout topLeft = layout.createFolder(""topLeft""_ IPageLayout.LEFT_ 0.25f_  editorArea);  topLeft.addView(IPageLayout.ID_PROJECT_EXPLORER);  topLeft.addPlaceholder(IPageLayout.ID_BOOKMARKS);  // Bottom left: Outline view and Property Sheet view  IFolderLayout bottomLeft = layout.createFolder(""bottomLeft""_ IPageLayout.BOTTOM_ 0.50f_  ""topLeft"");  bottomLeft.addView(IPageLayout.ID_OUTLINE);  bottomLeft.addView(IPageLayout.ID_PROP_SHEET);  // Bottom right: Task List view  layout.addView(IPageLayout.ID_TASK_LIST_ IPageLayout.BOTTOM_ 0.66f_ editorArea);      Restriction:  This interface is not intended to be implemented by clients.    "
711,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPlaceholderFolderLayout.html,An IPlaceholderFolderLayout is used to define the initial  view placeholders within a folder.   The folder itself is contained within an IPageLayout.    This interface is not intended to be implemented by clients.    Since:  2.0  See Also:  IPageLayout.createPlaceholderFolder(java.lang.String_ int_ float_ java.lang.String)  Restriction:  This interface is not intended to be implemented by clients.    
712,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IFolderLayout.html,"An IPlaceholderFolderLayout is used to define the initial  view placeholders within a folder.   The folder itself is contained within an IPageLayout.    This interface is not intended to be implemented by clients.    Since:  2.0  See Also:  IPageLayout.createPlaceholderFolder(java.lang.String_ int_ float_ java.lang.String)  Restriction:  This interface is not intended to be implemented by clients.    
extends IPlaceholderFolderLayout An IFolderLayout is used to define the initial views within a folder.  The folder itself is contained within an IPageLayout.    This interface is not intended to be implemented by clients.    See Also:  IPageLayout.createFolder(java.lang.String_ int_ float_ java.lang.String)  Restriction:  This interface is not intended to be implemented by clients.    "
713,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/CommonViewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends TreeViewer Provides the Tree Viewer for the Common Navigator. Content and labels are  provided by an instance of INavigatorContentService  which uses  the ID supplied in the constructor  CommonViewer(String_ Composite_ int) or through  NavigatorContentServiceFactory.createContentService(String_ org.eclipse.jface.viewers.StructuredViewer).      Clients may extend this class.        Note that as of 3.2.1 and 3.3_ the common viewer caches its selection.  Clients must not set the selection of the viewer's tree control directly.    Since:  3.2    "
714,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorContentService.html,"Manages content extensions for extensible viewers and provides reusable  services for filters_ sorting_ the activation of content extensions_ and DND.  The service can locate the appropriate providers (for contents or labels) for  an element and provide a ready-to-go ITreeContentProvider and  ILabelProvider for viewers that wish to take advantage of the  org.eclipse.ui.navigator.navigatorContent extensions defined for a  particular viewerId.      Clients can get the instance of this associated with the CommonNavigator using  CommonNavigator.getNavigatorContentService().        Clients may contribute logical extensions using  org.eclipse.ui.navigator.navigatorContent. Each extension has three  states which determine whether the extension is used by the content service:    visible: If a content extension id matches a  viewerContentBinding for the viewerId of this content  service_ then the extension is visible. Visible extensions may only  be configured through viewerContentBindings.   active: The active state may be set to a default using the  activeByDefault attribute of navigatorContent. Users may  toggle the active state through the ""Available customizations""  dialog. Clients may also configure the active extensions using  INavigatorActivationService.activateExtensions(String[]_ boolean) or  INavigatorActivationService.deactivateExtensions(String[]_ boolean)  from the Activation Service   enabled: An extension is enabled for an element if the  extension contributed that element or if the element is described in the  triggerPoints element of the navigatorContent extension. The  findXXX() methods search for enabled extensions.       A new instance of the content service should be created for each viewer.  Clients should use createCommonContentProvider() and  createCommonLabelProvider() for the viewer. Each content service  tracks the viewer it is attached to. Clients may create the content service  with a viewer using (NavigatorContentServiceFactory.createContentService(String)).  Alternatively_ when the content provider is created and set on a viewer_  IContentProvider.inputChanged(org.eclipse.jface.viewers.Viewer_ Object_ Object)  will be called and the content provider will update the viewer used by its  backing content service. Therefore_ only each content service has exactly one  content provider and one label provider.      Extensions may also coordinate their behavior through a  state model. The state model holds properties  and supports property change listeners. Actions can toggle the setting of  properties and the corresponding content/label providers will respond to  property change event. Each navigatorContent extension has its own  contained state model keyed off of the content extension id.      Clients may respond when content extensions are loaded by attaching a  INavigatorContentServiceListener to the content service.      Some extensions may provide content or label providers which implement  IMemento. Clients must call restoreState(IMemento) and  saveState(IMemento) at the appropriate times for these extensions to  prepare themselves with the memento.    Since:  3.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
715,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/Priority.html,extends Object  Enumeration of the Priority values supported by the Common Navigator.    Since:  3.2    
716,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/IMementoAware.html,Clients may use mementos to persist interesting state between sessions.  Clients should ensure that the memento keys are unique; generally by using  the id of the content extension as a prefix.  Since:  3.2    
717,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/CommonActionProvider.html,"Clients may use mementos to persist interesting state between sessions.  Clients should ensure that the memento keys are unique; generally by using  the id of the content extension as a prefix.  Since:  3.2    
extends ActionGroup implements IMementoAware  Provides actions from extensions for menu and  IActionBars contributions.      This abstract class should be extended by clients of the  org.eclipse.ui.navigator.navigatorContent extension point for  top-level and nested actionProvider elements.      CommonActionProviders may be declared as top-level elements in the  extension point (e.g. an actionProvider element at the root of the  extension point). Alternatively_ actionProvider elements may be  nested under a navigatorContent element_ in which case they are  considered to be ""associated"" with that content extension. For more  information_ see the org.eclipse.ui.navigator.navigatorContent  extension point.      Each action provider will have the opportunity to contribute to the context  menu when a user right clicks and also contribute to the IActionBars  each time the selection changes. Clients should re-configure the  IActionBars each time that ActionGroup.fillActionBars(IActionBars) is  called (which is once per selection changes). ActionGroup.updateActionBars()  will never be called from the NavigatorActionService. This behavior  is required since each selection could determine a different set of  retargetable actions. For instance_ the ""Delete"" operation for a custom model  element is likely to be different than for a resource.      Therefore_ each extension will have an opportunity to contribute to the  IActionBars based on the possibleChildren expression of the enclosing  navigatorContent extension or the enablement expression of  the actionProvider (for both top-level actionProviders and  nested actionProviders which only support a subset of the enclosing  content extensions possibleChildren expression).    Clients may extend this class.    Since:  3.2    "
718,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISaveablesSource.html,Represents a source of Saveable objects (units of saveability). Workbench  parts that show more than one unit of saveability_ or whose units of  saveability change over time_ should implement this interface in order to  provide better integration with workbench facilities like the Save command_  prompts to save on part close or shutdown_ etc.    IMPORTANT: As of 3.2_ implementers of ISaveablesSource must  satisfy the following conditions:    If ISaveablesSource is implemented by an IWorkbenchPart:  the part must implement ISaveablePart  if any of its Saveable objects are dirty_ the part must return  true from ISaveablePart.isDirty()  the part must return true from  ISaveablePart.isSaveOnCloseNeeded() if it is dirty (the default  behaviour implemented by EditorPart)  the part must not implement ISaveablePart2    If ISaveablesSource is implemented by a non-part (possible as of 3.2.1 and 3.3):  the Workbench's ISaveablesLifecycleListener (obtained from the  Workbench by calling  workbench.getService(ISaveablesLifecycleListener.class)) must  be notified of any change to the result of getSaveables()   getActiveSaveables() should be implemented to return an empty array      If any of these conditions are not met_ it is undefined whether the Workbench  will prompt to save dirty Saveables when closing parts or the Workbench.      These conditions may be relaxed in future releases.    Since:  3.2    
719,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/CommonNavigator.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
Represents a source of Saveable objects (units of saveability). Workbench  parts that show more than one unit of saveability_ or whose units of  saveability change over time_ should implement this interface in order to  provide better integration with workbench facilities like the Save command_  prompts to save on part close or shutdown_ etc.    IMPORTANT: As of 3.2_ implementers of ISaveablesSource must  satisfy the following conditions:    If ISaveablesSource is implemented by an IWorkbenchPart:  the part must implement ISaveablePart  if any of its Saveable objects are dirty_ the part must return  true from ISaveablePart.isDirty()  the part must return true from  ISaveablePart.isSaveOnCloseNeeded() if it is dirty (the default  behaviour implemented by EditorPart)  the part must not implement ISaveablePart2    If ISaveablesSource is implemented by a non-part (possible as of 3.2.1 and 3.3):  the Workbench's ISaveablesLifecycleListener (obtained from the  Workbench by calling  workbench.getService(ISaveablesLifecycleListener.class)) must  be notified of any change to the result of getSaveables()   getActiveSaveables() should be implemented to return an empty array      If any of these conditions are not met_ it is undefined whether the Workbench  will prompt to save dirty Saveables when closing parts or the Workbench.      These conditions may be relaxed in future releases.    Since:  3.2    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ IPersistable A view is a visual component within a workbench page. It is typically used to  navigate a hierarchy of information (like the workspace)_ open an editor_ or  display properties for the active editor. Modifications made in a view are  saved immediately (in contrast to an editor part_ which conforms to a more  elaborate open-save-close lifecycle).    Only one instance of a particular view type may exist within a workbench  page. This policy is designed to simplify part management for a user.      This interface may be implemented directly. For convenience_ a base  implementation is defined in ViewPart.      A view is added to the workbench in two steps:    A view extension is contributed to the workbench registry. This  extension defines the extension id and extension class.  The view is included in the default layout for a perspective.  Alternatively_ the user may open the view from the Perspective menu.      Views implement the IAdaptable interface; extensions are  managed by the platform's adapter manager.      As of 3.4_ views may optionally adapt to ISizeProvider if they have  a preferred size. The default presentation will make a best effort to  allocate the preferred size to a view if it is the only part in a stack. If  there is more than one part in the stack_ the constraints will be disabled  for that stack. The size constraints are adjusted for the size of the tab and  border trim. Note that this is considered to be a hint to the presentation_  and not all presentations may honor size constraints.    See Also:  IWorkbenchPage.showView(java.lang.String)_  ViewPart_  ISizeProvider    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
Interface for views which support reveal and select.    This interface may be implemented by subclasses of ViewPart.  This interface is commonly used by a New wizard to reveal and select a  resource in a workbench part which it has just created.    See Also:  IViewPart_  ViewPart    
This interface must be provided by Show In targets (parts listed  in the Show In prompter).  The part can either directly implement this interface_ or provide it  via IAdaptable.getAdapter(IShowInTarget.class).  Since:  2.1  See Also:  IPageLayout.addShowInPart(java.lang.String)    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
extends ViewPart implements ISetSelectionTarget_ ISaveablePart_ ISaveablesSource_ IShowInTarget  This class provides the IViewPart for the Common Navigator framework in the  Eclipse workbench. This class also serves as the backbone for navigational  viewers. The following types are used by this class to render the Common  Navigator:        CommonViewer: The viewer that renders the  extensible tree. Creates and manages the lifecycle of the Navigator Content  Service (described below).          NavigatorActionService: Manages instances of  CommonActionProviders provided by individual  extensions and content extensions.          INavigatorContentService: Manages instances  of Navigator Content Extensions. Instances are created as needed_ and  disposed of upon the disposal of the Navigator Content Service.          Clients that wish to define their own custom extensible navigator view using  CommonNavigator need to specify an instance of the  org.eclipse.ui.views extension point:        <extension  point=""org.eclipse.ui.views"">  <view  name=""My Custom View""  icon=""relative/path/to/icon.gif""  category=""org.acme.mycategory""  class=""org.eclipse.ui.navigator.CommonNavigator""  id=""org.acme.MyCustomNavigatorID"">  </view>  </extension>              CommonNavigator gets its initial input (during initialization) from the  Workbench by calling getSite().getPage().getInput(). This is done in  getInitialInput(). Clients may create a subclass of CommonNavigator  to provide their own means of getting the initial input. Or they may access  the CommonViewer and set its input directly after startup.        In the IDE scenario_ the default page input is IWorkspaceRoot_ in the RCP  scenario it is null and can be configured in the WorkbenchAdvisor.        Clients that wish to extend the view menu provided via the  org.eclipse.ui.popupMenus extension may specify the the  popupMenuId specified by org.eclipse.ui.navigator.viewer (or a  nested popupMenu element) of their target viewer as their target menu  id.        This class may be instantiated or subclassed    Since:  3.2    "
720,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/LinkHelperService.html,extends Object Manages the link helpers which are used to define the behavior of  the link with editor function.  Since:  3.4  Restriction:  This class is not intended to be instantiated by clients.    
721,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorViewerDescriptor.html,Provides a basic metadata about the abstract viewer for a particular content  service.  Since:  3.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
722,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IPageSite.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
 A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends IAdaptable_ IShellProvider_ IServiceLocator The common interface between the workbench and its parts_ including pages  within parts.    The workbench site supports a few services by  default. If these services are used to allocate resources_ it is important to  remember to clean up those resources after you are done with them. Otherwise_  the resources will exist until the workbench site is disposed. The supported  services are:    ICommandService  IContextService  IHandlerService  IBindingService. Resources allocated through this service will  not be cleaned up until the workbench shuts down.    This interface is not intended to be implemented or extended by clients.    Since:  2.0  See Also:  IWorkbenchPartSite_  IPageSite  Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkbenchSite The primary interface between a page and the outside world.    The workbench exposes its implemention of page sites via this interface_  which is not intended to be implemented or extended by clients.    Restriction:  This interface is not intended to be implemented by clients.    "
723,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorContentDescriptor.html,The descriptor provides a the low-level handle to a content extension. Information such as  the Id_ the name_ the priority_ and whether the descriptor provides one or  more root elements is provided. This descriptor is used to form the   INavigatorContentExtension.      There is a one-to-many correspondence between the INavigatorContentDescriptor and  INavigatorContentExtension. An instance of the INavigatorContentExtension is  created for each INavigatorContentDescriptor used by a   INavigatorContentService.    Since:  3.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
724,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/EvaluationResult.html,extends Object An evaluation result represents the result of an expression  evaluation. There are exact three instances of evaluation  result. They are: FALSE_ TRUE and  NOT_LOADED. NOT_LOADED represents  the fact that an expression couldn't be evaluated since a  plug-in providing certain test expressions isn't loaded yet.    In addition the class implements the three operation and  _ or and not. The operation are  defined as follows:      The and operation:    AND FALSE TRUE NOT_LOADED  FALSE FALSE FALSE FALSE  TRUE FALSE TRUE NOT_LOADED  NOT_LOADED FALSE NOT_LOADED NOT_LOADED    The or operation:    OR FALSE TRUE NOT_LOADED  FALSE FALSE TRUE NOT_LOADED  TRUE TRUE TRUE TRUE  NOT_LOADED NOT_LOADED TRUE NOT_LOADED    The not operation:    NOT FALSE TRUE NOT_LOADED  TRUE FALSE NOT_LOADED    The class is not intended to be subclassed by clients.    Since:  3.0  Restriction:  This class is not intended to be subclassed by clients.    
725,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/CommonDropAdapterAssistant.html,extends Object  Used by the  org.eclipse.ui.navigator.navigatorContent/navigatorContent/commonDropAdapter  extension point to carry out pluggable drop operations.      Each CommonDropAdapterAssistant is contained by single content  extension. The opportunity for each assistant to handle the drop operation is  determined by the possibleChildren expression of the  org.eclipse.ui.navigator.navigatorContent/navigatorContent extension;  whenever every element in the drag set matches the possibleChildren  expression of an extension_ it is eligible to handle the drop operation. This  initial set is further culled using the possibleDropTargets  expression of the commonDropAdapter using the current drop target.      If drag operations originate outside of Eclipse_ then the set of eligible  drop adapters is determined based on the drop target (using the  possibleDropTargets expression). Each assistant can then indicate   whether the incoming type is supported.    Whenever a match is found_ the assistant will be given an opportunity to  first validateDrop(Object_ int_ TransferData)_ and then if the  assistant returns true_ the assist must  handleDrop(CommonDropAdapter_ DropTargetEvent_ Object). If  multiple assistants match the drop target_ then the potential assistants are  ordered based on priority and their override relationships and given an  opportunity to validate the drop operation in turn. The first one to validate  will have the opportunty to carry out the drop.        Clients may handle DND operations that begin and end in the current viewer by  overriding the following methods:    validateDrop(Object_ int_ TransferData): Indicate whether this  assistant can handle a drop onto the current viewer.  handleDrop(CommonDropAdapter_ DropTargetEvent_ Object): Handle  the drop operation onto the current viewer.      If a user originates a drag operation to another viewer that cannot handle  one of the available drag transfer types_ drop assistants may handle the drop  operation for the target viewer. Clients must override :    validatePluginTransferDrop(IStructuredSelection_ Object):  Indicate whether this assistant can handle the drop onto another viewer.    handlePluginTransferDrop(IStructuredSelection_ Object): Handle  the drop operation onto the other viewer.      Clients may subclass this.    Since:  3.2  See Also:  INavigatorDnDService_  INavigatorDnDService.findCommonDropAdapterAssistants(Object_  TransferData)    
726,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/CommonDropAdapter.html,"extends org.eclipse.swt.internal.SWTEventListener The DropTargetListener class provides event notification to the application   for DropTarget events.  As the user moves the cursor into_ over and out of a Control that has been designated   as a DropTarget_ events indicate what operation can be performed and what data can be   transferred if a drop where to occur at that point.  The application can respond to these events and change the type of data that will   be dropped by modifying event.currentDataType_ or change the operation that will be performed   by modifying the event.detail field or stop any drop from happening on the current target  by setting the event.detail field to DND_DROP_NONE.  When the user causes a drop to happen by releasing the mouse over a valid drop target_   the application has one last chance to change the data type of the drop through the   DropAccept event. If the drop is still allowed_ the DropAccept event is immediately   followed by the Drop event. In the Drop event_ the application can still change the  operation that is performed but the data type is fixed.  See Also:  DropTargetEvent    
extends PluginDropAdapter Provides an implementation of PluginDropAdapter which uses the  extensions provided by the associated INavigatorContentService.      Clients should not need to create an instance of this class unless they are  creating their own custom viewer. Otherwise_ CommonViewer configures  its drop adapter automatically.    Since:  3.2  See Also:  INavigatorDnDService_  CommonDragAdapter_  CommonDragAdapterAssistant_  CommonDropAdapterAssistant_  CommonViewer    "
727,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/CommonDragAdapterAssistant.html,extends Object Assist the CommonDragAdapter by providing new TransferTypes and the  logic to handle setting up the transfer data. Clients must extend this class  as part of the org.eclipse.ui.navigator.viewer/dragAssistant  extension. By default_ the Common Navigator supports  LocalSelectionTransfer and PluginTransfer.      Clients may extend this class.    Since:  3.2  See Also:  INavigatorDnDService_  CommonDragAdapter_  CommonDropAdapter_  CommonDropAdapterAssistant_  CommonViewer_  Drag  and Drop: Adding Drag and Drop to an SWT Application_  Drag  and Drop in the Eclipse UI (Custom Transfer Types)    
728,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/PluginTransferData.html,extends Object Record for transferring data during a drag and drop operation between  different plug-ins. This object contains an extension identifier and a block  of bytes. When the drop occurs_ the data is interpreted by an action defined  in the specified extension.    Clients using PluginTransfer should create an instance to contain the  drop data.    Restriction:  This class is not intended to be subclassed by clients.    
729,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonViewerSite.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable Provides context for extensions including a valid shell_ a selection  provider_ and a unique identifier corresponding to the abstract viewer behind  the viewer site.  Since:  3.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
730,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorContentExtension.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable The content extension represents the components of a navigatorContent  extension. These handles are managed by a content service  INavigatorContentService. An extension is formed from the  INavigatorContentDescriptor.       There is a one-to-many correspondence between the INavigatorContentDescriptor and  INavigatorContentExtension. An instance of the INavigatorContentExtension is  created for each INavigatorContentDescriptor used by a   INavigatorContentService.    Since:  3.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
731,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/IExtensionStateModel.html,Allows clients to coordinate state across components that are part of the  same logical extension.      That is_ a content provider might vary how it exposes its content based on  the state of a specific property in the model. Interested parties may add  themselves as IPropertyChangeListeners to track changes in the state  model.    Since:  3.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
732,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ILinkHelper.html, Provides information to the Common Navigator on how to link selections with  active editors and vice versa.      The Common Navigator allows clients to plug-in their own custom logic for  linking selections from the Viewer to active editors. This interface is used  by the org.eclipse.ui.navigator.linkHelper extension  point to gather information and trigger editor activations.    Since:  3.2    
733,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/OverridePolicy.html,extends Object  Enumeration of the OverridePolicy values supported by the Common Navigator.    Since:  3.4    
734,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/IDescriptionProvider.html,Label providers (as specified by the labelProvider attribute of the  org.eclipse.ui.navigator.navigatorContent extension point) may   choose to also implement this interface in order to provide text for   the status bar at the bottom of the Eclipse window.  Since:  3.2    
735,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonLabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
Label providers (as specified by the labelProvider attribute of the  org.eclipse.ui.navigator.navigatorContent extension point) may   choose to also implement this interface in order to provide text for   the status bar at the bottom of the Eclipse window.  Since:  3.2    
A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider Extends IBaseLabelProvider with the methods  to provide the text and/or image for the label of a given element.   Used by most structured viewers_ except table viewers.    
Clients may use mementos to persist interesting state between sessions.  Clients should ensure that the memento keys are unique; generally by using  the id of the content extension as a prefix.  Since:  3.2    
extends ILabelProvider_ IMementoAware_ IDescriptionProvider Allows extensions to vary their behavior based on properties in the extension  model and the given memento.      Clients should refer to the org.eclipse.ui.navigator.navigatorContent  extension point for more information on building a content extension.      Clients should not dispose of any Image Resources that might be shared by  other extensions when their Label Provider is disposed. When a content extension  is deactivated_ both its content and label providers are disposed_ but the  viewer remains visible to the user. If clients dispose of Image Resources used  by other extensions_ then it will cause problems for those extensions and the   viewer in general.       Clients may implement this interface if they require the methods provided here.  ILabelProvider is respected by the Common  Navigator.    Since:  3.2    "
736,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonContentExtensionSite.html,Provides initialization data for a content extension. Supplied in the  init() methods of various interfaces allowed by the framework.  Since:  3.2  See Also:  ICommonLabelProvider_  ICommonContentProvider  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
737,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/StyledString.html,extends Object A mutable string with styled ranges. All ranges mark substrings of the string  and do not overlap. Styles are applied using instances of StyledString.Styler to  compute the result of getStyleRanges().    The styled string can be built in the following two ways:  new strings with stylers can be appended  stylers can by applied to ranges of the existing string      This class may be instantiated; it is not intended to be subclassed.    Since:  3.4    
738,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITreePathLabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider An extension to ILabelProvider that is given the   path of the element being decorated_ when it is available.  Since:  3.2    "
739,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/PipelinedShapeModification.html,extends Object Indicates how a shape modification should be transformed when applied to the  tree. Clients use PipelinedShapeModification as the input and return  type from intercept methods on IPipelinedTreeContentProvider.      Overriding extensions should use these to map attempts to directly modify the  tree down to the overridden model. A shape modification can either be an  add or remove shape modification_ and the type is determined by  the context of its use. If supplied to an interceptRemove  method_ then it is a remove shape modification_ otherwise if supplied to an  interceptAdd method_ then it is an add shape modification.    Since:  3.2    
740,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/PipelinedViewerUpdate.html,extends Object A pipelined viewer update should map requests to refresh or update elements  in the viewer to their correct_ modified structure. Clients use  PipelinedViewerUpdate as the input and return type from intercept  methods on IPipelinedTreeContentProvider.      Clients should use the viewer update to describe how the request from the  upstream extension (see IPipelinedTreeContentProvider for more  information on upstream extensions) should be reshaped when applied  to the tree. A request from an upstream extension to refresh a given element  could result in multiple refresh requests from downstream extensions.  Therefore_ the refresh targets are modeled as a set.      Initially_ this set will contain the original element that was passed to the  refresh requests. Clients may squash the refresh by clearing the set_ change  the original target by removing the current element and adding a new target_  or expand the refresh by adding more elements to the set.      A pipelined extension may receive a PipelinedViewerUpdate as the  result of a call to StructuredViewer.refresh()-methods or  ColumnViewer.update(Object_ String[])-methods. The  properties field is only applicable for update()  calls and the updateLabels field is only applicable for  refresh() calls.    Since:  3.2    
741,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITreePathContentProvider.html,"A content provider mediates between the viewer's model  and the viewer itself.  See Also:  ContentViewer.setContentProvider(IContentProvider)    
extends IContentProvider An interface to content providers for structured viewers.  See Also:  StructuredViewer    
extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers that  provides content based on the path of elements in the tree viewer.  Since:  3.2  See Also:  AbstractTreeViewer    "
742,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonActionExtensionSite.html,Provides access to information required for the initialization of  CommonActionProviders.      See the documentation of the org.eclipse.ui.navigator.navigatorContent  extension point and CommonActionProvider for more information on  contributing actions.    Since:  3.2  See Also:  CommonActionProvider  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
743,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerFilter.html,extends Object A viewer filter is used by a structured viewer to  extract a subset of elements provided by its content provider.    Subclasses must implement the select method  and may implement the isFilterProperty method.    See Also:  IStructuredContentProvider_  StructuredViewer    
744,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ColorRegistry.html,extends ResourceRegistry A color registry maintains a mapping between symbolic color names and SWT   Colors.    A color registry owns all of the Color objects registered with   it_ and automatically disposes of them when the SWT Display that creates the   Colors is disposed. Because of this_ clients do not need to   (indeed_ must not attempt to) dispose of Color objects   themselves.      Methods are provided for registering listeners that will be kept  apprised of changes to list of registed colors.      Clients may instantiate this class (it was not designed to be subclassed).    Since:  3.0  Restriction:  This class is not intended to be subclassed by clients.    
745,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonFilterDescriptor.html,Provides information about a commonFilter extension.  Since:  3.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
746,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorFilterService.html,Provides support for managing the filters defined for a Common Navigator  viewer.      An INavigatorFilterService manages the available common filters and their  current activation state for a particular INavigatorContentService. An  INavigatorFilterService cannot be acquired without an  INavigatorContentService (through  INavigatorContentService.getFilterService()). Each instance will  provide information specific to the content service associated with it.      The visibility of commonFilters is controlled through matching  viewerContentBindings. That is_ like content extensions_ the id of a  commonFilter must match an includes expression for at least one  viewerContentBinding element for the corresponding  INavigatorContentService.      The activation of each filter should be persisted from session to session.  Clients of this interface have control over when the persistence occurs. In  particular_ clients should call persistFilterActivationState()  after each call to setActiveFilterIds(String[]).    Since:  3.2  See Also:  INavigatorContentService.getFilterService()_  ViewerFilter  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
747,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/IExtensionActivationListener.html,An extension activation listener is notified whenever the activation state  changes for one or more content extensions.  Since:  3.2  See Also:  INavigatorActivationService_  INavigatorActivationService.addExtensionActivationListener(IExtensionActivationListener)_  INavigatorActivationService.removeExtensionActivationListener(IExtensionActivationListener)    
748,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorActivationService.html,Determines if an extension is active within the context of a given  viewer and manages the persistence of this information. If an extension is  active then the extension will contribute functionality to the  viewer. If an extension is not active_ then the extension will not be  given opportunities to contribute functionality to the given viewer. See  INavigatorContentService for more detail on what states are  associated with a content extension.  Since:  3.2    
749,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorContentServiceListener.html, Used by clients who would like to listen for the load event of am  INavigatorContentExtension.  Since:  3.2    
750,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorSorterService.html,Provides an interface to extensions declared in  org.eclipse.ui.navigator.navigatorContent/commonSorter.      Like other extensions to the Common Navigator framework_ sorters defined by  the above extension point must be bound to the associated  INavigatorContentService through a  org.eclipse.ui.navigator.viewer/viewerContentBinding extension.    Since:  3.2  See Also:  INavigatorContentService.getSorterService()_  ViewerSorter  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
751,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorPipelineService.html,Performs calculations that are necessary to determine the correct children to  render in the viewer.  Since:  3.2  See Also:  INavigatorContentService.getPipelineService()_  PipelinedShapeModification_  PipelinedViewerUpdate_  IPipelinedTreeContentProvider  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
752,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorDnDService.html,Provides instances of CommonDragAdapterAssistant and  CommonDropAdapterAssistant for the associated  INavigatorContentService.      Clients should only take note of this Service they are are using the  INavigatorContentService in the context of a viewer which is not or  does not extend CommonViewer. Clients should take a look at the  initialization of the DND support in the CommonViewer if they wish to  support this capability in their own viewers.    Since:  3.2  See Also:  CommonDragAdapter_  CommonDragAdapterAssistant_  CommonDropAdapter_  CommonDropAdapterAssistant_  CommonViewer_  INavigatorContentService.getDnDService()_  Drag  and Drop: Adding Drag and Drop to an SWT Application_  Drag  and Drop in the Eclipse UI (Custom Transfer Types)  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
753,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorSaveablesService.html, Since:  3.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
754,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonContentProvider.html,extends ITreeContentProvider_ IMementoAware Allows extensions to vary their behavior based on properties in the extension  model and the given memento. The state model should be initialized from  values in the memento if necessary.      Clients should refer to the org.eclipse.ui.navigator.navigatorContent  extension point for more information on building a content extension.        Clients may implement this interface if they require the methods defined here.  ITreeContentProvider is respected by the Common  Navigator.    Since:  3.2    
755,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/IPipelinedTreeContentProvider.html,"extends ITreeContentProvider_ IMementoAware Allows extensions to vary their behavior based on properties in the extension  model and the given memento. The state model should be initialized from  values in the memento if necessary.      Clients should refer to the org.eclipse.ui.navigator.navigatorContent  extension point for more information on building a content extension.        Clients may implement this interface if they require the methods defined here.  ITreeContentProvider is respected by the Common  Navigator.    Since:  3.2    
A content provider mediates between the viewer's model  and the viewer itself.  See Also:  ContentViewer.setContentProvider(IContentProvider)    
Clients may use mementos to persist interesting state between sessions.  Clients should ensure that the memento keys are unique; generally by using  the id of the content extension as a prefix.  Since:  3.2    
extends IContentProvider An interface to content providers for structured viewers.  See Also:  StructuredViewer    
A content provider mediates between the viewer's model  and the viewer itself.  See Also:  ContentViewer.setContentProvider(IContentProvider)    
extends IContentProvider An interface to content providers for structured viewers.  See Also:  StructuredViewer    
extends IStructuredContentProvider An interface to content providers for tree-structure-oriented  viewers.  See Also:  AbstractTreeViewer    
extends ICommonContentProvider To correctly implement pipelining you should implement  IPipelinedTreeContentProvider2 which provides the  additional  ITreeContentProvider.hasChildren(Object) method.  This allows the calculation of hasChildren to match what will be provided in  calculating the children. If you don't implement the hasChildren_ you may get  ""false positive"" hasChildrens which will result in a ""+"" indication in the  tree in the event that the pipelined children calculation.    The only reason these are two separate interfaces is historical.  Since:  3.2    "
756,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IFontProvider.html,Interface to provide font representation for a given element.  Since:  3.0  See Also:  IFontDecorator    
757,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IColorProvider.html,Interface to provide color representation for a given element.  See Also:  IColorDecorator    
758,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerColumn.html,extends Object Instances of this class represent a column of a ColumnViewer. Label  providers and editing support can be configured for each column separately.  Concrete subclasses of ColumnViewer should implement a matching  concrete subclass of ViewerColumn.  Since:  3.3    
759,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/IEvaluationService.html," The interface that should be implemented by services that make themselves  available through the IAdaptable mechanism. This is the  interface that drives the majority of services provided at the workbench  level.      A service has life-cycle. When the constructor completes_ the service must be  fully functional. When it comes time for the service to go away_ then the  service will receive a dispose() call. At this point_ the service  must release all resources and detach all listeners. A service can only be  disposed once; it cannot be reused.      This interface has nothing to do with OSGi services.      This interface can be extended or implemented by clients.    Since:  3.2    
extends IDisposable  A service that responds to changes in one or more sources. These sources can  be plugged into the service. Sources represent a common event framework for  services.      Clients must not extend or implement.    Since:  3.2    
extends IServiceWithSources Evaluate a core expression against the workbench application context and  report updates using a Boolean property. Clients supply an  IPropertyChangeListener that will be notified as changes  occur.    This can be used to implement core expressions in client extension points  similar to the <enabledWhen> of  org.eclipse.ui.handlers/handler elements.      The service will fire Boolean.TRUE and  Boolean.FALSE for the oldValue and newValue in the property  change events.      Adding the evaluation listener will fire one change with oldValue=null  and newValue=""evaluated expression"". Remove the  IEvaluationReference will fire one change with  oldValue=""last evaluated value"" and newValue=null.      Adding a service listener will fire the PROP_NOTIFYING property  change event with newValue=Boolean.TRUE when a source change  causes expression evaluations to update and another PROP_NOTIFYING  property change event with newValue=Boolean.FALSE when the  changes that started with a specific source change have finished. The  PROP_NOTIFYING change events will not be fired for source changes  caused by the outer most recalculations.      Variable sources can be provided to this service using the org.eclipse.ui.services  Extension Point. This makes the available to <with/> expressions.      This service can be acquired from your service locator:    IEvaluationService service = (IEvaluationService) getSite().getService(IEvaluationService.class);    This service is available globally.    Since:  3.4  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
760,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISaveablesLifecycleListener.html,Listener for events fired by implementers of ISaveablesSource.      This service can be acquired from a part's service locator:      ISaveablesLifecycleListener listener = (ISaveablesLifecycleListener) getSite()  .getService(ISaveablesLifecycleListener.class);      or_ in the case of implementers of ISaveablesSource that are not a  part_ from the workbench:      ISaveablesLifecycleListener listener = (ISaveablesLifecycleListener) workbench  .getService(ISaveablesLifecycleListener.class);      This service is available globally.    Since:  3.2    
761,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/SaveablesProvider.html," The interface that should be implemented by services that make themselves  available through the IAdaptable mechanism. This is the  interface that drives the majority of services provided at the workbench  level.      A service has life-cycle. When the constructor completes_ the service must be  fully functional. When it comes time for the service to go away_ then the  service will receive a dispose() call. At this point_ the service  must release all resources and detach all listeners. A service can only be  disposed once; it cannot be reused.      This interface has nothing to do with OSGi services.      This interface can be extended or implemented by clients.    Since:  3.2    
extends Object implements IDisposable Provides Saveable objects to the common navigator_ and allows to map  between elements in the tree and models.    This class is intended to be subclassed by clients.    Instances of subclasses will be returned from content extensions that  implement IAdaptable.  Since:  3.2    "
762,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/PerformanceStats.html,"extends Object PerformanceStats collects and aggregates timing data about events such as  a builder running_ an editor opening_ etc. This data is collected for the   purpose of performance analysis_ and is not intended to be used as  a generic event tracking and notification system.    Each performance event can have an associated maximum acceptable  duration that is specified in the platform debug options file (.options).  Events that take longer than this maximum are logged as errors. Along  with option file entries for each debug event_ there are some global debug  options for enabling or disabling performance event gathering and reporting.  See the ""org.eclipse.core.runtime/perf*"" debug options in the .options file  for the org.eclipse.core.runtime plugin for more details.    A performance event can optionally have additional context information  (getContext()). This information is only stored in the case  of a performance failure_ and can be used to provide further diagnostic   information that can help track down the cause of the failure.    Performance events and performance failures are batched up and periodically  sent to interested performance event listeners.    This class is not intended to be subclassed or instantiated by clients.    Since:  3.1    "
763,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ActionGroup.html,extends Object An ActionGroup represents a group of actions  which are added to a context menu_ or the action bars of a part_ together.  The group is given a context which can be used to determine which actions  are added_ and what their enabled state should be.    This class is intended only as a convenience for managing groups of actions.  Clients are not required to use this class in order to add actions to context  menus or action bars.      Clients should subclass this class and extend or override the appropriate fill methods.    Since:  2.0    
764,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPartListener.html,Interface for listening to part lifecycle events.    This interface may be implemented by clients.    See Also:  IPartService.addPartListener(IPartListener)    
765,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/RetargetAction.html,"An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
extends IAction Interface for a workbench action.    
Interface for listening to part lifecycle events.    This interface may be implemented by clients.    See Also:  IPartService.addPartListener(IPartListener)    
extends PartEventAction implements ActionFactory.IWorkbenchAction A RetargetAction tracks the active part in the workbench.   Each RetargetAction has an ID. If the active part provides an action   handler for the ID the enable and check state of the RetargetAction  is determined from the enable and check state of the handler. If the   active part does not provide an action handler then this action is   disabled.      Note: instances of this class add themselves as listeners to their  action handler. It is important for the creator of a retarget action to call  dispose when the action is no longer needed. This will ensure that the   listener is removed.      This class may be instantiated. It is not intented to be subclassed.    Since:  2.0  Restriction:  This class is not intended to be subclassed by clients.    "
766,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/SaveablesLifecycleEvent.html,extends EventObject Event object describing a change to a set of Saveable objects.  Since:  3.2  See Also:  Serialized Form    
767,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/IWizardRegistry.html,A registry describing all wizard extensions known to the workbench.    This interface is not intended to be implemented by clients.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.    
768,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ResourceWorkingSetFilter.html,extends ViewerFilter A resource working set filter filters resources from a view that   are neither a parent nor children of a working set element.  Since:  2.0    
769,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ltk/core/refactoring/RefactoringContribution.html,extends Object Partial implementation of refactoring contribution objects which are capable  of creating refactoring descriptors or refactoring arguments.    Clients which would like to add refactoring history and refactoring scripting  support to a refactoring are required to register a subclass of  RefactoringContribution with the extension point  org.eclipse.ltk.core.refactoring.refactoringContributions to  participate in the refactoring services. Refactoring contributions are  stateless objects. They are instantiated on demand by the refactoring  framework in the following cases:    When a refactoring script is executed_ the refactoring framework  retrieves a corresponding refactoring contribution for each refactoring  persisted in the script and calls  createDescriptor(String_ String_ String_ String_ Map_ int) with the  appropriate arguments read from the refactoring script to obtain a  language-specific refactoring descriptor. This refactoring descriptor is then  used to dynamically construct the corresponding refactoring object and to  initialize the refactoring object afterwards. The returned refactoring object  is completely initialized and ready to be executed_ ie. by  PerformRefactoringOperation.   After a refactoring has been executed_ the refactoring framework stores  the returned refactoring descriptor into the global refactoring history.  During serialization of the descriptor_ the refactoring framework calls  retrieveArgumentMap(RefactoringDescriptor) of the refactoring  contribution associated with the executed refactoring to obtain a neutral  key-value representation of the state of the language-specific refactoring  descriptor.     Refactorings for which a refactoring contribution has been registered should  also create a RefactoringDescriptor during change generation. Their  Refactoring.createChange(org.eclipse.core.runtime.IProgressMonitor) should  return a change object whose Change.getDescriptor() method returns a  RefactoringChangeDescriptor that encapsulates the RefactoringDescriptor.      Since 3.3_ refactoring contributions may serve also as a uniform API to  expose language-specific refactorings. Clients wishing to provide  customizable refactoring descriptors may reimplement the method  createDescriptor().    Note: Clients which extend this class are required to reimplement the method  retrieveArgumentMap(RefactoringDescriptor) in subclasses to capture  the state of a language-specific refactoring descriptor in a neutral  key-value representation used by the refactoring framework. The default  implementation in this class only handles refactoring descriptors associated  with refactorings for which no corresponding refactoring contribution has  been registered.    Since:  3.2    
770,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ltk/core/refactoring/resource/MoveResourcesDescriptor.html,extends RefactoringDescriptor Refactoring descriptor for the move resource refactoring.    An instance of this refactoring descriptor may be obtained by calling  RefactoringContribution.createDescriptor() on a refactoring  contribution requested by invoking  RefactoringCore.getRefactoringContribution(String) with the  refactoring id (ID).      Note: this class is not intended to be subclassed or instantiated by clients.    Since:  3.4  Restriction:  This class is not intended to be instantiated by clients.    
771,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ltk/core/refactoring/Refactoring.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends PlatformObject Abstract super class for all refactorings. Refactorings are used to perform  behavior-preserving workspace transformations. A refactoring offers two  different kind of methods:  methods to check conditions to determine if the refactoring can be carried out  in general and if transformation will be behavior-preserving.    a method to create a Change object  that represents the actual work space modifications.    The life cycle of a refactoring is as follows:  the refactoring gets created  the refactoring is initialized with the elements to be refactored. It is  up to a concrete refactoring implementation to provide corresponding API.  checkInitialConditions(IProgressMonitor) is called. The method  can be called more than once.  additional arguments are provided to perform the refactoring (for example  the new name of a element in the case of a rename refactoring). It is up  to a concrete implementation to provide corresponding API.  checkFinalConditions(IProgressMonitor) is called. The method  can be called more than once. The method must not be called if  checkInitialConditions(IProgressMonitor) returns a refactoring  status of severity RefactoringStatus.FATAL.  createChange(IProgressMonitor) is called. The method must only be  called once after each call to checkFinalConditions(IProgressMonitor)  and should not be called if one of the condition checking methods  returns a refactoring status of severity RefactoringStatus.FATAL.    steps 4 to 6 can be executed repeatedly (for example when the user goes  back from the preview page).      A refactoring can not assume that all resources are saved before any methods  are called on it. Therefore a refactoring must be able to deal with unsaved  resources.      The class should be subclassed by clients wishing to implement new refactorings.    Since:  3.0  See Also:  RefactoringContext    "
772,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ltk/core/refactoring/PerformRefactoringOperation.html,"A runnable which executes as a batch operation within the workspace.  The IWorkspaceRunnable interface should be implemented  by any class whose instances are intended to be run by  IWorkspace.run.    Clients may implement this interface.    See Also:  IWorkspace.run(IWorkspaceRunnable_ IProgressMonitor)    
extends Object implements IWorkspaceRunnable Operation that_ when run_ executes a refactoring. This includes  condition checking_ change creation_ change execution and remembering  of the undo change on the refactoring's undo stack.    The operation should be executed via the run method offered by  IWorkspace to achieve proper delta batching.      Note: this class is not intended to be extended by clients.    Since:  3.0  See Also:  IWorkspace  Restriction:  This class is not intended to be subclassed by clients.    "
773,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IPage.html,This interface has been replaced by IPageBookViewPage  but is preserved for backward compatibility.    This class is not intended to be directly implemented by clients; clients  should instead subclass Page.    See Also:  PageBookView_  Page  Restriction:  This interface is not intended to be implemented by clients.    
774,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/PageBook.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite A pagebook is a composite control where only a single control is visible  at a time. It is similar to a notebook_ but without tabs.    This class may be instantiated; it is not intended to be subclassed.      Note that although this class is a subclass of Composite_  it does not make sense to set a layout on it.    See Also:  PageBookView  Restriction:  This class is not intended to be subclassed by clients.    "
775,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IPageBookViewPage.html,extends IPage Interface for a page in a pagebook view.    Pages should implement this interface.    See Also:  PageBookView_  Page    
776,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MessagePage.html,"extends IPage Interface for a page in a pagebook view.    Pages should implement this interface.    See Also:  PageBookView_  Page    
extends Page A message page display a message in a pagebook view.    This class may be instantiated; it is not intended to be subclassed.    See Also:  PageBookView  Restriction:  This class is not intended to be subclassed by clients.    "
777,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IViewReference.html,"Implements a reference to a IWorkbenchPart.  The IWorkbenchPart will not be instantiated until the part   becomes visible or the API getPart is sent with true;    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkbenchPartReference Defines a reference to an IViewPart.    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    "
778,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ICellEditorValidator.html,An interface for validating a cell editor's input.    This interface should be implemented by classes that wish to  act as cell editor validators.      
779,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IContributedContentsView.html,This interface is used to identify workbench views which  allow other parts (typically the active part) to supply  their contents.  The interface allows access to the part which contributed the current  contents.    
780,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/help/IWorkbenchHelpSystem.html, The interface that is used to access the workbench help system. Replaces  static methods on WorkbenchHelp.      This interface is not intended to be implemented by clients.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.    
781,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ITabItem.html,Represents a tab to be displayed in the tab list in the tabbed property sheet  page.    
782,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ITabDescriptor.html,"Represents a tab to be displayed in the tab list in the tabbed property sheet  page.    
extends ITabItem Represents a tab descriptor for the tabbed property view.    This interface should not be extended or implemented. New instances should be  created using AbstractTabDescriptor.    Since:  3.4    "
783,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/IOverridableTabList.html,Represents a list of tabs. Used by a section that overrides the tabs that are  provided by the tabbed property registry with a new list of tabs.    The overridable tab list is a content provider that provides both the  sections and the tab labels.  Since:  3.4    
784,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ISection.html,Represents a section of properties for a given input.    The lifecycle of an ISection is as follows:    ISection.createControls()  ISection.setInput()  ISection.aboutToBeShown()  ISection.refresh()  ISection.aboutToBeHidden()  ISection.dispose()      Implementors of this class should be aware that a section instance might be  reused for different input objects (as long as they are valid section  inputs). It means that ISection.setInput can be called at any  time between ISection.createControls and  ISection.dispose.      When an input change event occurs_ such as a tab selection or a workbench  selection change_ an ISection is sent:    ISection.setInput()  ISection.refresh()      When an part activation event occurs_ such as the contributor part activation  event_ an ISection is sent:    ISection.setInput()  ISection.aboutToBeShown()  ISection.refresh()  ISection.setInput()  ISection.refresh()  This is because both a tab selection event and an input selection event have  occurred.      This interface should not be extended or implemented. New section instances  should be created using AbstractPropertySection.    See Also:  TabbedPropertySheetPage    
785,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/AbstractOverridableTabListPropertySection.html,"Represents a list of tabs. Used by a section that overrides the tabs that are  provided by the tabbed property registry with a new list of tabs.    The overridable tab list is a content provider that provides both the  sections and the tab labels.  Since:  3.4    
Represents a section of properties for a given input.    The lifecycle of an ISection is as follows:    ISection.createControls()  ISection.setInput()  ISection.aboutToBeShown()  ISection.refresh()  ISection.aboutToBeHidden()  ISection.dispose()      Implementors of this class should be aware that a section instance might be  reused for different input objects (as long as they are valid section  inputs). It means that ISection.setInput can be called at any  time between ISection.createControls and  ISection.dispose.      When an input change event occurs_ such as a tab selection or a workbench  selection change_ an ISection is sent:    ISection.setInput()  ISection.refresh()      When an part activation event occurs_ such as the contributor part activation  event_ an ISection is sent:    ISection.setInput()  ISection.aboutToBeShown()  ISection.refresh()  ISection.setInput()  ISection.refresh()  This is because both a tab selection event and an input selection event have  occurred.      This interface should not be extended or implemented. New section instances  should be created using AbstractPropertySection.    See Also:  TabbedPropertySheetPage    
extends AbstractPropertySection implements IOverridableTabList An abstract implementation of a section in a tab that overrides the tabs that  are provided by the tabbed property registry with a new list of tabs.  Since:  3.4    "
786,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/TabContents.html,extends Object A property tab is composed by one or more property sections and is used to  categorize sections.  Since:  3.4    
787,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ITypeMapper.html,Allows property sheet page contributors to map the input object type to a  domain model type. The domain model type is then used for matching against  the input attribute of the propertySection extension.    The type mapper is most frequently used to return the type of the model  object when selecting a view object in a workbench part. For example_ nodes  in a tree may all be TreeObjects in a structured selection. The type mapper  will take the tree node and return the type of the model object the node  represents.      This interface should not be extended or implemented. New type mapper instances  should be created using AbstractTypeMapper.      
788,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/TabbedPropertySheetWidgetFactory.html,extends FormToolkit A FormToolkit customized for use by tabbed property sheet page.    
789,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Canvas.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class provide a surface for drawing  arbitrary graphics.  Styles:  (none)  Events:  (none)    This class may be subclassed by custom control implementors  who are building controls that are not constructed  from aggregates of other controls. That is_ they are either  painted using SWT graphics calls or are handled by native  methods.    See Also:  Composite_  Canvas snippets_  SWT Example: ControlExample_  Sample code and further information    "
790,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ISectionDescriptor.html,Represents a section descriptor on the tabbed property sections extensions.    This interface should not be extended or implemented. New instances should be  created using AbstractSectionDescriptor.      
791,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/AbstractTabDescriptor.html,"Represents a tab to be displayed in the tab list in the tabbed property sheet  page.    
extends ITabItem Represents a tab descriptor for the tabbed property view.    This interface should not be extended or implemented. New instances should be  created using AbstractTabDescriptor.    Since:  3.4    
Represents a tab to be displayed in the tab list in the tabbed property sheet  page.    
extends Object implements ITabDescriptor_ Cloneable An abstract implementation of a tab descriptor for the tabbed property view.  Since:  3.4    "
792,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/IActionProvider.html,Allows a tabbed properties view to make contributions to action bars.    An action provider is called when the tabbed properties view becomes the  active view. It is at this point where the action provider can override the  action bars.      Normally TabbedPropertySheetPage.setActionBars(IActionBars) is  sufficient_ but this is only called once and is not sufficient for a  contributor that is selection based. An example is the Project Explorer where  different providers contribute different action sets and properties  configurations.      The most frequent use of setActionBars() is to retarget the global actions  for undo and redo based on the active tabbed properties view contributor.    Since:  3.2.1    
793,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ITabbedPropertySheetPageContributor.html,Interface for a workbench part to contribute content to the tabbed property  view.    It is expected that the contributor ID is unique for a configuration of tabs  and sections. Editors and views can share a configuration by sharing a  contributor ID. Editors and views cannot share tabs and sections from  multiple contributors.      As a workaround_ if all the elements in a structured selection implement  ITabbedPropertySheetPageContributor and they all return the same unique  contributor ID_ then that configuration of tabs and sections will be used by  the tabbed property view for that selection.      
794,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/ole/win32/OleClientSite.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite OleClientSite provides a site to manage an embedded OLE Document within a container.  The OleClientSite provides the following capabilities:    creates the in-place editor for a blank document or opening an existing OLE Document    lays the editor out    provides a mechanism for activating and deactivating the Document    provides a mechanism for saving changes made to the document    This object implements the OLE Interfaces IUnknown_ IOleClientSite_ IAdviseSink_   IOleInPlaceSite   Note that although this class is a subclass of Composite_  it does not make sense to add Control children to it_  or set a layout on it.      Styles   BORDER     Events   Dispose_ Move_ Resize    See Also:  OLE and ActiveX snippets_  SWT Examples: OLEExample_ OleWebBrowser    "
795,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/ole/win32/OleAutomation.html,"extends Object OleAutomation provides a generic mechanism for accessing functionality that is   specific to a particular ActiveX Control or OLE Document.  The OLE Document or ActiveX Control must support the IDispatch interface in order to provide  OleAutomation support. The additional functionality provided by the OLE Object is specified in   its IDL file. The additional methods can either be to get property values (getProperty)_   to set property values (setProperty) or to invoke a method (invoke or  invokeNoReply). Arguments are passed around in the form of Variant   objects.   Here is a sample IDL fragment:    interface IMyControl : IDispatch  {  [propget_ id(0)] HRESULT maxFileCount([retval_ out] int *c);  [propput_ id(0)] HRESULT maxFileCount([in] int c);  [id(1)] HRESULT AddFile([in] BSTR fileName);  };    An example of how to interact with this extended functionality is shown below:    OleAutomation automation = new OleAutomation(myControlSite);  // Look up the ID of the maxFileCount parameter  int[] rgdispid = automation.getIDsOfNames(new String[]{""maxFileCount""});  int maxFileCountID = rgdispid[0];  // Set the property maxFileCount to 100:  if (automation.setProperty(maxFileCountID_ new Variant(100))) {  System.out.println(""Max File Count was successfully set."");  }  // Get the new value of the maxFileCount parameter:  Variant pVarResult = automation.getProperty(maxFileCountID);  if (pVarResult != null) {  System.out.println(""Max File Count is ""+pVarResult.getInt());  }  // Invoke the AddFile method  // Look up the IDs of the AddFile method and its parameter  rgdispid = automation.getIDsOfNames(new String[]{""AddFile""_ ""fileName""});   int dispIdMember = rgdispid[0];  int[] rgdispidNamedArgs = new int[] {rgdispid[1]};  // Convert arguments to Variant objects  Variant[] rgvarg = new Variant[1];  String fileName = ""C:\\testfile"";  rgvarg[0] = new Variant(fileName);  // Call the method  Variant pVarResult = automation.invoke(dispIdMember_ rgvarg_ rgdispidNamedArgs);  // Check the return value  if (pVarResult == null || pVarResult.getInt() != OLE.S_OK){  System.out.println(""Failed to add file ""+fileName);  }  automation.dispose();    See Also:  OLE and ActiveX snippets_  SWT Examples: OLEExample_ OleWebBrowser    "
796,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/ole/win32/Variant.html,extends Object A Variant is a generic OLE mechanism for passing data of different types via a common interface.  It is used within the OleAutomation object for getting a property_ setting a property or invoking  a method on an OLE Control or OLE Document.    
797,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/SaveAsDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends TitleAreaDialog A standard ""Save As"" dialog which solicits a path from the user. The  getResult method returns the path. Note that the folder  at the specified path might not exist and might need to be created.    This class may be instantiated; it is not intended to be subclassed.    See Also:  ContainerGenerator  Restriction:  This class is not intended to be subclassed by clients.    "
798,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/Action.html,"An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
extends AbstractAction implements IAction The standard abstract implementation of an action.    Subclasses must implement the IAction.run method to carry out  the action's semantics.      "
799,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/SubActionBars.html,"Used by a part to access its menu_ toolbar_ and status line managers.     Within the workbench each part_ editor or view_ has a private set of action  bars. This set_ which contains a menu_ toolbar_ and status line_ appears  in the local toolbar for a view and in the window for an editor. The view  may provide an implementation for pre-existing actions or add new actions to  the action bars.    In a workbench window there are a number of actions which are applicable to  all parts. Some common examples are CUT_ COPY and   PASTE. These actions_ known as ""global actions""_ are contributed to   the workbench window by the window itself and shared by all parts. The  presentation is owned by the window. The implementation is delegated to the  active part.     To participate in the global action design an IWorkbenchPart should   register a handler for each global action which is implemented by the part. This   can be done by calling setGlobalActionHandler. For convenience_ the   standard global actions are defined in   org.eclipse.ui.IWorkbenchActionConstants.     Additional work is required for the Delete global action. In  this case the accelerator is defined in the menu item text but is not hooked   on the window. This is to support text editors where the Delete   key is functional even when the Delete action is disabled (no text   is selected). An implementation for this accelerator must be defined locally_   in each part_ by listening for Delete key events.    A part may also contribute new actions to the action bars as required. To do  this_ call getMenuManager_ getToolBarManager_ or  getStatusLineManager as appropriate to get the action target.  Add the action(s) to the target and call update to commit  any changes to the underlying widgets.    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    
extends EventManager implements IActionBars Generic implementation of the IActionBars interface.    "
800,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/WindowManager.html,extends Object A manager for a group of windows. Window managers are an optional JFace   feature used in applications which create many different windows (dialogs_  wizards_ etc.) in addition to a main window. A window manager can be used to  remember all the windows that an application has created (independent of   whether they are presently open or closed). There can be several window  managers_ and they can be arranged into a tree. This kind of organization   makes it simple to close whole subgroupings of windows.    Creating a window manager is as simple as creating an instance of   WindowManager. Associating a window with a window manager is   done with WindowManager.add(Window). A window is automatically  removed from its window manager as a side effect of closing the window.    See Also:  Window    
801,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/AbstractPresentationFactory.html,extends Object This is a factory for presentation objects that control the appearance of  editors_ views and other components in the workbench.  Since:  3.0    
802,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/ContributionComparator.html,extends ViewerComparator implements Comparator A ContributionComparator is capable of ordering  IComparableContribution instances_ either as a  ViewerComparator (for StructuredViewers) or as a traditional  Comparator.    This class orders contributions by first grouping by priority (IComparableContribution.getPriority())  and then by utilizing the JFace policy comparator to order by label (IComparableContribution.getLabel()).  Since:  3.4  See Also:  IComparableContribution    
803,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/intro/IIntroManager.html,Manages the intro part that introduces the product to new users.  The intro part is typically shown the first time a product is started up.    The initial behavior of the intro part is controlled by the application  from via the WorkbenchWindowAdvisor.openIntro()  method.      See IIntroPart for details on where intro parts  come from.      This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  IWorkbench.getIntroManager()  Restriction:  This interface is not intended to be implemented by clients.    
804,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/KeySequence.html,extends Object implements Comparable  A KeySequence is defined as a list of zero or more  KeyStrokes_ with the stipulation that all  KeyStroke objects must be complete_ save for the last one_  whose completeness is optional. A KeySequence is said to be  complete if all of its KeyStroke objects are complete.      All KeySequence objects have a formal string representation  available via the toString() method. There are a number of  methods to get instances of KeySequence objects_ including one  which can parse this formal string representation.      All KeySequence objects_ via the format()  method_ provide a version of their formal string representation translated by  platform and locale_ suitable for display to a user.      KeySequence objects are immutable. Clients are not permitted  to extend this class.    Since:  3.0    
805,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IExecutionListener.html, A listener to the execution of commands. This listener will be notified if a  command is about to execute_ and when that execution completes. It is not  possible for the listener to prevent the execution_ only to respond to it in  some way.    Since:  3.1    
806,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/UIElement.html,extends Object Allow a command or application to provide feedback to a user through updating  a MenuItem or ToolItem. Initially used to update properties for UI elements  created by the CommandContributionItem.    This class may be extended by clients.    Since:  3.3    
807,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/contexts/IContextManagerListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of IContextManager.    This interface may be implemented by clients.    Since:  3.1  See Also:  ContextManager.addContextManagerListener(IContextManagerListener)_  ContextManager.removeContextManagerListener(IContextManagerListener)    
808,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/progress/WorkbenchJob.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends UIJob WorkbenchJob is a type of job that implements a done listener  and does the shutdown checks before scheduling. This is used if   a job is not meant to run when the Workbench is shutdown.  Since:  3.0    "
809,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/preferences/IWorkbenchPreferenceContainer.html,IWorkbenchPreferenceContainer is the class that specifies  the workbench specific preferences support.  Since:  3.1    
810,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/IPreferenceNode.html,Interface to a node in a preference dialog.   A preference node maintains a label and image used to display the  node in a preference dialog (usually in the form of a tree)_   as well as the preference page this node stands for.  The node may use lazy creation for its page  Note that all preference nodes must be dispose their resources.  The node must dispose the page managed by this node_ and any SWT resources  allocated by this node (Images_ Fonts_ etc).  However the node itself may be reused.    
811,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/IPreferencePageContainer.html,An interface used by a preference page to talk to  its dialog.    
812,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferenceDialog.html,"Minimal interface to a page change provider. Used for dialogs which can  switch between multiple pages.  Since:  3.1    
An interface used by a preference page to talk to  its dialog.    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends TrayDialog implements IPreferencePageContainer_ IPageChangeProvider A preference dialog is a hierarchical presentation of preference pages. Each  page is represented by a node in the tree shown on the left hand side of the  dialog; when a node is selected_ the corresponding page is shown on the right  hand side.    "
813,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/IControlContentAdapter.html,This interface is used to set and retrieve text content from an arbitrary  control. Clients are expected to implement this interface when defining a  ContentProposalAdapter_ in order to specify how to retrieve and set  the contents of the control being adapted.  Since:  3.2    
814,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/IContentProposalProvider.html,IContentProposalProvider provides an array of IContentProposals that are  appropriate for a textual dialog field_ given the field's current content and  the current cursor position.  Since:  3.2  See Also:  SimpleContentProposalProvider    
815,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/IControlCreator.html,This interface is used to create a control with a specific parent and style  bits. It is used by DecoratedField to create the control to be  decorated. Clients are expected to implement this interface in order to  create a particular kind of control for decoration.  Since:  3.2    
816,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/State.html,extends EventManager  A piece of state information that can be shared between objects_ and might be  persisted between sessions. This can be used for commands that toggle between  two states and wish to pass this state information between different  handlers.      This state object can either be used as a single state object shared between  several commands_ or one state object per command -- depending on the needs  of the application.      Clients may instantiate or extend this class.    Since:  3.2    
817,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICommand.html,extends Comparable  An instance of ICommand is a handle representing a command as  defined by the extension point org.eclipse.ui.commands. The  identifier of the handle is identifier of the command being represented.      An instance of ICommand can be obtained from an instance of  ICommandManager for any identifier_ whether or not a command  with that identifier defined in the plugin registry.      The handle-based nature of this API allows it to work well with runtime  plugin activation and deactivation. If a command is defined_ that means that  its corresponding plug-in is active. If the plug-in is then deactivated_ the  command will still exist but it will be undefined. An attempts to use an  undefined command will result in a NotDefinedException being  thrown.      This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  ICommandListener_  ICommandManager_  Command  Restriction:  This interface is not intended to be implemented by clients.    
818,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/help/IHelp.html,Former interface to the help system UI.    
819,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILightweightLabelDecorator.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider The ILightweightLabelDecorator is a decorator that decorates  using a prefix_ suffix and overlay image rather than doing all   of the image and text management itself like an ILabelDecorator.    "
820,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/signedcontent/SignedContentFactory.html,A factory used to create SignedContent objects.    The framework will register a factory implementation as an OSGi service.  This service can be used to get SignedContent for a bundle.  It can also be used to get SignedContent for a repository file.  The supported formats for file repositories are jar files and directories containing the   content of an extracted jar.      This interface is not intended to be implemented by clients.    Since:  3.4  Restriction:  This interface is not intended to be implemented by clients.    
821,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/signedcontent/SignedContent.html,A SignedContent object represents content which may be signed. A  SignedContentFactory is used to create signed content objects.    A SignedContent object is intended to provide information about   the signers of the content_ and cannot be used to access the actual data of the content.      This interface is not intended to be implemented by clients.    Since:  3.4  Restriction:  This interface is not intended to be implemented by clients.    
822,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FillLayout.html,extends Layout FillLayout is the simplest layout class. It lays out   controls in a single row or column_ forcing them to be the same size.     Initially_ the controls will all be as tall as the tallest control_   and as wide as the widest. FillLayout does not wrap_   but you can specify margins and spacing. You might use it to   lay out buttons in a task bar or tool bar_ or to stack checkboxes   in a Group. FillLayout can also be used   when a Composite only has one child. For example_   if a Shell has a single Group child_   FillLayout will cause the Group to   completely fill the Shell (if margins are 0).      Example code: first a FillLayout is created and  its type field is set_ and then the layout is set into the   Composite. Note that in a FillLayout_  children are always the same size_ and they fill all available space.    FillLayout fillLayout = new FillLayout();  fillLayout.type = SWT.VERTICAL;  shell.setLayout(fillLayout);      See Also:  SWT Example: LayoutExample_  Sample code and further information    
823,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/IPreferencesService.html,The preference service provides facilities for dealing with the default scope  precedence lookup order_ querying the preference store for values using this order_  accessing the root of the preference store node hierarchy_ and importing/exporting  preferences.    The default-default preference search look-up order as defined by the platform  is: project_ instance_ configuration_ default.    This interface is not intended to be implemented by clients.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
824,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/about/InstallationPage.html,"Interface for a page in a multi-page dialog.    
Minimal interface to a message provider. Used for dialog pages which can  provide a message with an icon.  Since:  2.0    
extends DialogPage Abstract base implementation for an installation dialog page.    Clients should extend this class and include the name of the subclass in an  extension contributed to the workbench's installation pages extension point  (named ""org.eclipse.ui.installationPages""). For example_ the  plug-in's XML markup might contain:      <extension point=""org.eclipse.ui.installationPages"">  <page id=""com.example.myplugin.installInfo""  name=""Example Details""  class=""com.example.myplugin.MyInstallationPage"" />  </extension>        Since:  3.5    "
825,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISelectionListener.html,extends EventListener Interface for listening to selection changes.    This interface may be implemented by clients.    See Also:  ISelectionService.addSelectionListener(ISelectionListener)_  ISelectionService.addSelectionListener(String_ ISelectionListener)_  INullSelectionListener    
826,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/IWorkingSetEditWizard.html,"Interface for a wizard. A wizard maintains a list of wizard pages_  stacked on top of each other in card layout fashion.    The class Wizard provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if Wizard does not suit their needs.    See Also:  Wizard    
extends IWizard A working set edit wizard allows editing a working set using  the IWorkingSetPage associated with the working set.  See the org.eclipse.ui.workingSets extension point for details.    Use org.eclipse.ui.IWorkingSetManager#createWorkingSetEditWizard(IWorkingSet)  to create an instance of this wizard.      This interface is not intended to be implemented by clients.    Since:  2.1  See Also:  IWorkingSetManager  Restriction:  This interface is not intended to be implemented by clients.    "
827,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/IWorkingSetPage.html,"Interface for a page in a multi-page dialog.    
extends IDialogPage Interface for a wizard page.    The class WizardPage provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if WizardPage does not suit their needs.      
extends IWizardPage A working set page allows the user to edit an existing   working set and create a new working set.    Clients should implement this interface and include the   name of their class in an extension contributed to the   workbench's working set extension point   (named ""org.eclipse.ui.workingSets"") if they   want to provide a special wizard page for a particular   working set element type.      Clients implementing this interface may subclass from   org.eclipse.jface.wizard.WizardPage.    Since:  2.0    "
828,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/IWorkingSetNewWizard.html,"Interface for a wizard. A wizard maintains a list of wizard pages_  stacked on top of each other in card layout fashion.    The class Wizard provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if Wizard does not suit their needs.    See Also:  Wizard    
extends IWizard A working set new wizard allows creating new working sets using  a plug-in specific working set page.    Use org.eclipse.ui.IWorkingSetManager#createWorkingSetNewWizard(String[] workingSetIds)  to create an instance of this wizard.      This interface is not intended to be implemented by clients.    Since:  3.1  See Also:  IWorkingSetManager_  IWorkingSetPage  Restriction:  This interface is not intended to be implemented by clients.    "
829,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkingSetUpdater.html,An IWorkingSetUpdater can be used to dynamically update  the content of a working set.     A working set updater manages a set of working sets. It is contributed  via the attribute updaterClass of the   org.eclipse.ui.workingSets extension point. Extensions of this  extension point must therefore implement this interface.      API under construction and subject to change at any time.    Since:  3.1    
830,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkingSetElementAdapter.html, Interface that describes a mechanism that may be provided by working set  extensions to help manage the addition of elements to working sets. Instances  of this class are capable of transforming possible working set content into  the most applicable form.        Usage of this interface is achieved via the elementAdapterClass  attribute of the org.eclipse.ui.workingSets extension point.  Usage of this interface in org.eclipse.ui.workingSets  extensions is optional.    Since:  3.3    
831,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/WorkingSetFilterActionGroup.html,extends ActionGroup Adds working set filter actions (set / clear / edit)  Since:  2.1    
832,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/CommandEvent.html,extends AbstractNamedHandleEvent An instance of this class describes changes to an instance of  Command.    This class is not intended to be extended by clients.    Since:  3.1  See Also:  ICommandListener.commandChanged(CommandEvent)    
833,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICommandImageService.html," The interface that should be implemented by services that make themselves  available through the IAdaptable mechanism. This is the  interface that drives the majority of services provided at the workbench  level.      A service has life-cycle. When the constructor completes_ the service must be  fully functional. When it comes time for the service to go away_ then the  service will receive a dispose() call. At this point_ the service  must release all resources and detach all listeners. A service can only be  disposed once; it cannot be reused.      This interface has nothing to do with OSGi services.      This interface can be extended or implemented by clients.    Since:  3.2    
extends IDisposable  Provides a look-up facility for images associated with commands.      The type of an image indicates the state of the associated command  within the user interface. The supported types are: TYPE_DEFAULT  (to be used for an enabled command)_ TYPE_DISABLED (to be used  for a disabled command) and TYPE_HOVER (to be used for an  enabled command over which the mouse is hovering).      The style of an image is an arbitrary string used to distinguish  between sets of images associated with a command. For example_ a command may  appear in the menus as the default style. However_ in the toolbar_ the  command is simply the default action for a toolbar drop down item. As such_  perhaps a different image style is appropriate. The classic case is the ""Run  Last Launched"" command_ which appears in the menu and the toolbar_ but with  different icons in each location.      We currently support a default image style (none) and an image style of  IMAGE_STYLE_TOOLBAR.    Since:  3.4  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
834,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IActionBars2.html,"Used by a part to access its menu_ toolbar_ and status line managers.     Within the workbench each part_ editor or view_ has a private set of action  bars. This set_ which contains a menu_ toolbar_ and status line_ appears  in the local toolbar for a view and in the window for an editor. The view  may provide an implementation for pre-existing actions or add new actions to  the action bars.    In a workbench window there are a number of actions which are applicable to  all parts. Some common examples are CUT_ COPY and   PASTE. These actions_ known as ""global actions""_ are contributed to   the workbench window by the window itself and shared by all parts. The  presentation is owned by the window. The implementation is delegated to the  active part.     To participate in the global action design an IWorkbenchPart should   register a handler for each global action which is implemented by the part. This   can be done by calling setGlobalActionHandler. For convenience_ the   standard global actions are defined in   org.eclipse.ui.IWorkbenchActionConstants.     Additional work is required for the Delete global action. In  this case the accelerator is defined in the menu item text but is not hooked   on the window. This is to support text editors where the Delete   key is functional even when the Delete action is disabled (no text   is selected). An implementation for this accelerator must be defined locally_   in each part_ by listening for Delete key events.    A part may also contribute new actions to the action bars as required. To do  this_ call getMenuManager_ getToolBarManager_ or  getStatusLineManager as appropriate to get the action target.  Add the action(s) to the target and call update to commit  any changes to the underlying widgets.    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    
extends IActionBars Interface extention to IActionBars that provides an additional  cool bar manager.  Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    "
835,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/SubMenuManager.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
A contribution manager organizes contributions to such UI components  as menus_ toolbars and status lines.    A contribution manager keeps track of a list of contribution  items. Each contribution item may has an optional identifier_ which can be used  to retrieve items from a manager_ and for positioning items relative to  each other. The list of contribution items can be subdivided into named groups   using special contribution items that serve as group markers.      The IContributionManager interface provides general  protocol for adding_ removing_ and retrieving contribution items.  It also provides convenience methods that make it convenient  to contribute actions. This interface should be implemented  by all objects that wish to manage contributions.      There are several implementions of this interface in this package_  including ones for menus (MenuManager)_  tool bars (ToolBarManager)_  and status lines (StatusLineManager).      
extends IContributionManager_ IContributionItem The IMenuManager interface provides protocol for managing  contributions to a menu bar and its sub menus.  An IMenuManager is also an IContributionItem_  allowing sub-menus to be nested in parent menus.    This interface is internal to the framework; it should not be implemented outside  the framework.      This package provides a concrete menu manager implementation_  MenuManager.    Restriction:  This interface is not intended to be implemented by clients.    
extends SubContributionManager implements IMenuManager A SubMenuManager is used to define a set of contribution  items within a parent manager. Once defined_ the visibility of the entire set can   be changed as a unit.    A client may ask for and make additions to a submenu. The visibility of these items  is also controlled by the visibility of the SubMenuManager.      "
836,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/SubToolBarManager.html,"A contribution manager organizes contributions to such UI components  as menus_ toolbars and status lines.    A contribution manager keeps track of a list of contribution  items. Each contribution item may has an optional identifier_ which can be used  to retrieve items from a manager_ and for positioning items relative to  each other. The list of contribution items can be subdivided into named groups   using special contribution items that serve as group markers.      The IContributionManager interface provides general  protocol for adding_ removing_ and retrieving contribution items.  It also provides convenience methods that make it convenient  to contribute actions. This interface should be implemented  by all objects that wish to manage contributions.      There are several implementions of this interface in this package_  including ones for menus (MenuManager)_  tool bars (ToolBarManager)_  and status lines (StatusLineManager).      
extends IContributionManager The IToolBarManager interface provides protocol for managing  contributions to a tool bar. It extends IContributionManager  but does not declare any new members; it exists only to increase the  readability of code using tool bars.    This package also provides a concrete tool bar manager implementation_  ToolBarManager.      
extends SubContributionManager implements IToolBarManager A SubToolBarManager monitors the additional and removal of   items from a parent manager so that visibility of the entire set can be changed as a  unit.    "
837,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPropertyListener.html,Interface for listening for property changes on an object.    This interface may be implemented by clients.    See Also:  IWorkbenchPart.addPropertyListener(org.eclipse.ui.IPropertyListener)    
838,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/IContextActivation.html,extends org.eclipse.ui.internal.services.IEvaluationResultCache  A token representing the activation of a context. This token can later be  used to cancel that activation. Without this token_ then context will only  become inactive if the component in which the context was activated is  destroyed.      This interface is not intended to be implemented or extended by clients.    Since:  3.1  See Also:  ISources_  ISourceProvider    
839,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/SubContributionItem.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
extends Object implements IContributionItem A SubContributionItem is a wrapper for an IContributionItem.   It is used within a SubContributionManager to control the visibility  of items.    This class is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    "
840,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IActivityManagerListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of IActivityManager.    This interface may be implemented by clients.    Since:  3.0  See Also:  IActivityManager.addActivityManagerListener(IActivityManagerListener)_  IActivityManager.removeActivityManagerListener(IActivityManagerListener)    
841,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IActivityListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of IActivity.    This interface may be implemented by clients.    Since:  3.0  See Also:  IActivity.addActivityListener(IActivityListener)_  IActivity.removeActivityListener(IActivityListener)    
842,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ActivityEvent.html,extends Object An instance of this class describes changes to an instance of   IActivity. This class does not give details as to the   specifics of a change_ only that the given property on the source object has   changed.    This class is not intended to be extended by clients.    Since:  3.0  See Also:  IActivityListener.activityChanged(ActivityEvent)    
843,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ICategoryListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of ICategory.      This interface may be implemented by clients.    Since:  3.0  See Also:  ICategory.addCategoryListener(ICategoryListener)_  ICategory.removeCategoryListener(ICategoryListener)    
844,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/CategoryEvent.html,extends Object An instance of this class describes changes to an instance of   ICategory. This class does not give details as to the   specifics of a change_ only that the given property on the source object has   changed.      This class is not intended to be extended by clients.    Since:  3.0  See Also:  ICategoryListener.categoryChanged(CategoryEvent)    
845,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IIdentifierListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of IIdentifier.    This interface may be implemented by clients.    Since:  3.0  See Also:  IIdentifier.addIdentifierListener(IIdentifierListener)_  IIdentifier.removeIdentifierListener(IIdentifierListener)    
846,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IdentifierEvent.html,extends Object An instance of this class describes changes to an instance of   IIdentifier. This class does not give details as to the   specifics of a change_ only that the given property on the source object has   changed.      This class is not intended to be extended by clients.    Since:  3.0  See Also:  IIdentifierListener.identifierChanged(IdentifierEvent)    
847,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ICategory.html,extends Comparable An instance of this interface is a category as defined by the extension  point org.eclipse.ui.activities.    An instance of this interface can be obtained from an instance of   IActivityManager for any identifier_ whether or not a category   with that identifier is defined in the extension registry.      The handle-based nature of this API allows it to work well with runtime  plugin activation and deactivation_ which can cause dynamic changes to the  extension registry.      This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  IActivityManager  Restriction:  This interface is not intended to be implemented by clients.    
848,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ICategoryActivityBinding.html,extends Comparable An instance of this interface represents a binding between a category and an  activity.      This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  IActivity_  ICategory  Restriction:  This interface is not intended to be implemented by clients.    
849,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ITriggerPointAdvisor.html,The trigger point advisor is a mechanism provided by the workbench that is  consulted whenever code that is considered a trigger point is hit. It is the  role of the advisor to determine what_ if any_ activities should be enabled  as a consequence of this action. The advisor also has the option of vetoing  the operation.  Since:  3.1  See Also:  ITriggerPoint  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
850,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IActivity.html,extends Comparable An instance of this interface is an activity as defined by the extension  point org.eclipse.ui.activities.      An instance of this interface can be obtained from an instance of   IActivityManager for any identifier_ whether or not an activity   with that identifier is defined in the extension registry.        The handle-based nature of this API allows it to work well with runtime  plugin activation and deactivation_ which can cause dynamic changes to the  extension registry. A client may get an IActivity handle that   is currently undefined (isDefined() equals false) and   listen for it to become defined.        This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  IActivityManager  Restriction:  This interface is not intended to be implemented by clients.    
851,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IActivityRequirementBinding.html,extends Comparable An instance of this interface represents a binding between two activities.  The relationship can be interpreted as 'activity needs requiredActivity to   be enabled'.  Enablement of the activity requires enablement of the required activity.       This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  IActivity  Restriction:  This interface is not intended to be implemented by clients.    
852,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IActivityPatternBinding.html,extends Comparable An instance of this interface represents a binding between an activity and a  regular expression pattern. It's typically unnecessary to use this interface   directly. Rather_ clients wishing to test strings against activity patterns  should use instances of IIdentifier.    This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  IActivity_  IIdentifier_  IActivityManager.getIdentifier(String)  Restriction:  This interface is not intended to be implemented by clients.    
853,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/IEvaluationReference.html,extends org.eclipse.ui.internal.services.IEvaluationResultCache A token representing a core expression and property change listener currently  working in the IEvaluationService.  Since:  3.4  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
854,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IMutableActivityManager.html,"An instance of this interface allows clients to manage activities_ as  defined by the extension point org.eclipse.ui.activities.    This interface is not intended to be extended or implemented by clients.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    
extends IActivityManager An instance of this interface allows clients to manage activities_ as  defined by the extension point org.eclipse.ui.activities.    This interface extends IActivityManager by granting the ability   to alter the set of currently enabled activities.      This interface is not intended to be extended or implemented by clients.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    "
855,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ITriggerPointManager.html,Contains a collection of known trigger points. An instance of this class may  be obtained from  IWorkbenchActivitySupport.getTriggerPointManager().    This interface is not intended to be extended or implemented by clients.    Since:  3.1  See Also:  ITriggerPoint  Restriction:  This interface is not intended to be implemented by clients.    
856,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/WorkbenchAdvisor.html,extends Object Public base class for configuring the workbench.    Note that the workbench advisor object is created in advance of creating the  workbench. However_ by the time the workbench starts calling methods on this  class_ PlatformUI.getWorkbench is guaranteed to have been  properly initialized.      Example of creating and running a workbench (in an  IPlatformRunnable):        public class MyApplication implements IPlatformRunnable {  public Object run(Object args) {  WorkbenchAdvisor workbenchAdvisor = new MyWorkbenchAdvisor();  Display display = PlatformUI.createDisplay();  int returnCode = PlatformUI.createAndRunWorkbench(display_ workbenchAdvisor);  if (returnCode == PlatformUI.RETURN_RESTART) {  return IPlatformRunnable.EXIT_RESTART;  } else {  return IPlatformRunnable.EXIT_OK;  }  }            An application should declare a subclass of WorkbenchAdvisor  and override methods to configure the workbench to suit the needs of the  particular application.      The following advisor methods are called at strategic points in the  workbench's lifecycle (all occur within the dynamic scope of the call to  PlatformUI.createAndRunWorkbench):    initialize - called first; before any windows; use to  register things  preStartup - called second; after initialize but before  first window is opened; use to temporarily disable things during startup or  restore  postStartup - called third; after first window is opened;  use to reenable things temporarily disabled in previous step  postRestore - called after the workbench and its windows  has been recreated from a previously saved state; use to adjust the restored  workbench  preWindowOpen - called as each window is being opened;  use to configure aspects of the window other than actions bars   fillActionBars - called after preWindowOpen  to configure a window's action bars  postWindowRestore - called after a window has been  recreated from a previously saved state; use to adjust the restored window  postWindowCreate - called after a window has been  created_ either from an initial state or from a restored state; used to  adjust the window  openIntro - called immediately before a window is opened  in order to create the introduction component_ if any.  postWindowOpen - called after a window has been opened;  use to hook window listeners_ etc.  preWindowShellClose - called when a window's shell is  closed by the user; use to pre-screen window closings  eventLoopException - called to handle the case where the  event loop has crashed; use to inform the user that things are not well  eventLoopIdle - called when there are currently no more  events to be processed; use to perform other work or to yield until new  events enter the queue  preShutdown - called immediately prior to workbench  shutdown before any windows have been closed; allows the advisor to veto the  shutdown  postShutdown - called last; after event loop has  terminated and all windows have been closed; use to deregister things  registered during initialize    Since:  3.0    
857,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/ISchemeListener.html, An instance of ISchemeListener can be used by clients to  receive notification of changes to one or more instances of  IScheme.      This interface may be implemented by clients.    Since:  3.1  See Also:  Scheme.addSchemeListener(ISchemeListener)_  Scheme.removeSchemeListener(ISchemeListener)_  SchemeEvent    
858,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/BindingManager.html,"An instance of this interface can be used by clients to receive notification  of changes to one or more instances of IContextManager.    This interface may be implemented by clients.    Since:  3.1  See Also:  ContextManager.addContextManagerListener(IContextManagerListener)_  ContextManager.removeContextManagerListener(IContextManagerListener)    
 An instance of ISchemeListener can be used by clients to  receive notification of changes to one or more instances of  IScheme.      This interface may be implemented by clients.    Since:  3.1  See Also:  Scheme.addSchemeListener(ISchemeListener)_  Scheme.removeSchemeListener(ISchemeListener)_  SchemeEvent    
extends HandleObjectManager implements IContextManagerListener_ ISchemeListener  A central repository for bindings -- both in the defined and undefined  states. Schemes and bindings can be created and retrieved using this manager.  It is possible to listen to changes in the collection of schemes and bindings  by adding a listener to the manager.      The binding manager is very sensitive to performance. Misusing the manager  can render an application unenjoyable to use. As such_ each of the public  methods states the current run-time performance. In future releases_ it is  guaranteed that the method will run in at least the stated time constraint --  though it might get faster. Where possible_ we have also tried to be memory  efficient.    Since:  3.1    "
859,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICommandListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of ICommand.    This interface may be implemented by clients.    Since:  3.0  See Also:  ICommand.addCommandListener(ICommandListener)_  ICommand.removeCommandListener(ICommandListener)_  ICommandListener    
860,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICommandManagerListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of ICommandManager.    This interface may be implemented by clients.    Since:  3.0  See Also:  ICommandManager.addCommandManagerListener(ICommandManagerListener)_  ICommandManager.removeCommandManagerListener(ICommandManagerListener)_  ICommandManagerListener    
861,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/BindingManagerEvent.html,extends AbstractBitSetEvent An instance of this class describes changes to an instance of  BindingManager.    This class is not intended to be extended by clients.    Since:  3.1  See Also:  IBindingManagerListener.bindingManagerChanged(BindingManagerEvent)    
862,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/CommandManagerEvent.html,extends Object An instance of this class describes changes to an instance of  ICommandManager.    This class is not intended to be extended by clients.    Since:  3.0  See Also:  ICommandManagerListener.commandManagerChanged(CommandManagerEvent)_  CommandManagerEvent    
863,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICategory.html,"extends Comparable  A category is a grouping of commands by functional area. For example_ in the  Eclipse workbench_ ""Text Editing"" is a category containing various commands  related to text editing. A category's primary functionality is to control the  display of commands to the user. When appropriate_ commands displayed to the  user (e.g._ keys preference page) will be grouped by category.      An instance of ICategory is a handle representing a category  as defined by the extension point org.eclipse.ui.commands.  The identifier of the handle is identifier of the category being represented.      An instance of ICategory can be obtained from an instance of  ICommandManager for any identifier_ whether or not a category  with that identifier defined in the plugin registry.      The handle-based nature of this API allows it to work well with runtime  plugin activation and deactivation_ which causes dynamic changes to the  plugin registry_ and therefore_ potentially_ dynamic changes to the set of  category definitions.      This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  ICategoryListener_  ICommandManager_  Category  Restriction:  This interface is not intended to be implemented by clients.    "
864,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IKeyConfiguration.html,extends Comparable  An instance of IKeyConfiguration is a handle representing a  key configuration as defined by the extension point  org.eclipse.ui.commands. The identifier of the handle is  identifier of the key configuration being represented.      An instance of IKeyConfiguration can be obtained from an  instance of ICommandManager for any identifier_ whether or not  a key configuration with that identifier defined in the plugin registry.      The handle-based nature of this API allows it to work well with runtime  plugin activation and deactivation. If a key configuration is defined_ that  means that its corresponding plug-in is active. If the plug-in is then  deactivated_ the configuration will still exist but it will be undefined.  An attempt to use an undefined key configuration will result in a  NotDefinedException being thrown.      This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  IKeyConfigurationListener_  ICommandManager_  Scheme  Restriction:  This interface is not intended to be implemented by clients.    
865,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/commands/PersistentState.html,extends State  This is a state that can be made persistent. A state is persisted to a  preference store.      Clients may extend this class.    Since:  3.2    
866,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IElementUpdater.html,An IHandler for a command that expects to provide feedback through the  registered element mechanism must implement this interface.  Since:  3.3    
867,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IElementReference.html,the ICommandService will return a reference for all callbacks that are  registered. This reference can be used to unregister the specific callback.    Similar in functionality to an IHandlerActivation. This interface should  not be implemented or extended by clients.    Since:  3.3    
868,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IStateListener.html, A listener to changes in some state.      Clients may implement_ but must not extend this interface.    Since:  3.2    
869,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/HandlerSubmission.html,"extends Object implements Comparable  An instance of this class represents a request to handle a command. A handler  submission specifies a list of conditions under which it would be appropriate  for a particular command to have a particular handler. These conditions  include things like the active part or the active shell. So_ it is possible  to say things like: ""when my part is active_ please consider calling these  classes when you want to perform a cut_ copy or paste"".      The workbench considers all of the submissions it has received and choses the  ones it views as the best possible match.      This class is not intended to be extended by clients.      Note: this class has a natural ordering that is inconsistent with equals.    Since:  3.0  See Also:  IWorkbenchCommandSupport_  IHandlerService    "
870,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/handlers/IHandlerActivation.html,extends org.eclipse.ui.internal.services.IEvaluationResultCache_ Comparable  A token representing the activation of a handler. This token can later be  used to cancel that activation. Without this token_ then handler will only  become inactive if the component in which the handler was activated is  destroyed.      This interface is not intended to be implemented or extended by clients.    Since:  3.1  See Also:  ISources_  ISourceProvider    
871,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICommandManager.html, An instance of ICommandManager can be used to obtain instances  of ICommand_ as well as manage whether or not those instances  are active or inactive_ enabled or disabled.      This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  ICommand_  ICommandManagerListener_  CommandManager  Restriction:  This interface is not intended to be implemented by clients.    
872,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/about/ISystemSummarySection.html,Extensions to org.eclipse.ui.systemSummaryExtensions must provide  an implementation of this interface. The class must provide a default  constructor. A new instance of the class will be created each time the system  summary is created.  Since:  3.0    
873,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/IContextService.html," The interface that should be implemented by services that make themselves  available through the IAdaptable mechanism. This is the  interface that drives the majority of services provided at the workbench  level.      A service has life-cycle. When the constructor completes_ the service must be  fully functional. When it comes time for the service to go away_ then the  service will receive a dispose() call. At this point_ the service  must release all resources and detach all listeners. A service can only be  disposed once; it cannot be reused.      This interface has nothing to do with OSGi services.      This interface can be extended or implemented by clients.    Since:  3.2    
extends IDisposable  A service that responds to changes in one or more sources. These sources can  be plugged into the service. Sources represent a common event framework for  services.      Clients must not extend or implement.    Since:  3.2    
extends IServiceWithSources  Provides services related to contexts in the Eclipse workbench. This provides  access to contexts.      This service can be acquired from your service locator:    IContextService service = (IContextService) getSite().getService(IContextService.class);    This service is available globally.    Since:  3.1  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
874,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/DisposeListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the event that is generated when a widget  is disposed.    After creating an instance of a class that implements  this interface it can be added to a widget using the  addDisposeListener method and removed using  the removeDisposeListener method. When a  widget is disposed_ the widgetDisposed method will  be invoked.    See Also:  DisposeEvent    
875,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/IContextListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of IContext.    This interface may be implemented by clients.    Since:  3.0  See Also:  IContext.addContextListener(IContextListener)_  IContext.removeContextListener(IContextListener)_  IContextListener    
876,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/IContextManagerListener.html,An instance of this interface can be used by clients to receive notification  of changes to one or more instances of IContextManager.    This interface may be implemented by clients.    Since:  3.0  See Also:  IContextManager.addContextManagerListener(IContextManagerListener)_  IContextManager.removeContextManagerListener(IContextManagerListener)_  IContextManagerListener    
877,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/ContextManagerEvent.html,extends Object An instance of this class describes changes to an instance of  IContextManager.    This class is not intended to be extended by clients.    Since:  3.0  See Also:  IContextManagerListener.contextManagerChanged(ContextManagerEvent)_  ContextManagerEvent    
878,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/IContext.html,extends Comparable An instance of this interface is an context as defined by the extension point  org.eclipse.ui.contexts.    An instance of this interface can be obtained from an instance of  IContextManager for any identifier_ whether or not an context  with that identifier is defined in the extension registry.      The handle-based nature of this API allows it to work well with runtime  plugin activation and deactivation. If a context is defined_ that means that  its corresponding plug-in is active. If the plug-in is then deactivated_ the  context will still exist but it will be undefined. An attempts to use an  undefined context will result in a NotDefinedException being  thrown.      This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  IContextManager_  Context  Restriction:  This interface is not intended to be implemented by clients.    
879,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISourceProvider.html, A provider of notifications for when a change has occurred to a particular  type of source. These providers can be given to the appropriate service_ and  this service will then re-evaluate the appropriate pieces of its internal  state in response to these changes.      It is recommended that clients subclass AbstractSourceProvider  instead_ as this provides some common support for listeners.    Since:  3.1  See Also:  IHandlerService_  ISources    
880,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/contexts/ContextEvent.html,extends AbstractNamedHandleEvent An instance of this class describes changes to an instance of  IContext.    This class is not intended to be extended by clients.    Since:  3.1  See Also:  IContextListener.contextChanged(ContextEvent)    
881,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/EnabledSubmission.html,"extends Object implements Comparable  An instance of this class represents a request to enabled a context. An  enabled submission specifies a list of conditions under which it would be  appropriate for a particular context to be enabled. These conditions include  things like the active part or the active shell. So_ it is possible to say  things like: ""when the java editor is active_ please consider enabling the  'editing java' context"".      The workbench considers all of the submissions it has received and choses the  ones it views as the best possible match.      This class is not intended to be extended by clients.      Note: this class has a natural ordering that is inconsistent with equals.    Since:  3.0  See Also:  IWorkbenchContextSupport_  IContextService    "
882,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/IContextManager.html, A context manager tracks the sets of defined and enabled contexts within the  application. The manager sends notification events to listeners when these  sets change. It is also possible to retrieve any given context with its  identifier.      This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  ContextManager  Restriction:  This interface is not intended to be implemented by clients.    
883,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ToolBarContributionItem.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
extends ContributionItem implements org.eclipse.jface.internal.provisional.action.IToolBarContributionItem The ToolBarContributionItem class provides a wrapper for tool  bar managers when used in cool bar managers. It extends ContributionItem  but and provides some additional methods to customize the size of the cool  item and to retrieve the underlying tool bar manager.    This class may be instantiated; it is not intended to be subclassed.    Since:  3.0  Restriction:  This class is not intended to be subclassed by clients.    "
884,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/CommandContributionItem.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
extends ContributionItem A contribution item which delegates to a command. It can be used in AbstractContributionFactory.createContributionItems(IServiceLocator_  IContributionRoot).    It currently supports placement in menus and toolbars.      This class may be instantiated; it is not intended to be subclassed.    Since:  3.3  Restriction:  This class is not intended to be subclassed by clients.    "
885,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IDecorationContext.html,A decoration context provides additional information to  a label decorator.    This interface is not intended to be implemented by clients  Since:  3.2  See Also:  LabelDecorator    
886,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/DecorationOverlayIcon.html,extends CompositeImageDescriptor A DecorationOverlayIcon is an image descriptor that can be used  to overlay decoration images on to the 4 corner quadrants of a base image.  The four quadrants are IDecoration.TOP_LEFT_ IDecoration.TOP_RIGHT_  IDecoration.BOTTOM_LEFT and IDecoration.BOTTOM_RIGHT. Additionally_  the overlay can be used to provide an underlay corresponding to IDecoration.UNDERLAY.  Since:  3.3  See Also:  IDecoration    
887,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/StackPresentation.html,extends Object implements ISizeProvider This represents an object that can supply trim around a IPresentablePart.  Clients can implement subclasses to provide the appearance for editor  workbooks_ view folders_ fast views_ and detached windows.    StackPresentations do not store any persistent state and cannot directly make  changes to the workbench. They are given an IStackPresentationSite reference  on creation_ which allows them to send events and requests to the workbench.  However_ the workbench is free to ignore these requests. The workbench will  call one of the public methods on StackPresentation when (and if) the  presentation is expected to change state.      For example_ if the user clicks a button that is intended to close a part_  the StackPresentation will send a close request to its site_ but should not  assume that the part has been closed until the workbench responds with a call  StackPresentation.remove.    Since:  3.0    
888,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/IPresentablePart.html,extends ISizeProvider This is a skin's interface to the contents of a view or editor. Note that  this is essentially the same as IWorkbenchPart_ except it does not provide  access to lifecycle events and allows repositioning of the part.    Not intended to be implemented by clients.  Since:  3.0_ 3.4 now extends ISizeProvider  Restriction:  This interface is not intended to be implemented by clients.    
889,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ComboViewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends AbstractListViewer A concrete viewer based either on an SWT Combo control or CCombo  control. This class is intended as an alternative to the JFace ListViewer_ which displays  its content in a combo box rather than a list. Wherever possible_ this class attempts to behave  like ListViewer.     This class is designed to be instantiated with a pre-existing SWT combo control   and configured with a domain-specific content provider_ label provider_ element  filter (optional)_ and element sorter (optional).    Since:  3.0 (made non-final in 3.4)  See Also:  ListViewer    "
890,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/IViewRegistry.html,The view registry maintains a list of views explicitly registered  against the view extension point..    The description of a given view is kept in a IViewDescriptor.      This interface is not intended to be implemented by clients.    Since:  3.1  See Also:  IViewDescriptor_  IStickyViewDescriptor  Restriction:  This interface is not intended to be implemented by clients.    
891,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/IViewCategory.html,Represents a categorization of views.      This interface is not intended to be implemented by clients.    Since:  3.1    
892,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/IViewDescriptor.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Description of a workbench part. The part descriptor contains   the information needed to create part instances.    This interface is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkbenchPartDescriptor_ IAdaptable This is a view descriptor. It provides a ""description"" of a given  given view so that the view can later be constructed.    The view registry provides facilities to map from an extension  to a IViewDescriptor.      This interface is not intended to be implemented by clients.    Since:  3.1  See Also:  IViewRegistry  Restriction:  This interface is not intended to be implemented by clients.    "
893,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/OpenPerspectiveAction.html,"An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
An interface that descriptor classes may implement in addition to their  descriptor interface. This indicates that they may or may not originate from  a plugin contribution. This is useful in various activity filtering  scenarios.  Since:  3.0    
extends Action implements IPluginContribution Opens a perspective.  Since:  3.1    "
894,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Resource.html,extends Object This class is the abstract superclass of all graphics resource objects.   Resources created by the application must be disposed.    IMPORTANT: This class is intended to be subclassed only  within the SWT implementation. However_ it has not been marked  final to allow those outside of the SWT development team to implement  patched versions of the class in order to get around specific  limitations in advance of when those limitations can be addressed  by the team. Any class built using subclassing to access the internals  of this class will likely fail to compile or run between releases and  may be strongly platform specific. Subclassing should not be attempted  without an intimate and detailed understanding of the workings of the  hierarchy. No support is provided for user-written classes which are  implemented as subclasses of this class.    Since:  3.1  See Also:  dispose()_  isDisposed()_  Sample code and further information    
895,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/EditorSelectionDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends Dialog This class is used to allow the user to select a dialog from the set of  internal and external editors.  Since:  3.3    "
896,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferenceManager.html,extends Object A preference manager maintains a hierarchy of preference nodes and  associated preference pages.    
897,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/IContributionService.html,Instances of this service are capable of providing standard mechanisms that  clients may use to order_ display_ and generally work with contributions to  the Workbench.  Since:  3.4    
898,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/preferences/IWorkingCopyManager.html,IWorkingCopyManager is the interface for the working copy  support for references to shared preference nodes.  Since:  3.1    
899,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/IWizardNode.html,A wizard node acts a placeholder for a real wizard in a wizard   selection page. It is done in such a way that the actual creation  of a wizard can be deferred until the wizard is really needed.    When a wizard node comes into existence_ its wizard may or may  not have been created yet; isContentCreated can  be used to determine which. A node may be asked for its wizard  using getWizard_ which will force it to be created  if required. Once the client is done with a wizard node_ its  disposemethod must be called to free up the wizard;  once disposes_ the node should no longer be used.      This interface should be implemented by clients wishing to  support this kind of wizard placeholder in a wizard selection page.    See Also:  WizardSelectionPage    
900,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferenceNode.html,"Interface to a node in a preference dialog.   A preference node maintains a label and image used to display the  node in a preference dialog (usually in the form of a tree)_   as well as the preference page this node stands for.  The node may use lazy creation for its page  Note that all preference nodes must be dispose their resources.  The node must dispose the page managed by this node_ and any SWT resources  allocated by this node (Images_ Fonts_ etc).  However the node itself may be reused.    
extends Object implements IPreferenceNode A concrete implementation of a node in a preference dialog tree. This class  also supports lazy creation of the node's preference page.    "
901,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IActionFilter.html,An adapter which performs action filtering.    Within the workbench a plugin may extend the actions which appear in the  context menu for any object. The visibility of each action extension is controlled  by action filtering. By default_ the workbench will filter each action extension using   the objectClass and optional nameFilter attributes defined  in xml. If the action extension passes this test the action will be added to the   context menu for the object.       In some situations the object class and name are not enough to describe the intended  target action. In those situations an action extension may define one or more   filter sub-elements. Each one of these elements describes one attribute of   the action target using a name value pair. The attributes for an object   are type specific and beyond the domain of the workbench itself_ so the workbench   will delegate filtering at this level to an IActionFilter. This is a   filtering strategy which is provided by the selection itself and may perform type   specific filtering.      The workbench will retrieve the filter from the selected object by testing to see  if it implements IActionFilter. If that fails_ the workbench will ask for  a filter through through the IAdaptable mechanism. If a filter is  found the workbench will pass each name value pair to the filter to determine if it   matches the state of the selected object. If so_ or there is no filter_ the action   will be added to the context menu for the object.       Clients that implement this filter mechanism are strongly encouraged to extend this  interface to provide a list of attribute names and possible values that are  considered public for other clients to reference.    See Also:  IAdaptable    
902,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/PatternFilter.html,extends ViewerFilter A filter used in conjunction with FilteredTree. In order to  determine if a node should be filtered it uses the content and label provider  of the tree to do pattern matching on its children. This causes the entire  tree structure to be realized. Note that the label provider must implement  ILabelProvider.  Since:  3.2  See Also:  FilteredTree    
903,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ICheckStateProvider.html,Interface to provide checked and grayed state information about data in trees  or tables. The following chart determines the checkbox state:  isGrayed()  false true  isChecked() false unchecked  true checked grayed  Since:  3.5    
904,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPreferencePage.html,"Interface for a page in a multi-page dialog.    
extends IDialogPage An interface for a preference page. This interface  is used primarily by the page's container    
extends IPreferencePage Interface for workbench preference pages.    Clients should implement this interface and include the name of their class  in an extension contributed to the workbench's preference extension point   (named ""org.eclipse.ui.preferencePages"").  For example_ the plug-in's XML markup might contain:    <extension point=""org.eclipse.ui.preferencePages"">  <page id=""com.example.myplugin.prefs""  name=""Knobs""  class=""com.example.myplugin.MyPreferencePage"" />  </extension>        "
905,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/SelectionEnabler.html,"extends Object Determines the enablement status given a selection. This calculation is done  based on the definition of the enablesFor attribute_  enablement element_ and the selection element  found in the IConfigurationElement provided.    This class can be instantiated by clients. It is not intended to be extended.    Since:  3.0    Note: The dependency on org.eclipse.jface.text for ITextSelection must be  severed It may be possible to do with IActionFilter generic workbench  registers IActionFilter for ""size"" property against IStructuredSelection  workbench text registers IActionFilter for ""size"" property against  ITextSelection code here: sel.getAdapter(IActionFilter.class) As an interim  solution_ use reflection to access selections implementing ITextSelection    "
906,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MultiEditorInput.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable IEditorInput is a light weight descriptor of editor input_  like a file name but more abstract. It is not a model. It is a description of  the model source for an IEditorPart.    Clients implementing this editor input interface should override  Object.equals(Object) to answer true for two inputs that are  the same. The IWorbenchPage.openEditor APIs are dependent on  this to find an editor with the same input.      Clients should extend this interface to declare new types of editor inputs.      An editor input is passed to an editor via the IEditorPart.init  method. Due to the wide range of valid editor inputs_ it is not possible to  define generic methods for getting and setting bytes.      Editor input must implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.      Please note that it is important that the editor input be light weight.  Within the workbench_ the navigation history tends to hold on to editor  inputs as a means of reconstructing the editor at a later time. The  navigation history can hold on to quite a few inputs (i.e._ the default is  fifty). The actual data model should probably not be held in the input.    See Also:  IEditorPart_  IWorkbenchPage.openEditor(IEditorInput_ String)_  IWorkbenchPage.openEditor(IEditorInput_ String_ boolean)    
extends Object implements IEditorInput Implements an input for a AbstractMultiEditor.    This class is intended to be instantiated by clients but is   not intended to be subclassed.  Restriction:  This class is not intended to be subclassed by clients.    "
907,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/ESelectionService.html,This interface describes the workbench selection service  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.    
908,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IViewLayout.html,Represents the layout info for a view or placeholder in an IPageLayout.    This interface is not intended to be implemented by clients.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    
909,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/SubContributionManager.html,"A contribution manager organizes contributions to such UI components  as menus_ toolbars and status lines.    A contribution manager keeps track of a list of contribution  items. Each contribution item may has an optional identifier_ which can be used  to retrieve items from a manager_ and for positioning items relative to  each other. The list of contribution items can be subdivided into named groups   using special contribution items that serve as group markers.      The IContributionManager interface provides general  protocol for adding_ removing_ and retrieving contribution items.  It also provides convenience methods that make it convenient  to contribute actions. This interface should be implemented  by all objects that wish to manage contributions.      There are several implementions of this interface in this package_  including ones for menus (MenuManager)_  tool bars (ToolBarManager)_  and status lines (StatusLineManager).      
extends Object implements IContributionManager A SubContributionManager is used to define a set of contribution  items within a parent manager. Once defined_ the visibility of the entire set can   be changed as a unit.    "
910,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IActionDelegate.html,Interface for actions contributed via an extension point.    This interface should be implemented by clients who need to contribute actions  via an extension point. The workbench will generate a proxy action   object on behalf of the plug-in to avoid having to activate the plug-in until   the user needs it. If the action is performed the workbench will load the class   that implements this interface and create what is called an action   delegate object. Then the request_ and all subsequent ones_ are  forwarded through the proxy action to the action delegate_ which does the  real work.     The proxy action is the one that appears in the UI_ so the action delegate   will need to talk to the proxy action in order to keep up an appropriate   appearance. Once the action delegate has been created_ it will be  notified of all selection changes_ allowing it to enable or disable the   proxy action appropriately.    An action delegate cannot be consulted about selection changes before the  action is performed because it does not exist. For this reason_ control of  the action's enable state should also be exercised through simple XML rules  contained in the extension. These rules allow enable state control before  the action delegate's plug-in is loaded.    Clients can choose to subclass the provided abstract implementation  org.eclipse.ui.actions.ActionDelegate or implement the  interface directly.    See Also:  ActionDelegate_  IActionDelegate2    
911,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExtensionDelta.html,An extension delta represents changes to the extension registry.    This interface can be used without OSGi running.    This interface is not intended to be implemented by clients.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    
912,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/themes/ITheme.html,A theme is a collection of colors_ fonts and supporting data that may   be used by plugins to help provide uniform look and feel to their components.  The workbench has a default theme (one whos id has the value IThemeManager.DEFAULT_THEME)   that defines the initial values for a collection of fonts and colors. Other  themes may extend and override the default theme to provide new values.      Clients may obtain themes via IThemeManager.getTheme(String).        This interface is not intended to be implemented or extended by clients.    Since:  3.0  See Also:  IWorkbench.getThemeManager()  Restriction:  This interface is not intended to be implemented by clients.    
913,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchWindowActionDelegate.html,"Interface for actions contributed via an extension point.    This interface should be implemented by clients who need to contribute actions  via an extension point. The workbench will generate a proxy action   object on behalf of the plug-in to avoid having to activate the plug-in until   the user needs it. If the action is performed the workbench will load the class   that implements this interface and create what is called an action   delegate object. Then the request_ and all subsequent ones_ are  forwarded through the proxy action to the action delegate_ which does the  real work.     The proxy action is the one that appears in the UI_ so the action delegate   will need to talk to the proxy action in order to keep up an appropriate   appearance. Once the action delegate has been created_ it will be  notified of all selection changes_ allowing it to enable or disable the   proxy action appropriately.    An action delegate cannot be consulted about selection changes before the  action is performed because it does not exist. For this reason_ control of  the action's enable state should also be exercised through simple XML rules  contained in the extension. These rules allow enable state control before  the action delegate's plug-in is loaded.    Clients can choose to subclass the provided abstract implementation  org.eclipse.ui.actions.ActionDelegate or implement the  interface directly.    See Also:  ActionDelegate_  IActionDelegate2    
extends IActionDelegate Interface for an action that is contributed into the workbench window menu   or tool bar. It extends IActionDelegate and adds an  initialization method for connecting the delegate to the workbench window it  should work with.    "
914,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IActionDelegate2.html,"Interface for actions contributed via an extension point.    This interface should be implemented by clients who need to contribute actions  via an extension point. The workbench will generate a proxy action   object on behalf of the plug-in to avoid having to activate the plug-in until   the user needs it. If the action is performed the workbench will load the class   that implements this interface and create what is called an action   delegate object. Then the request_ and all subsequent ones_ are  forwarded through the proxy action to the action delegate_ which does the  real work.     The proxy action is the one that appears in the UI_ so the action delegate   will need to talk to the proxy action in order to keep up an appropriate   appearance. Once the action delegate has been created_ it will be  notified of all selection changes_ allowing it to enable or disable the   proxy action appropriately.    An action delegate cannot be consulted about selection changes before the  action is performed because it does not exist. For this reason_ control of  the action's enable state should also be exercised through simple XML rules  contained in the extension. These rules allow enable state control before  the action delegate's plug-in is loaded.    Clients can choose to subclass the provided abstract implementation  org.eclipse.ui.actions.ActionDelegate or implement the  interface directly.    See Also:  ActionDelegate_  IActionDelegate2    
extends IActionDelegate Interface extension to IActionDelegate adding lifecycle methods.  In addition_ a runWithEvent method that includes the triggering  SWT event.    An action delegate that implements this interface will have its  runWithEvent(IAction_ Event) called instead of its  run(IAction) method.    Clients should implement this interface_ in addition to  IActionDelegate or sub-interfaces_ if interested in the  triggering event or in the lifecycle of the delegate object.    Clients can choose to subclass the provided abstract implementation  org. eclipse. ui. actions. ActionDelegate or implement the  interface directly.    Since:  2.1  See Also:  ActionDelegate_  IActionDelegate    "
915,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IActionDelegateWithEvent.html,This interface is a mixin interface for action delegates_ adding the ability to  examine the triggering SWT event when it is run.  If an action delegate implements this interface_ then runWithEvent(IAction_ Event)  is called instead of run(IAction).    Clients should implement this interface_ in addition to IActionDelegate   (or subinterface)_ if they need to examine the triggering event.  Otherwise_ they should simply implement IActionDelegate (or subinterface).    Since:  2.0    
916,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/PageSwitcher.html,extends Object Provides the implementation for switching pages in a view. A view may track  pages however it wishes. The view should subclass PageSwitcher to provide the  abstract methods_ and then instantiate their page switcher once.  Since:  3.4    
917,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/WorkbenchPart.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
extends EventManager implements IWorkbenchPart3_ IExecutableExtension_ IWorkbenchPartOrientation Abstract base implementation of all workbench parts.    This class is not intended to be subclassed by clients outside this  package; clients should instead subclass ViewPart or  EditorPart.    See Also:  ViewPart_  EditorPart  Restriction:  This class is not intended to be subclassed by clients.    "
918,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/HandlerEvent.html,extends Object An instance of this class describes changes to an instance of  IHandler.    This class is not intended to be extended by clients.    Since:  3.0  See Also:  IHandlerListener.handlerChanged(HandlerEvent)    
919,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/ISourceProviderService.html, A service from which all of the source providers can be retrieved.      This service can be acquired from your service locator:    ISourceProviderService service = (ISourceProviderService) getSite().getService(ISourceProviderService.class);    This service is available globally.    Since:  3.4  See Also:  IEvaluationService  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
920,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/ElementHandler.html,extends Object An element handler converts an IConfigurationElement into a  corresponding expression object.    The class should be subclassed by clients wishing to provide an element  handler for special expressions.    Since:  3.0    
921,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/ExpressionConverter.html,extends Object An expression converter converts an XML expression represented by an  IConfigurationElement or Element (DOM) subtree into a  corresponding expression tree.    An expression converter manages a list of ElementHandlers. Element  handlers are responsible to do the actual conversion. The element handlers  build a chain of responsibility.    Since:  3.0    
922,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/testing/ContributionInfo.html,extends Object Instances of this class describe a contribution of an element of a certain  type to the UI.  Since:  3.6    
923,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/help/AbstractHelpUI.html,"extends Object Abstract base class for the help system UI.    The Eclipse platform provides an extension point (""org.eclipse.ui.helpSupport"")  for plugging in a help system UI. The help system UI is an optional  component; applications may provide a UI for presenting help to the user by  implementing a subclass and including the name of their class in the  <config> element in an extension to the  ""org.eclipse.ui.helpSupport"" extension point.      Note that the standard implementation of the help system UI is provided by  the ""org.eclipse.help.ui"" plug-in. Since the platform can only  make use of a single help system UI implementation_ make sure that the  platform is not configured with more than one plug-in trying to extend this  extension point.    Since:  3.0    "
924,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/help/IContextComputer.html,A content computer is used to dynamically calculate help support contexts at the  time the user requests help.    This interface may be implemented by clients.      
925,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/intro/IIntroPart.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable The intro part is a visual component within the workbench responsible for  introducing the product to new users. The intro part is typically shown the  first time a product is started up.    The intro part implementation is contributed to the workbench via the  org.eclipse.ui.intro extension point. There can be several  intro part implementations_ and associations between intro part  implementations and products. The workbench will only make use of the intro  part implementation for the current product (as given by  Platform.getProduct(). There is at most one  intro part instance in the entire workbench_ and it resides in exactly one  workbench window at a time.      This interface in not intended to be directly implemented. Rather_ clients  providing a intro part implementation should subclass   IntroPart.     Since:  3.0  See Also:  IIntroManager.showIntro(org.eclipse.ui.IWorkbenchWindow_ boolean)  Restriction:  This interface is not intended to be implemented by clients.    "
926,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/intro/IntroContentDetector.html,extends Object An intro content detector is used when starting the Workbench to determine if  new intro content is available. Since calling this method is part of the  Workbench start sequence_ subclasses should be implemented with care as not  to introduce noticeable delay at startup. If an intro content detector  reports new available content_ the view part showing the content will be  opened again even if the user had closed it in a previous session. Because of  this_ the intro view part should draw the user's attention to the new content  to avoid confusion about why the intro view part was opened again without the  user requesting it.  Since:  3.3    
927,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IKeyBindingService.html,The key binding service allows one to query or set the scope of Eclipse for  the purposes of resolving key assignments to commands_ and to register  actions to handle specific commands. See the org.eclipse.ui.commands  extension point for details.    A participating workbench part is responsible to register all its actions  with this service. The part is also responsible to set the current scope.      This interface is not intended to be implemented or extended by clients.    Since:  2.0  Restriction:  This interface is not intended to be implemented by clients.    
928,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/Key.html,extends Object implements Comparable  Key is the abstract base class for all objects representing  keys on the keyboard.      All Key objects have a formal string representation_ called  the 'name' of the key_ available via the toString() method.      All Key objects_ via the format() method_  provide a version of their formal string representation translated by  platform and locale_ suitable for display to a user.      Key objects are immutable. Clients are not permitted to extend  this class.    Since:  3.0  Restriction:  This class is not intended to be subclassed by clients.    
929,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/KeyStroke.html,"extends Object implements Comparable  A KeyStroke is defined as an optional set of modifier keys  followed optionally by a natural key. A KeyStroke is said to  be complete if it contains a natural key. A natural key is any Unicode  character (e.g._ ""backspace""_ etc.)_ any character belonging to a natural  language (e.g._ ""A""_ ""1""_ ""[""_ etc.)_ or any special control character  specific to computers (e.g._ ""F10""_ ""PageUp""_ etc.).      All KeyStroke objects have a formal string representation  available via the toString() method. There are a number of  methods to get instances of KeyStroke objects_ including one  which can parse this formal string representation.      All KeyStroke objects_ via the format() method_  provide a version of their formal string representation translated by  platform and locale_ suitable for display to a user.      KeyStroke objects are immutable. Clients are not permitted to  extend this class.    Since:  3.0  See Also:  ModifierKey_  NaturalKey    "
930,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/NaturalKey.html,"extends Key  Instances of NaturalKey represent all keys on the keyboard not  known by convention as 'modifier keys'. These can either be keys that belong  to a natural language of some kind(e.g._ ""A""_ ""1"")_ any Unicode character  (e.g._ ""backspace"")_ or they can be special controls keys used by computers  (e.g._ ""F10""_ ""PageUp"").      NaturalKey objects are immutable. Clients are not permitted to  extend this class.    Since:  3.0  Restriction:  This class is not intended to be subclassed by clients.    "
931,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/ModifierKey.html,extends Key  Instances of ModifierKey represent the four keys on the  keyboard recognized by convention as 'modifier keys'_ those keys typically  pressed in combination with themselves and/or a  NaturalKey.      ModifierKey objects are immutable. Clients are not permitted  to extend this class.    Since:  3.0  See Also:  NaturalKey    
932,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/KeyBinding.html,extends Binding  A keyboard shortcut. This is a binding between some keyboard input and the  triggering of a command. This object is immutable.    Since:  3.1    
933,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/IBindingManagerListener.html, An instance of BindingManagerListener can be used by clients to  receive notification of changes to an instance of  BindingManager.       This interface may be implemented by clients.    Since:  3.1  See Also:  BindingManager.addBindingManagerListener(IBindingManagerListener)_  BindingManager.addBindingManagerListener(IBindingManagerListener)_  BindingManagerEvent    
934,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/StatusLineContributionItem.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
extends ContributionItem A contribution item to be used with status line managers.    This class may be instantiated; it is not intended to be subclassed.    Since:  3.4    "
935,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IKeyConfigurationListener.html, An instance of IKeyConfigurationListener can be used by  clients to receive notification of changes to one or more instances of  IKeyConfiguration.      This interface may be implemented by clients.    Since:  3.0  See Also:  IKeyConfiguration.addKeyConfigurationListener(IKeyConfigurationListener)_  IKeyConfiguration.removeKeyConfigurationListener(IKeyConfigurationListener)_  KeyConfigurationEvent_  ISchemeListener    
936,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/SchemeEvent.html,extends AbstractNamedHandleEvent An instance of this class describes changes to an instance of  IScheme.    This class is not intended to be extended by clients.    Since:  3.1  See Also:  ISchemeListener.schemeChanged(SchemeEvent)    
937,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CBanner.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class implement a Composite that lays out its  children and allows programmatic control of the layout. It draws  a separator between the left and right children which can be dragged  to resize the right control.  CBanner is used in the workbench to layout the toolbar area and  perspective switching toolbar.    Note that although this class is a subclass of Composite_  it does not make sense to set a layout on it.      Styles:  NONE  Events:  (None)    IMPORTANT: This class is not intended to be subclassed.    Since:  3.0  See Also:  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
938,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/AbstractContributionFactory.html,"extends Object ContributionFactories are used by the IMenuService to populate  ContributionManagers. In createContributionItems(IServiceLocator_ IContributionRoot)  you fill in the additions List with IContributionItem to be inserted at this  factory's location. For example:        AbstractContributionFactory contributions = new AbstractContributionFactory(  ""menu:org.eclipse.ui.tests.api.MenuTestHarness?after=additions"") {  public void createContributionItems(IMenuService menuService_ List additions) {  CommandContributionItem item = new CommandContributionItem(  ""org.eclipse.ui.tests.menus.helloWorld""_  ""org.eclipse.ui.tests.commands.enabledHelloWorld""_ null_ null_  ""Say Hello""_ null);  additions.add(item);  item = new CommandContributionItem(  ""org.eclipse.ui.tests.menus.refresh""_  ""org.eclipse.ui.tests.commands.refreshView""_ null_ null_  ""Refresh""_ null);  menuService.registerVisibleWhen(item_ new MyActiveContextExpression(  ""org.eclipse.ui.tests.myview.context""));  additions.add(item);  }    public void releaseContributionItems(IMenuService menuService_ List items) {  // we have nothing to do  }  };  IMenuService service = (IMenuService) PlatformUI.getWorkbench().getService(  IMenuService.class);  service.addContributionFactory(contributions);            Clients who are providing factories via the org.eclipse.ui.menus  extension point should subclass ExtensionContributionFactory instead.        Only the abstract methods may be implemented.    Since:  3.3  See Also:  IMenuService_  MenuManager_  ToolBarManager    "
939,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ContributionManager.html,"A contribution manager organizes contributions to such UI components  as menus_ toolbars and status lines.    A contribution manager keeps track of a list of contribution  items. Each contribution item may has an optional identifier_ which can be used  to retrieve items from a manager_ and for positioning items relative to  each other. The list of contribution items can be subdivided into named groups   using special contribution items that serve as group markers.      The IContributionManager interface provides general  protocol for adding_ removing_ and retrieving contribution items.  It also provides convenience methods that make it convenient  to contribute actions. This interface should be implemented  by all objects that wish to manage contributions.      There are several implementions of this interface in this package_  including ones for menus (MenuManager)_  tool bars (ToolBarManager)_  and status lines (StatusLineManager).      
extends Object implements IContributionManager Abstract base class for all contribution managers_ and standard  implementation of IContributionManager. This class provides  functionality common across the specific managers defined by this framework.    This class maintains a list of contribution items and a dirty flag_ both as  internal state. In addition to providing implementations of most  IContributionManager methods_ this class automatically  coalesces adjacent separators_ hides beginning and ending separators_ and  deals with dynamically changing sets of contributions. When the set of  contributions does change dynamically_ the changes are propagated to the  control via the update method_ which subclasses must  implement.      Note: A ContributionItem cannot be shared between different  ContributionManagers.      "
940,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/WorkbenchWindowControlContribution.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
extends org.eclipse.ui.internal.menus.InternalControlContribution Abstract base class from which all controls contributions to  the workbench through the 'org.eclipse.ui.menus' extension  point must derive.    The extends the ControlContribution by adding accessor  methods that provide extra state information about the placement  of the control:    getWorkbenchWindow() - indicates which workbench window this control  is being hosted by  getCurSide() - indicates which side of the workbench window the  control is being displayed on    Since:  3.3  See Also:  ControlContribution    "
941,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/core/contexts/ContextFunction.html,"A context function encapsulates evaluation of some code within an  IEclipseContext. The result of the function must be derived purely  from the provided arguments and context objects_ and must be free from  side-effects other than the function's return value. In particular_ the  function must be idempotent - subsequent invocations of the same function  with the same inputs must produce the same result.    A common use for context functions is as a place holder for an object that  has not yet been created. These place holders can be stored as values in an  IEclipseContext_ allowing the concrete value they represent to be  computed lazily only when requested.      Context functions can optionally be registered as OSGi services. Context  implementations may use such registered services to seed context instances  with initial values. Registering your context function as a service is a  signal that contexts are free to add an instance of your function to their  context automatically_ using the key specified by the  SERVICE_CONTEXT_KEY service property.    Since:  1.3  See Also:  IEclipseContext.set(String_ Object)  Restriction:  This interface is not intended to be implemented by clients.  Function implementations must subclass ContextFunction  instead.    
extends Object implements IContextFunction The base class for all computed value implementations. Clients may subclass  this class. See the class comment of IContextFunction for specific  rules that must be followed by function implementations.    This class is intended to be subclassed by clients.    Since:  1.3  See Also:  IContextFunction    "
942,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchWindowPulldownDelegate.html,extends IWorkbenchWindowActionDelegate Interface for a pulldown action that is contributed into the workbench window   tool bar. It extends IWorkbenchWindowActionDelegate and adds an  initialization method to define the menu creator for the action.    
943,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchWindowPulldownDelegate2.html,"Interface for actions contributed via an extension point.    This interface should be implemented by clients who need to contribute actions  via an extension point. The workbench will generate a proxy action   object on behalf of the plug-in to avoid having to activate the plug-in until   the user needs it. If the action is performed the workbench will load the class   that implements this interface and create what is called an action   delegate object. Then the request_ and all subsequent ones_ are  forwarded through the proxy action to the action delegate_ which does the  real work.     The proxy action is the one that appears in the UI_ so the action delegate   will need to talk to the proxy action in order to keep up an appropriate   appearance. Once the action delegate has been created_ it will be  notified of all selection changes_ allowing it to enable or disable the   proxy action appropriately.    An action delegate cannot be consulted about selection changes before the  action is performed because it does not exist. For this reason_ control of  the action's enable state should also be exercised through simple XML rules  contained in the extension. These rules allow enable state control before  the action delegate's plug-in is loaded.    Clients can choose to subclass the provided abstract implementation  org.eclipse.ui.actions.ActionDelegate or implement the  interface directly.    See Also:  ActionDelegate_  IActionDelegate2    
Interface for actions contributed via an extension point.    This interface should be implemented by clients who need to contribute actions  via an extension point. The workbench will generate a proxy action   object on behalf of the plug-in to avoid having to activate the plug-in until   the user needs it. If the action is performed the workbench will load the class   that implements this interface and create what is called an action   delegate object. Then the request_ and all subsequent ones_ are  forwarded through the proxy action to the action delegate_ which does the  real work.     The proxy action is the one that appears in the UI_ so the action delegate   will need to talk to the proxy action in order to keep up an appropriate   appearance. Once the action delegate has been created_ it will be  notified of all selection changes_ allowing it to enable or disable the   proxy action appropriately.    An action delegate cannot be consulted about selection changes before the  action is performed because it does not exist. For this reason_ control of  the action's enable state should also be exercised through simple XML rules  contained in the extension. These rules allow enable state control before  the action delegate's plug-in is loaded.    Clients can choose to subclass the provided abstract implementation  org.eclipse.ui.actions.ActionDelegate or implement the  interface directly.    See Also:  ActionDelegate_  IActionDelegate2    
extends IActionDelegate Interface for an action that is contributed into the workbench window menu   or tool bar. It extends IActionDelegate and adds an  initialization method for connecting the delegate to the workbench window it  should work with.    
extends IWorkbenchWindowActionDelegate Interface for a pulldown action that is contributed into the workbench window   tool bar. It extends IWorkbenchWindowActionDelegate and adds an  initialization method to define the menu creator for the action.    
extends IWorkbenchWindowPulldownDelegate Extension of IWorkbenchWindowPulldownDelegate that allows the delegate dropdown  menu to be a child of a Menu item. Necessary for CoolBar support. If a coolbar   group of items is not fully displayed_ a chevron and a drop down menu will be  used to show the group's tool items. Therefore_ a getMenu(Menu) method is necessary_   since the delegate drop down menu will be a child of the chevron menu item (not   the tool control).    "
944,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/INavigationLocation.html,Represents the context marked for the user in the navigation history.    Not intended to be implemented by clients. Clients should subclass NavigationLocation  instead.  Since:  2.1  Restriction:  This interface is not intended to be implemented by clients.    
945,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IObjectActionDelegate.html,"Interface for actions contributed via an extension point.    This interface should be implemented by clients who need to contribute actions  via an extension point. The workbench will generate a proxy action   object on behalf of the plug-in to avoid having to activate the plug-in until   the user needs it. If the action is performed the workbench will load the class   that implements this interface and create what is called an action   delegate object. Then the request_ and all subsequent ones_ are  forwarded through the proxy action to the action delegate_ which does the  real work.     The proxy action is the one that appears in the UI_ so the action delegate   will need to talk to the proxy action in order to keep up an appropriate   appearance. Once the action delegate has been created_ it will be  notified of all selection changes_ allowing it to enable or disable the   proxy action appropriately.    An action delegate cannot be consulted about selection changes before the  action is performed because it does not exist. For this reason_ control of  the action's enable state should also be exercised through simple XML rules  contained in the extension. These rules allow enable state control before  the action delegate's plug-in is loaded.    Clients can choose to subclass the provided abstract implementation  org.eclipse.ui.actions.ActionDelegate or implement the  interface directly.    See Also:  ActionDelegate_  IActionDelegate2    
extends IActionDelegate Interface for an object action that is contributed into a popup menu  for a view or editor. It extends IActionDelegate  and adds an initialization method for connecting the delegate to the   part it should work with.    "
946,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPageListener.html,Interface for listening to page lifecycle events.    This interface may be implemented by clients.    See Also:  IPageService.addPageListener(org.eclipse.ui.IPageListener)    
947,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MultiPageEditorSite.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
 A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends IWorkbenchSite The primary interface between a workbench part and the workbench.    This interface is not intended to be implemented or extended by clients.    Restriction:  This interface is not intended to be implemented by clients.    
extends IAdaptable_ IShellProvider_ IServiceLocator The common interface between the workbench and its parts_ including pages  within parts.    The workbench site supports a few services by  default. If these services are used to allocate resources_ it is important to  remember to clean up those resources after you are done with them. Otherwise_  the resources will exist until the workbench site is disposed. The supported  services are:    ICommandService  IContextService  IHandlerService  IBindingService. Resources allocated through this service will  not be cleaned up until the workbench shuts down.    This interface is not intended to be implemented or extended by clients.    Since:  2.0  See Also:  IWorkbenchPartSite_  IPageSite  Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkbenchPartSite The primary interface between an editor part and the workbench.    The workbench exposes its implemention of editor part sites via this   interface_ which is not intended to be implemented or extended by clients.    Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkbenchSite The primary interface between a workbench part and the workbench.    This interface is not intended to be implemented or extended by clients.    Restriction:  This interface is not intended to be implemented by clients.    
extends IAdaptable_ IShellProvider_ IServiceLocator The common interface between the workbench and its parts_ including pages  within parts.    The workbench site supports a few services by  default. If these services are used to allocate resources_ it is important to  remember to clean up those resources after you are done with them. Otherwise_  the resources will exist until the workbench site is disposed. The supported  services are:    ICommandService  IContextService  IHandlerService  IBindingService. Resources allocated through this service will  not be cleaned up until the workbench shuts down.    This interface is not intended to be implemented or extended by clients.    Since:  2.0  See Also:  IWorkbenchPartSite_  IPageSite  Restriction:  This interface is not intended to be implemented by clients.    
 A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2    
extends Object implements IEditorSite_ org.eclipse.ui.internal.services.INestable Site for a nested editor within a multi-page editor. Selection is handled by  forwarding the event to the multi-page editor's selection listeners; most  other methods are forwarded to the multi-page editor's site.    The base implementation of MultiPageEditor.createSite creates  an instance of this class. This class may be instantiated or subclassed.      "
948,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPerspectiveListener.html,Interface for listening to perspective lifecycle events.    This interface may be implemented by clients.    See Also:  IPageService.addPerspectiveListener(IPerspectiveListener)_  PerspectiveAdapter    
949,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPerspectiveListener2.html,extends IPerspectiveListener Extension interface to IPerspectiveListener which   adds support for listening to part-specific perspective lifecycle events.  For example_ this allows a perspective listener to determine which view  is being hidden during a CHANGE_VIEW_HIDE event.    This interface may be implemented by clients.    Since:  3.0  See Also:  IPageService.addPerspectiveListener(IPerspectiveListener)_  PerspectiveAdapter    
950,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPerspectiveListener3.html,extends IPerspectiveListener2 Extension interface to IPerspectiveListener which   adds support for listening to perspective open and close events.    This interface may be implemented by clients.    Since:  3.1  See Also:  IPageService.addPerspectiveListener(IPerspectiveListener)_  PerspectiveAdapter    
951,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPerspectiveListener4.html,"Interface for listening to perspective lifecycle events.    This interface may be implemented by clients.    See Also:  IPageService.addPerspectiveListener(IPerspectiveListener)_  PerspectiveAdapter    
extends IPerspectiveListener Extension interface to IPerspectiveListener which   adds support for listening to part-specific perspective lifecycle events.  For example_ this allows a perspective listener to determine which view  is being hidden during a CHANGE_VIEW_HIDE event.    This interface may be implemented by clients.    Since:  3.0  See Also:  IPageService.addPerspectiveListener(IPerspectiveListener)_  PerspectiveAdapter    
extends IPerspectiveListener2 Extension interface to IPerspectiveListener which   adds support for listening to perspective open and close events.    This interface may be implemented by clients.    Since:  3.1  See Also:  IPageService.addPerspectiveListener(IPerspectiveListener)_  PerspectiveAdapter    
extends IPerspectiveListener3 Extension interface to IPerspectiveListener which adds support  for listening to perspective pre-deactivate events.    This interface may be implemented by clients.    Since:  3.2  See Also:  IPageService.addPerspectiveListener(IPerspectiveListener)_  PerspectiveAdapter    "
952,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/IPreferenceFilter.html,"Preference filters are used to describe the relationship between the  preference tree and a data set when importing/exporting preferences.    For instance_ a client is able to create a preference filter describing  which preference nodes/keys should be used when exporting the  ""Key Bindings"" preferences. When the export happens_ the tree is  trimmed and only the applicable preferences will be exported.      Clients may implement this interface.    Since:  3.1    "
953,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/FontRegistry.html,extends ResourceRegistry A font registry maintains a mapping between symbolic font names   and SWT fonts.    A font registry owns all of the font objects registered  with it_ and automatically disposes of them when the SWT Display  that creates the fonts is disposed. Because of this_ clients do   not need to (indeed_ must not attempt to) dispose of font   objects themselves.      A special constructor is provided for populating a font registry  from a property files using the standard Java resource bundle mechanism.      Methods are provided for registering listeners that will be kept  apprised of changes to list of registered fonts.      Clients may instantiate this class (it was not designed to be subclassed).      Since 3.0 this class extends ResourceRegistry.  Restriction:  This class is not intended to be subclassed by clients.    
954,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/themes/IThemeManager.html,A theme manager is an object that contains references to usable   ITheme objects and maintains a reference to the currently active  theme. This theme will be used by the workbench to decorate tab folders and  other controls where possible. The workbench implementation of this   interface will push the values of the current theme into the underlying jface  registries (ColorRegistry and   FontRegistry whenever the current theme   changes. Clients who do not need access to specific themes may instead   attach listeners to these registries directly.       This interface is not intended to be implemented or extended by clients.    Since:  3.0  See Also:  IWorkbench.getThemeManager()  Restriction:  This interface is not intended to be implemented by clients.    
955,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/IPreferenceNodeVisitor.html,This interface is implemented by objects that visit preference nodes.    Usage:    class Visitor implements IPreferenceNodeVisitor {  public boolean visit(IEclipsePreferences node) {  // your code here  return true;  }  }  IEclipsePreferences root = ...;  root.accept(new Visitor());      Clients may implement this interface.    Since:  3.0  See Also:  IEclipsePreferences.accept(IPreferenceNodeVisitor)    
956,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ProgressBar.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Control Instances of the receiver represent an unselectable  user interface object that is used to display progress_  typically in the form of a bar.  Styles:  SMOOTH_ HORIZONTAL_ VERTICAL_ INDETERMINATE  Events:  (none)    Note: Only one of the styles HORIZONTAL and VERTICAL may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  ProgressBar snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
957,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/IJobChangeEvent.html,An event describing a change to the state of a job.  Since:  3.0  See Also:  IJobChangeListener  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
958,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/ImageLoader.html,extends Object Instances of this class are used to load images from_  and save images to_ a file or stream.    Currently supported image formats are:    BMP (Windows or OS/2 Bitmap)  ICO (Windows Icon)  JPEG  GIF  PNG  TIFF  ImageLoaders can be used to:  load/save single images in all formats  load/save multiple images (GIF/ICO/TIFF)  load/save animated GIF images  load interlaced GIF/PNG images  load progressive JPEG images  See Also:  SWT Example: ImageAnalyzer_  Sample code and further information    
959,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/TextStyle.html,extends Object TextStyle defines a set of styles that can be applied  to a range of text.    The hashCode() method in this class uses the values of the public  fields to compute the hash value. When storing instances of the  class in hashed collections_ do not modify these fields after the  object has been inserted.       Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.    Since:  3.0  See Also:  TextLayout_  Font_  Color_  TextLayout_ TextStyle snippets_  Sample code and further information    
960,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/KeyListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated as keys  are pressed on the system keyboard.    After creating an instance of a class that implements  this interface it can be added to a control using the  addKeyListener method and removed using  the removeKeyListener method. When a  key is pressed or released_ the appropriate method will  be invoked.    See Also:  KeyAdapter_  KeyEvent    
961,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/KeyAdapter.html,"extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated as keys  are pressed on the system keyboard.    After creating an instance of a class that implements  this interface it can be added to a control using the  addKeyListener method and removed using  the removeKeyListener method. When a  key is pressed or released_ the appropriate method will  be invoked.    See Also:  KeyAdapter_  KeyEvent    
extends Object implements KeyListener This adapter class provides default implementations for the  methods described by the KeyListener interface.    Classes that wish to deal with KeyEvents can  extend this class and override only the methods which they are  interested in.    See Also:  KeyListener_  KeyEvent_  Sample code and further information    "
962,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/swt/IFocusService.html,"Tracks focusGained and focusLost events for a Control registered with this  service_ and provides the control and its registered ID as variables to the  application evaluation context for evaluation by the various services.    This service provides 2 variables_ activeFocusControl (a Control) and  activeFocusControlId (the ID registered with the service).      You can use this service to provide default cut/copy/paste/selectAll for  specific text controls outside of the normal workbench part lifecycle_ like a  control contributed to the trim. For example:          <handler  class=""org.eclipse.ui.internal.handlers.WidgetMethodHandler:paste""  commandId=""org.eclipse.ui.edit.paste"">  <activeWhen>  <with variable=""activeFocusControlId"">  <equals value=""org.eclipse.ui.tests.focusText""/>  </with>  </activeWhen>  </handler>          This service can be acquired from your service locator:    IFocusService service = (IFocusService) getSite().getService(IFocusService.class);    This service is available globally.    Since:  3.3  See Also:  ISources  Restriction:  This interface is not intended to be implemented by clients.    "
963,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorMatchingStrategy.html,An editor matching strategy allows editor extensions to provide their own  algorithm for matching the input of an open editor of that type to a   given editor input. This is used to find a matching editor during  IWorkbenchPage.openEditor(IEditorInput_ String_ boolean) and  IWorkbenchPage.findEditor(IEditorInput).  Since:  3.1    
964,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPerspectiveFactory.html,"A perspective factory generates the initial page layout and visible  action set for a page.    When a new page is created in the workbench a perspective is used to define  the initial page layout. If this is a predefined perspective (based on an extension to   the workbench's perspective extension point) an IPerspectiveFactory   is used to define the initial page layout.    The factory for the perspective is created and passed an IPageLayout   where views can be added. The default layout consists of the editor area with no   additional views. Additional views are added to the layout using   the editor area as the initial point of reference. The factory is used only briefly   while a new page is created; then discarded.    To define a perspective clients should implement this interface and   include the name of their class in an extension to the workbench's perspective   extension point (named ""org.eclipse.ui.perspectives""). For example_   the plug-in's XML markup might contain:    <extension point=""org.eclipse.ui.perspectives"">  <perspective  id=""com.example.javaplugin.perspective""  name=""Java""  class=""com.example.javaplugin.JavaPerspective"">  </perspective>  </extension>      Example of populating a page with standard workbench views:    public void createInitialLayout(IPageLayout layout) {  // Get the editor area.  String editorArea = layout.getEditorArea();  // Top left: Resource Navigator view and Bookmarks view placeholder  IFolderLayout topLeft = layout.createFolder(""topLeft""_ IPageLayout.LEFT_ 0.25f_  editorArea);  topLeft.addView(IPageLayout.ID_RES_NAV);  topLeft.addPlaceholder(IPageLayout.ID_BOOKMARKS);  // Bottom left: Outline view and Property Sheet view  IFolderLayout bottomLeft = layout.createFolder(""bottomLeft""_ IPageLayout.BOTTOM_ 0.50f_  ""topLeft"");  bottomLeft.addView(IPageLayout.ID_OUTLINE);  bottomLeft.addView(IPageLayout.ID_PROP_SHEET);  // Bottom right: Task List view  layout.addView(IPageLayout.ID_TASK_LIST_ IPageLayout.BOTTOM_ 0.66f_ editorArea);  }      Within the workbench a user may override the visible views_ layout and  action sets of a predefined perspective to create a custom perspective. In such cases   the layout is persisted by the workbench and the factory is not used.      "
965,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/dynamichelpers/IExtensionChangeHandler.html,Extension change handlers are notified of changes for a given extension   point in the context of an extension tracker.    This interface can be used without OSGi running.    This interface is intended to be implemented by clients.    Since:  3.1    
966,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISaveablePart2.html,"Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends ISaveablePart Workbench parts implement or adapt to this interface to participate  in actions that require a prompt for the user to provide input on   what to do with unsaved data when the part is closed or the Workbench  is shut down.    Note that if a part implements this interface_ it is excluded from the  common ""prompt to save"" dialog_ and instead opens its own dialog. This may  cause multiple prompts to the end user during a single user operation.  Implementors should be aware that this may lead to a less than optimal  user experience.    Since:  3.1    "
967,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/SubMonitor.html,"The IProgressMonitor interface is implemented  by objects that monitor the progress of an activity; the methods  in this interface are invoked by code that performs the activity.    All activity is broken down into a linear sequence of tasks against  which progress is reported. When a task begins_ a beginTask(String_ int)  notification is reported_ followed by any number and mixture of   progress reports (worked()) and subtask notifications   (subTask(String)). When the task is eventually completed_ a   done() notification is reported. After the done()  notification_ the progress monitor cannot be reused; i.e._   beginTask(String_ int) cannot be called again after the call to   done().      A request to cancel an operation can be signaled using the   setCanceled method. Operations taking a progress  monitor are expected to poll the monitor (using isCanceled)  periodically and abort at their earliest convenience. Operation can however   choose to ignore cancelation requests.      Since notification is synchronous with the activity itself_ the listener should   provide a fast and robust implementation. If the handling of notifications would   involve blocking operations_ or operations which might throw uncaught exceptions_   the notifications should be queued_ and the actual processing deferred (or perhaps  delegated to a separate thread).    This interface can be used without OSGi running.    Clients may implement this interface.      
extends IProgressMonitor An extension to the IProgressMonitor interface for monitors that want to  support feedback when an activity is blocked due to concurrent activity in  another thread.    When a monitor that supports this extension is passed to an operation_ the  operation should call setBlocked whenever it knows that it  must wait for a lock that is currently held by another thread. The operation  should continue to check for and respond to cancelation requests while  blocked. When the operation is no longer blocked_ it must call clearBlocked  to clear the blocked state.    This interface can be used without OSGi running.    Clients may implement this interface.    Since:  3.0  See Also:  IProgressMonitor    
extends Object implements IProgressMonitorWithBlocking A progress monitor that uses a given amount of work ticks from a parent monitor. This is intended as a   safer_ easier-to-use alternative to SubProgressMonitor. The main benefits of SubMonitor over   SubProgressMonitor are:  It is not necessary to call beginTask() or done() on an instance of SubMonitor.  SubMonitor has a simpler syntax for creating nested monitors.  SubMonitor is more efficient for deep recursion chains.  SubMonitor has a setWorkRemining method that allows the remaining space on the monitor to be   redistributed without reporting any work.  SubMonitor protects the caller from common progress reporting bugs in a called method. For example_   if a called method fails to call done() on the given monitor or fails to consume all the ticks on   the given monitor_ the parent will correct the problem after the method returns.    USAGE:    When implementing a method that accepts an IProgressMonitor:  At the start of your method_ use SubMonitor.convert(...). to convert the IProgressMonitor   into a SubMonitor.   Use SubMonitor.newChild(...) whenever you need to call another method that   accepts an IProgressMonitor.    DEFAULT BEHAVIOR:    When writing JavaDoc for a method that accepts an IProgressMonitor_ you should assume the   following default behavior unless the method's JavaDoc says otherwise:  It WILL call beginTask on the IProgressMonitor.  It WILL NOT accept a null argument.  It WILL call done on the IProgressMonitor.    BEST PRACTISES:    We recommend that newly-written methods follow the given contract:  It WILL call beginTask on the IProgressMonitor.  It WILL accept a null argument_ indicating that no progress should be reported and the operation cannot be cancelled.  It WILL NOT call done on the IProgressMonitor_ leaving this responsibility up to the caller.  If you wish to follow these conventions_ you may copy and paste the following text into your method's JavaDoc:    @param monitor the progress monitor to use for reporting progress to the user. It is the caller's responsibility  to call done() on the given monitor. Accepts null_ indicating that no progress should be  reported and that the operation cannot be cancelled.    Example: Recommended usage  This example demonstrates how the recommended usage of SubMonitor makes it unnecessary to call  IProgressMonitor.done() in most situations.    It is never necessary to call done() on a monitor obtained from convert or progress.newChild().   In this example_ there is no guarantee that monitor is an instance of SubMonitor_ making it   necessary to call monitor.done(). The JavaDoc contract makes this the responsibility of the caller.        // param monitor the progress monitor to use for reporting progress to the user. It is the caller's responsibility  // to call done() on the given monitor. Accepts null_ indicating that no progress should be  // reported and that the operation cannot be cancelled.  //  void doSomething(IProgressMonitor monitor) {  // Convert the given monitor into a progress instance   SubMonitor progress = SubMonitor.convert(monitor_ 100);    // Use 30% of the progress to do some work  doSomeWork(progress.newChild(30));    // Advance the monitor by another 30%  progress.worked(30);    // Use the remaining 40% of the progress to do some more work  doSomeWork(progress.newChild(40));   }      Example: Default usage    You will often need to implement a method that does not explicitly stipulate that calling done() is the responsibility  of the caller. In this case_ you should use the following pattern:      // param monitor the progress monitor to use for reporting progress to the user_ or null indicating  // that no progress should be reported and the operation cannot be cancelled.  //  void doSomething(IProgressMonitor monitor) {  // Convert the given monitor into a progress instance   SubMonitor progress = SubMonitor.convert(monitor_ 100);  try {  // Use 30% of the progress to do some work  doSomeWork(progress.newChild(30));    // Advance the monitor by another 30%  progress.worked(30);    // Use the remaining 40% of the progress to do some more work  doSomeWork(progress.newChild(40));    } finally {  if (monitor != null) {  monitor.done();  }  }   }        Example: Branches  This example demonstrates how to smoothly report progress in situations where some of the work is optional.      void doSomething(IProgressMonitor monitor) {  SubMonitor progress = SubMonitor.convert(monitor_ 100);    if (condition) {  // Use 50% of the progress to do some work  doSomeWork(progress.newChild(50));  }    // Don't report any work_ but ensure that we have 50 ticks remaining on the progress monitor.  // If we already consumed 50 ticks in the above branch_ this is a no-op. Otherwise_ the remaining  // space in the monitor is redistributed into 50 ticks.    progress.setWorkRemaining(50);    // Use the remainder of the progress monitor to do the rest of the work  doSomeWork(progress.newChild(50));   }      Please beware of the following anti-pattern:    if (condition) {  // Use 50% of the progress to do some work  doSomeWork(progress.newChild(50));  } else {  // Bad: Causes the progress monitor to appear to start at 50%_ wasting half of the  // space in the monitor.  progress.worked(50);  }          Example: Loops  This example demonstrates how to report progress in a loop.        void doSomething(IProgressMonitor monitor_ Collection someCollection) {  SubMonitor progress = SubMonitor.convert(monitor_ 100);  // Create a new progress monitor that uses 70% of the total progress and will allocate one tick  // for each element of the given collection.   SubMonitor loopProgress = progress.newChild(70).setWorkRemaining(someCollection.size());    for (Iterator iter = someCollection.iterator(); iter.hasNext();) {  Object next = iter.next();    doWorkOnElement(next_ loopProgress.newChild(1));  }    // Use the remaining 30% of the progress monitor to do some work outside the loop  doSomeWork(progress.newChild(30));  }      Example: Infinite progress    This example demonstrates how to report logarithmic progress in situations where the number of ticks  cannot be easily computed in advance.      void doSomething(IProgressMonitor monitor_ LinkedListNode node) {  SubMonitor progress = SubMonitor.convert(monitor);  while (node != null) {  // Regardless of the amount of progress reported so far_  // use 0.01% of the space remaining in the monitor to process the next node.  progress.setWorkRemaining(10000);    doWorkOnElement(node_ progress.newChild(1));  node = node.next;  }  }          This class can be used without OSGi running.    Since:  org.eclipse.equinox.common 3.3    "
968,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/AbstractServiceFactory.html,extends Object A factory for creating services for use with the  org.eclipse.ui.services extension point. You are given a  service locator to look up other services_ and can retrieve your parent  service (if one has already been created).  Since:  3.4    
969,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IShowInTargetList.html,Show In sources which need to provide additional entries to the Show In list of targets  can provide this interface.  The part can either directly implement this interface_ or provide it  via IAdaptable.getAdapter(IShowInTargetList).  Since:  2.1  See Also:  IShowInSource_  IShowInTarget    
970,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/splash/AbstractSplashHandler.html,extends Object Base class for splash implementations. Please note that methods on this class  will be invoked while the Workbench is being instantiated. As such_ any  resource provided by the workbench plug-in cannot be guaranteed to be  available to this class while executing. No attempt should be made to access  IWorkbench or any subordinate interfaces or resources.  Since:  3.3    
971,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/statushandlers/AbstractStatusAreaProvider.html,extends ErrorSupportProvider  A status area provider creates an area that displays detailed information  about StatusAdapter or IStatus.        The area provider can be set in WorkbenchStatusDialogManager as well as in  JFace Policy since its extends ErrorSupportProvider.    Since:  3.4  See Also:  Policy.setErrorSupportProvider(ErrorSupportProvider)_  WorkbenchStatusDialogManager.setSupportAreaProvider(AbstractStatusAreaProvider)_  WorkbenchStatusDialogManager.setDetailsAreaProvider(AbstractStatusAreaProvider)    
972,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/DialogTray.html,extends Object  This class is the abstract superclass of all dialog trays. A tray can be opened  in any TrayDialog.    Since:  3.2  See Also:  TrayDialog    
973,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/themes/IThemePreview.html,Interface used by theme element developers to preview the usage of their   elements within the colors and fonts preference page.  Since:  3.0    
974,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/themes/IColorFactory.html,"A factory interface that may be used to specify a color value. This is   (optionally) used by the themes extension point for color value   definitions.    Example usage:      <colorDefinition  label=""Custom Color""  id=""example.customColor""  colorFactory=""some.implementor.of.IColorFactory"">  </colorDefinition>      Since:  3.0    "
975,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/FontDescriptor.html,extends DeviceResourceDescriptor Lightweight descriptor for a font. Creates the described font on demand.  Subclasses can implement different ways of describing a font. These objects  will be compared_ so hashCode(...) and equals(...) must return something   meaningful.  Since:  3.1    
976,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ColorDescriptor.html,extends DeviceResourceDescriptor Lightweight descriptor for an SWT color. Each ColorDescriptor will create a particular SWT   Color on demand. This object will be compared so hashCode(...) and equals(...) must   return meaningful values.  Since:  3.1    
977,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/DeviceResourceDescriptor.html,extends Object Instances of this class can allocate and dispose SWT resources. Each  instance describes a particular resource (such as a Color_ Font_ or Image)  and can create and destroy that resource on demand. DeviceResourceDescriptors  are managed by a ResourceRegistry.  Since:  3.1  See Also:  ResourceManager    
978,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/IExportedPreferences.html,"extends org.osgi.service.prefs.Preferences This interface describes Eclipse extensions to the preference  story. It provides means for both preference and node change  listeners.    Clients may implement this interface.    Since:  3.0  See Also:  Preferences    
extends IEclipsePreferences Represents a node in the preference hierarchy which is used in  the import/export mechanism.    This interface is not intended to be implemented by clients.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
979,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/DeviceData.html,extends Object    
980,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchListener.html,Interface for listening to workbench lifecycle events.    This interface may be implemented by clients.    Since:  3.2  See Also:  IWorkbench.addWorkbenchListener(org.eclipse.ui.IWorkbenchListener)_  IWorkbench.removeWorkbenchListener(org.eclipse.ui.IWorkbenchListener)    
981,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWindowListener.html,Interface for listening to window lifecycle events.    This interface may be implemented by clients.      
982,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/IModelResourceHandler.html,This handler allows clients load_ create and save model resources  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.    
983,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/operations/IWorkbenchOperationSupport.html,An instance of this interface provides support for managing a  a shared operations history and an shared undo context at the IWorkbench  level.    This interface is not intended to be extended or implemented by clients.    Since:  3.1  See Also:  IWorkbench.getOperationSupport()  Restriction:  This interface is not intended to be implemented by clients.    
984,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ILocalWorkingSetManager.html,"A working set manager stores working sets and provides property   change notification when a working set is added or removed.    The workbench working set manager can be accessed using   IWorkbench#getWorkingSetManager()      This interface is not intended to be implemented by clients.    Since:  2.0 initial version_ 3.0 added createWorkingSet(IMemento)  See Also:  IWorkingSet  Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkingSetManager A local working set manager can be used to manage a set of  working sets independently from the working sets managed by   the global working set manager. A local working set manager   can be saved and restored using the methods saveState   and restoreState. A new local working set manager can be created   using IWorkbench.createLocalWorkingSetManager().  Clients of local working set managers are responsible for calling   IWorkingSetManager.dispose() when the working sets it manages   are no longer needed.    This interface is not intended to be implemented or extended by clients.    Since:  3.1  See Also:  IWorkbench.createLocalWorkingSetManager()  Restriction:  This interface is not intended to be implemented by clients.    "
985,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IDelayedLabelDecorator.html,extends ILabelDecorator A delayed label decorator is a label decorator that may not have a  decoration available immediately. This interface defines the methods for  requesting the preparation of a decorator for an object and for querying  if the decorator is ready. Interested parties should register an  ILabelProviderListener with a delayed label decorator in order to be informed  when the decoration is ready.  Since:  3.0    
986,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IDecoratorManager.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends ILabelDecorator A delayed label decorator is a label decorator that may not have a  decoration available immediately. This interface defines the methods for  requesting the preparation of a decorator for an object and for querying  if the decorator is ready. Interested parties should register an  ILabelProviderListener with a delayed label decorator in order to be informed  when the decoration is ready.  Since:  3.0    
A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider A label decorator decorates the label text and image for some element.  The original label text and image are obtained by some other means_  for example by a label provider.  See Also:  ILabelProvider    
extends IDelayedLabelDecorator Manages the decorators contributed via the decorators extension point.  Views which allow decoration of their elements should use the label  decorator returned by getLabelDecorator().    This class is not intended to be implemented by clients.    Restriction:  This interface is not intended to be implemented by clients.    "
987,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IWorkbenchCommandSupport.html,An instance of this interface provides support for managing commands at the  IWorkbench level.    This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  ICommandService_  IHandlerService  Restriction:  This interface is not intended to be implemented by clients.    
988,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/IWorkbenchContextSupport.html, An instance of this interface provides support for managing contexts at the  IWorkbench level. This provides the functionality necessary to  enabled contexts_ disable or enabled the key binding service_ as well as  register shells as particular types of windows.    This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  IContextService_  IBindingService  Restriction:  This interface is not intended to be implemented by clients.    
989,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISaveableFilter.html,A filter for selecting Saveables.  Since:  3.3  See Also:  IWorkbench.saveAll(org.eclipse.jface.window.IShellProvider_ org.eclipse.jface.operation.IRunnableContext_ ISaveableFilter_ boolean)    
990,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/INavigationHistory.html,Manages a list of entries to keep a history of locations on editors_  enabling the user to go back and forward without losing context.    The history is a list of INavigationLocation and a pointer  to the current location. Whenever the back or forward action runs the  history restores the previous or next location.  The back and/or forward actions should not change the content of the history  in any way.    If the user steps N times in one direction (back or forward) and then N times to  the oposite direction_ the editor and location should be exactly the same as before.    Clients must guarantee that the current location is  always in the history_ which can be done either by marking  a new location or by updating the current location.    Not intended to be implemented by clients.  Since:  2.1  Restriction:  This interface is not intended to be implemented by clients.    
991,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IReusableEditor.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IEditorPart Interface for reusable editors.     An editors may support changing its input so that   the workbench may change its contents instead of   opening a new editor.    "
992,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPersistableEditor.html,"Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IPersistable An editor can implement this interface and participate in the workbench  session save/restore cycle using IMemento_ similar to how  IViewPart currently works.    Refer to IWorkbenchPart for the part lifecycle.      If a memento is available_ restoreState(*) will be inserted into the editor  startup.    editor.init(site_ input)  editor.restoreState(memento)  editor.createPartControl(parent)  ...      On workbench shutdown_ the editor state will be persisted when the editor  references are saved.    Since:  3.3    "
993,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISizeProvider.html,Interface implemented by objects that are capable of computing a preferred  size.  Since:  3.1    
994,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/ISaveHandler.html, Since:  1.0  Restriction:  This interface is not intended to be referenced by clients.    
995,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IHandler2.html,extends IHandler Extend the IHandler interface to provide some context for isEnabled()  requests. Clients should use AbstractHandler unless they need to  provide their own listener mechanism.  Since:  3.4  See Also:  AbstractHandler    
996,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/commands/ActionHandler.html,"A handler is the pluggable piece of a command that handles execution. Each  command can have zero or more handlers associated with it (in general)_ of  which only one will be active at any given moment in time. When the command  is asked to execute_ it will simply pass that request on to its active  handler_ if any.  Since:  3.1  See Also:  AbstractHandler    
extends IHandler Extend the IHandler interface to provide some context for isEnabled()  requests. Clients should use AbstractHandler unless they need to  provide their own listener mechanism.  Since:  3.4  See Also:  AbstractHandler    
extends AbstractHandler  This class adapts instances of IAction to  IHandler.    Since:  3.1    "
997,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/intro/IIntroSite.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
 A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends IAdaptable_ IShellProvider_ IServiceLocator The common interface between the workbench and its parts_ including pages  within parts.    The workbench site supports a few services by  default. If these services are used to allocate resources_ it is important to  remember to clean up those resources after you are done with them. Otherwise_  the resources will exist until the workbench site is disposed. The supported  services are:    ICommandService  IContextService  IHandlerService  IBindingService. Resources allocated through this service will  not be cleaned up until the workbench shuts down.    This interface is not intended to be implemented or extended by clients.    Since:  2.0  See Also:  IWorkbenchPartSite_  IPageSite  Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkbenchSite The primary interface between an intro part and the workbench.    The workbench exposes its implemention of intro part sites via this   interface_ which is not intended to be implemented or extended by clients.    Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    "
998,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/INestableKeyBindingService.html,extends IKeyBindingService  A service that is capable of nesting other services within itself. This   allows lower level components to query for a service provider in a   hierarchical fashion_ and for information to be resolved in a hierarchical  manner      This interface is not intended to be implemented or extended by clients.    Since:  2.1.3  Restriction:  This interface is not intended to be implemented by clients.    
999,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IPluginDescriptor.html,A plug-in descriptor contains information about a plug-in  obtained from the plug-in's manifest (plugin.xml) file.    Plug-in descriptors are platform-defined objects that exist  in the plug-in registry independent of whether a plug-in has  been started. In contrast_ a plug-in's runtime object   (getPlugin) generally runs plug-in-defined code.    See Also:  getPlugin()  Restriction:  This interface is not intended to be implemented by clients.    
1000,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/progress/IJobRunnable.html,Interface for runnables that can be run as jobs.  Since:  3.3    
1001,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/SubCoolBarManager.html,"A contribution manager organizes contributions to such UI components  as menus_ toolbars and status lines.    A contribution manager keeps track of a list of contribution  items. Each contribution item may has an optional identifier_ which can be used  to retrieve items from a manager_ and for positioning items relative to  each other. The list of contribution items can be subdivided into named groups   using special contribution items that serve as group markers.      The IContributionManager interface provides general  protocol for adding_ removing_ and retrieving contribution items.  It also provides convenience methods that make it convenient  to contribute actions. This interface should be implemented  by all objects that wish to manage contributions.      There are several implementions of this interface in this package_  including ones for menus (MenuManager)_  tool bars (ToolBarManager)_  and status lines (StatusLineManager).      
extends IContributionManager The ICoolBarManager interface provides protocol for managing  contributions to a cool bar. A cool bar manager delegates responsibility for  creating child controls to its contribution items by calling  IContributionItem.fill(CoolBar_ int).    This interface is internal to the framework; it should not be implemented  outside the framework. This package provides a concrete cool bar manager  implementation_ CoolBarManager_ which  clients may instantiate or subclass.    Since:  3.0  See Also:  ToolBarContributionItem    
extends SubContributionManager implements ICoolBarManager A SubCoolBarManager monitors the additional and removal of   items from a parent manager so that visibility of the entire set can be changed as a  unit.  Since:  3.0    "
1002,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/IObservableValue.html#getValueType(),extends IObservable A value whose changes can be tracked by value change listeners.  Since:  1.0  See Also:  AbstractObservableValue  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
1003,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/WritableValue.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable A value whose changes can be tracked by value change listeners.  Since:  1.0  See Also:  AbstractObservableValue  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends AbstractObservableValue Mutable (writable) implementation of IObservableValue that will maintain a value and fire  change events when the value changes.    This class is thread safe. All state accessing methods must be invoked from  the current realm. Methods for adding and removing  listeners may be invoked from any thread.    Since:  1.0    "
1004,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/ObservableListContentProvider.html,"A content provider mediates between the viewer's model  and the viewer itself.  See Also:  ContentViewer.setContentProvider(IContentProvider)    
extends IContentProvider An interface to content providers for structured viewers.  See Also:  StructuredViewer    
extends Object implements IStructuredContentProvider A content provider for  AbstractTableViewer or AbstractListViewer that provides  elements of an IObservableList when set as the viewer's input.  Objects of this class listen for changes to the observable list_ and will  insert and remove viewer elements to reflect observed changes.  Since:  1.1  Restriction:  This class is not intended to be subclassed by clients.    "
1005,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/ObservableSetContentProvider.html,"A content provider mediates between the viewer's model  and the viewer itself.  See Also:  ContentViewer.setContentProvider(IContentProvider)    
extends IContentProvider An interface to content providers for structured viewers.  See Also:  StructuredViewer    
extends Object implements IStructuredContentProvider A content provider for  AbstractTableViewer or AbstractListViewer that provides  elements of an IObservableSet when set as the viewer's input. Objects  of this class listen for changes to the observable set_ and will insert and  remove viewer elements to reflect observed changes.  Since:  1.1  Restriction:  This class is not intended to be subclassed by clients.    "
1006,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ListViewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends AbstractListViewer A concrete viewer based on an SWT List control.    This class is not intended to be subclassed. It is designed to be  instantiated with a pre-existing SWT List control and configured  with a domain-specific content provider_ label provider_ element filter (optional)_  and element sorter (optional).    Note that the SWT List control only supports the display of strings_ not icons.  If you need to show icons for items_ use TableViewer instead.    See Also:  TableViewer  Restriction:  This class is not intended to be subclassed by clients.    "
1007,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/WritableSet.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    
extends Set_ IObservableCollection A set whose changes can be tracked by set change listeners.  Since:  1.0  See Also:  AbstractObservableSet_  ObservableSet  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends ObservableSet Mutable (writable) implementation of IObservableSet.      This class is thread safe. All state accessing methods must be invoked from  the current realm. Methods for adding and removing  listeners may be invoked from any thread.    Since:  1.0    "
1008,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IViewerLabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider Extends IBaseLabelProvider with the methods  to update the label for a given element. The label is represented by a   ViewerLabel.  Unlike ILabelProvider_ this allows the text and image to be  set in the same request_ rather than via separate requests.     It also allows the current values for the text and image to be considered by   the label provider_ allowing for potential optimizations.  For example_ decorating label providers that run in the background can hold off  applying an update to a previously populated label until the decoration is ready_  thereby reducing flicker.    Since:  3.0  See Also:  IDelayedLabelDecorator    "
1009,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/ObservableSetTreeContentProvider.html,"A content provider mediates between the viewer's model  and the viewer itself.  See Also:  ContentViewer.setContentProvider(IContentProvider)    
extends IContentProvider An interface to content providers for structured viewers.  See Also:  StructuredViewer    
A content provider mediates between the viewer's model  and the viewer itself.  See Also:  ContentViewer.setContentProvider(IContentProvider)    
extends IContentProvider An interface to content providers for structured viewers.  See Also:  StructuredViewer    
extends IStructuredContentProvider An interface to content providers for tree-structure-oriented  viewers.  See Also:  AbstractTreeViewer    
extends Object implements ITreeContentProvider An ITreeContentProvider for use with an AbstractTreeViewer_  which uses the provided set factory to obtain the  elements of a tree. Objects of this class listen for changes to each  IObservableSet created by the factory_ and will insert and remove  viewer elements to reflect the observed changes.  Since:  1.2  Restriction:  This class is not intended to be subclassed by clients.    "
1010,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TableCursor.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Canvas A TableCursor provides a way for the user to navigate around a Table  using the keyboard. It also provides a mechanism for selecting an  individual cell in a table.    For a detailed example of using a TableCursor to navigate to a cell and then edit it see  http://git.eclipse.org/c/platform/eclipse.platform.swt.git/tree/examples/org.eclipse.swt.snippets/src/org/eclipse/swt/snippets/Snippet96.java .      Styles:  BORDER  Events:  Selection_ DefaultSelection  Since:  2.0  See Also:  TableCursor snippets_  Sample code and further information    "
1011,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/ControlEditor.html,"extends Object A ControlEditor is a manager for a Control that appears above a composite and tracks with the  moving and resizing of that composite. It can be used to display one control above   another control. This could be used when editing a control that does not have editing   capabilities by using a text editor or for launching a dialog by placing a button   above a control.  Here is an example of using a ControlEditor:    Canvas canvas = new Canvas(shell_ SWT.BORDER);  canvas.setBounds(10_ 10_ 300_ 300);   Color color = new Color(null_ 255_ 0_ 0);  canvas.setBackground(color);  ControlEditor editor = new ControlEditor (canvas);  // The editor will be a button in the bottom right corner of the canvas.  // When selected_ it will launch a Color dialog that will change the background   // of the canvas.  Button button = new Button(canvas_ SWT.PUSH);  button.setText(""Select Color..."");  button.addSelectionListener (new SelectionAdapter() {  public void widgetSelected(SelectionEvent e) {  ColorDialog dialog = new ColorDialog(shell);  dialog.open();  RGB rgb = dialog.getRGB();  if (rgb != null) {  if (color != null) color.dispose();  color = new Color(null_ rgb);  canvas.setBackground(color);  }    }  });  editor.horizontalAlignment = SWT.RIGHT;  editor.verticalAlignment = SWT.BOTTOM;  editor.grabHorizontal = false;  editor.grabVertical = false;  Point size = button.computeSize(SWT.DEFAULT_ SWT.DEFAULT);  editor.minimumWidth = size.x;  editor.minimumHeight = size.y;  editor.setEditor (button);    See Also:  Sample code and further information    "
1012,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/validation/MultiValidator.html,"extends ValidationStatusProvider A validator for cross-constraints between observables.      Some practical examples of cross-constraints:    A start date cannot be later than an end date    A list of percentages should add up to 100%      Example: require two integer fields to contain either both even or both odd  numbers.      DataBindingContext dbc = new DataBindingContext();    IObservableValue target0 = SWTObservables.observeText(text0_ SWT.Modify);  IObservableValue target1 = SWTObservables.observeText(text1_ SWT.Modify);    // Binding in two stages (from target to middle_ then from middle to model)  // simplifies the validation logic. Using the middle observables saves  // the trouble of converting the target values (Strings) to the model type  // (integers) manually during validation.  final IObservableValue middle0 = new WritableValue(null_ Integer.TYPE);  final IObservableValue middle1 = new WritableValue(null_ Integer.TYPE);  dbc.bind(target0_ middle0_ null_ null);  dbc.bind(target1_ middle1_ null_ null);    // Create the multi-validator  MultiValidator validator = new MultiValidator() {  protected IStatus validate() {  // Calculate the validation status  Integer value0 = (Integer) middle0.getValue();  Integer value1 = (Integer) middle1.getValue();  if (Math.abs(value0.intValue()) % 2 != Math.abs(value1.intValue()) % 2)  return ValidationStatus  .error(""Values must be both even or both odd"");  return ValidationStatus.ok();  }  };  dbc.addValidationStatusProvider(validator);    // Bind the middle observables to the model observables.   IObservableValue model0 = new WritableValue(new Integer(2)_ Integer.TYPE);  IObservableValue model1 = new WritableValue(new Integer(4)_ Integer.TYPE);  dbc.bind(middle0_ model0_ null_ null);  dbc.bind(middle1_ model1_ null_ null);        MultiValidator can also prevent invalid data from being copied to model. This  is done by wrapping each target observable in a validated observable_ and  then binding the validated observable to the model.        ...    // Validated observables do not change value until the validator passes.   IObservableValue validated0 = validator.observeValidatedValue(middle0);  IObservableValue validated1 = validator.observeValidatedValue(middle1);  IObservableValue model0 = new WritableValue(new Integer(2)_ Integer.TYPE);  IObservableValue model1 = new WritableValue(new Integer(4)_ Integer.TYPE);  // Bind to the validated value_ not the middle/target  dbc.bind(validated0_ model0_ null_ null);  dbc.bind(validated1_ model1_ null_ null);      Note: No guarantee is made as to the order of updates when multiple validated  observables change value at once (i.e. multiple updates pending when the  status becomes valid). Therefore the model may be in an invalid state after  the first but before the last pending update.  Since:  1.1    "
1013,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/IViewerObservableValue.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable A value whose changes can be tracked by value change listeners.  Since:  1.0  See Also:  AbstractObservableValue  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends IObservable IObservable observing a JFace Viewer.  Since:  1.2    
extends IObservableValue_ IViewerObservable IObservableValue observing a JFace Viewer.  Since:  1.2    "
1014,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/SelectObservableValue.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable A value whose changes can be tracked by value change listeners.  Since:  1.0  See Also:  AbstractObservableValue  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends AbstractObservableValue An observable value which behaves similarly to the <select> and  <option> HTML tags. A SelectObservableValue has a number of options  added to it via the addOption(Object_ IObservableValue) method. The  value of the SelectObservableValue is the value of whichever option's  observable has a value of Boolean.TRUE_ or null if none of the observable's  values are Boolean.TRUE.  Since:  1.2  Restriction:  This class is not intended to be subclassed by clients.    "
1015,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/ObservableListTreeContentProvider.html,"A content provider mediates between the viewer's model  and the viewer itself.  See Also:  ContentViewer.setContentProvider(IContentProvider)    
extends IContentProvider An interface to content providers for structured viewers.  See Also:  StructuredViewer    
A content provider mediates between the viewer's model  and the viewer itself.  See Also:  ContentViewer.setContentProvider(IContentProvider)    
extends IContentProvider An interface to content providers for structured viewers.  See Also:  StructuredViewer    
extends IStructuredContentProvider An interface to content providers for tree-structure-oriented  viewers.  See Also:  AbstractTreeViewer    
extends Object implements ITreeContentProvider An ITreeContentProvider for use with an AbstractTreeViewer_  which uses the provided list factory to obtain the  elements of a tree. Object of this class listen for changes to each  IObservableList created by the factory_ and will insert and remove  viewer elements to reflect the observed changes.  Since:  1.2  Restriction:  This class is not intended to be subclassed by clients.    "
1016,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/ObservableMapLabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider Extends IBaseLabelProvider with the methods  to provide the text and/or image for the label of a given element.   Used by most structured viewers_ except table viewers.    
A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider Extends IBaseLabelProvider with the methods  to provide the text and/or image for each column of a given element.   Used by table viewers.  See Also:  TableViewer    
extends LabelProvider implements ILabelProvider_ ITableLabelProvider A label provider based on one or more observable maps that track attributes  that this label provider uses for display. Clients may customize by  subclassing and overriding getColumnText(Object_ int)_  getColumnImage(Object_ int)_ for tables or trees with columns_ or by  implementing additional mixin interfaces for colors_ fonts etc.  Since:  1.1    "
1017,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/ProgressIndicator.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite A control for showing progress feedback for a long running operation. This  control supports both determinate and indeterminate SWT progress bars. For  indeterminate progress_ we don't have to know the total amount of work in  advance and no worked method needs to be called.    "
1018,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewerEditorDeactivationEvent.html,extends EventObject This event is fired when an editor deactivated  Since:  3.3  See Also:  Serialized Form  Restriction:  This class is not intended to be subclassed by clients.    
1019,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewerEditorActivationEvent.html,extends EventObject This event is passed on when a cell-editor is going to be activated  Since:  3.3  See Also:  Serialized Form    
1020,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewerEditorActivationListener.html,extends Object Parties interested in activation and deactivation of editors extend this  class and implement any or all of the methods  Since:  3.3    
1021,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeViewerFocusCellManager.html,extends Object This class is responsible to provide the concept of cells for Tree.  This concept is needed to provide features like editor activation with the  keyboard  Since:  3.3    
1022,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewerEditorActivationStrategy.html,extends Object This class is responsible to determine if a cell selection event is triggers  an editor activation. Implementors can extend and overwrite to implement  custom editing behavior  Since:  3.3    
1023,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TextCellEditor.html,extends CellEditor A cell editor that manages a text entry field.  The cell editor's value is the text string itself.    This class may be instantiated or subclassed.      
1024,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TableTreeViewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
extends AbstractTreeViewer A concrete viewer based on a SWT TableTree control.    This class is not intended to be subclassed outside the viewer framework. It  is designed to be instantiated with a pre-existing SWT table tree control and  configured with a domain-specific content provider_ label provider_ element  filter (optional)_ and element sorter (optional).      Content providers for table tree viewers must implement the  ITreeContentProvider interface.      Label providers for table tree viewers must implement either the  ITableLabelProvider or the ILabelProvider  interface (see TableTreeViewer.setLabelProvider for more  details).    Restriction:  This class is not intended to be subclassed by clients.    "
1025,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TableViewerFocusCellManager.html,extends Object This class is responsible to provide the concept of cells for Table.  This concept is needed to provide features like editor activation with the  keyboard  Since:  3.3    
1026,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CheckboxCellEditor.html,extends CellEditor A cell editor that manages a checkbox.  The cell editor's value is a boolean.    This class may be instantiated; it is not intended to be subclassed.      Note that this implementation simply fakes it and does does not create  any new controls. The mere activation of this editor means that the value  of the check box is being toggled by the end users; the listener method  applyEditorValue is immediately called to signal the change.    Restriction:  This class is not intended to be subclassed by clients.    
1027,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewerEditor.html,extends Object This is the base for all editor implementations of Viewers. ColumnViewer  implementors have to subclass this class and implement the missing methods  Since:  3.3  See Also:  TableViewerEditor_  TreeViewerEditor    
1028,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/DelegatingStyledCellLabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends StyledCellLabelProvider A DelegatingStyledCellLabelProvider is a  StyledCellLabelProvider that delegates requests for the styled string  and the image to a  DelegatingStyledCellLabelProvider.IStyledLabelProvider.      Existing label providers can be enhanced by implementing  DelegatingStyledCellLabelProvider.IStyledLabelProvider so they can be  used in viewers with styled labels.        The DelegatingStyledCellLabelProvider.IStyledLabelProvider can  optionally implement IColorProvider and IFontProvider to  provide foreground and background color and a default font.    Since:  3.4    "
1029,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/FocusCellOwnerDrawHighlighter.html,extends FocusCellHighlighter A concrete implementation of FocusCellHighlighter using by setting  the control into owner draw mode and highlighting the currently selected  cell. To make the use this class you should create the control with the  SWT.FULL_SELECTION bit set    This class can be subclassed to configure how the coloring of the selected  cell.  Since:  3.3    
1030,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ComboBoxCellEditor.html,extends CellEditor A cell editor that presents a list of items in a combo box. The cell editor's  value is the zero-based index of the selected item.    This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    
1031,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CellNavigationStrategy.html,extends Object This class implementation the strategy how the table is navigated using the  keyboard.      Subclasses can implement their custom navigation algorithms    Since:  3.3    
1032,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerRow.html,extends Object implements Cloneable ViewerRow is the abstract superclass of the part that represents items in a  Table or Tree. Implementors of ColumnViewer have to provide a  concrete implementation for the underlying widget  Since:  3.3    
1033,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/FocusCellHighlighter.html,extends Object  Since:  3.3    
1034,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/DefaultToolTip.html,extends ToolTip Default implementation of ToolTip that provides an iconofied label with font  and color controls by subclass.  Since:  3.3    
1035,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/ContentProposalAdapter.html,extends Object ContentProposalAdapter can be used to attach content proposal behavior to a  control. This behavior includes obtaining proposals_ opening a popup dialog_  managing the content of the control relative to the selections in the popup_  and optionally opening up a secondary popup to further describe proposals.    A number of configurable options are provided to determine how the control  content is altered when a proposal is chosen_ how the content proposal popup  is activated_ and whether any filtering should be done on the proposals as  the user types characters.    This class provides some overridable methods to allow clients to manually  control the popup. However_ most of the implementation remains private.  Since:  3.2    
1036,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Spinner.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class are selectable user interface  objects that allow the user to enter and modify numeric  values.    Note that although this class is a subclass of Composite_  it does not make sense to add children to it_ or set a layout on it.      Styles:  READ_ONLY_ WRAP  Events:  Selection_ Modify_ Verify    IMPORTANT: This class is not intended to be subclassed.    Since:  3.1  See Also:  Spinner snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
1037,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/progress/IElementCollector.html,IElementCollector is a type that allows for the incremental update of a  collection of objects. This used for updating trees incrementally with  a progress monitor so that the update can be reported.  Since:  3.0  See Also:  IDeferredWorkbenchAdapter_  DeferredTreeContentManager    
1038,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/ITextEditor.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IEditorPart Interface to a text editor. This interface defines functional extensions to  IEditorPart as well as the configuration capabilities of a text editor.    Text editors are configured with an IDocumentProvider which delivers a textual  presentation (IDocument) of the editor's input. The editor works on the document and  forwards all input element related calls_ such as save_ to the document provider.  The provider also delivers the input's annotation model which is used by the editor's vertical  ruler.      Clients may implement this interface from scratch_ but the recommended way is to subclass the  abstract base class AbstractTextEditor.      In order to provided backward compatibility for clients of ITextEditor_ extension  interfaces are used to provide a means of evolution. The following extension interfaces exist:    ITextEditorExtension since version 2.0 introducing status  fields_ read-only state and ruler context menu listeners.  ITextEditorExtension2 since version 2.1 introducing  modifiable state for the editor input and validate state handling.  ITextEditorExtension3 since version 3.0 adding input state  and change information control.  ITextEditorExtension4 since version 3.2 adding annotation  navigation and revision information display.  ITextEditorExtension5 since version 3.5 adding block  selection mode.    See Also:  IDocumentProvider_  IAnnotationModel_  ITextEditorExtension_  ITextEditorExtension2_  ITextEditorExtension3_  ITextEditorExtension4_  ITextEditorExtension5    "
1039,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/IDocumentProvider.html,A document provider maps between domain elements and documents. A document provider has the  following responsibilities:  create an annotation model of a domain model element    create and manage a textual representation_ i.e._ a document_ of a domain model element    create and save the content of domain model elements based on given documents    update the documents this document provider manages for domain model elements to changes  directly applied to those domain model elements    notify all element state listeners about changes directly applied to domain model elements  this document provider manages a document for_ i.e. the document provider must know which changes  of a domain model element are to be interpreted as element moves_ deletes_ etc.    Text editors use document providers to bridge the gap between their input elements and the  documents they work on. A single document provider may be shared between multiple editors; the  methods take the editors' input elements as a parameter.    This interface may be implemented by clients; or subclass the standard abstract base class  AbstractDocumentProvider.      In order to provided backward compatibility for clients of IDocumentProvider_  extension interfaces are used to provide a means of evolution. The following extension interfaces  exist:    IDocumentProviderExtension since version 2.0 introducing  state validation_ extended read-only handling and synchronization.  IDocumentProviderExtension2 since version 2.1 introducing  adding support for a global progress monitor.  IDocumentProviderExtension3 since version 3.0 adding  a predicate for querying synchronization state.  IDocumentProviderExtension4 since version 3.1 adding  a predicate for querying an element's the content description.  IDocumentProviderExtension5 since version 3.2 adding  the ability to detect a non-synchronized exception.    See Also:  IDocument_  AbstractDocumentProvider_  IDocumentProviderExtension_  IDocumentProviderExtension2_  IDocumentProviderExtension3_  IDocumentProviderExtension4_  IDocumentProviderExtension5    
1040,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IDocument.html,An IDocument represents text providing support for  text manipulation    positions    partitions    line information    document change listeners    document partition change listeners    A document allows to set its content and to manipulate it. For manipulation  a document provides the replace method which substitutes a given  string for a specified text range in the document. On each document change_ all  registered document listeners are informed exactly once.    Positions are stickers to the document's text that are updated when the  document is changed. Positions are updated by IPositionUpdaters. Position  updaters are managed as a list. The list defines the sequence in which position  updaters are invoked. This way_ position updaters may rely on each other.  Positions are grouped into categories. A category is a ordered list of positions.  the document defines the order of position in a category based on the position's offset  based on the implementation of the method computeIndexInCategory.  Each document must support a default position category whose name is specified by this  interface.    A document can be considered consisting of a sequence of not overlapping partitions.  A partition is defined by its offset_ its length_ and its type. Partitions are  updated on every document manipulation and ensured to be up-to-date when the document  listeners are informed. A document uses an IDocumentPartitioner to  manage its partitions. A document may be unpartitioned which happens when there is no  partitioner. In this case_ the document is considered as one single partition of a  default type. The default type is specified by this interface. If a document change  changes the document's partitioning all registered partitioning listeners are  informed exactly once. The extension interface IDocumentExtension3  introduced in version 3.0 extends the concept of partitions and allows a document to  not only manage one but multiple partitioning. Each partitioning has an id which must  be used to refer to a particular partitioning.    An IDocument provides methods to map line numbers and character  positions onto each other based on the document's line delimiters. When moving text  between documents using different line delimiters_ the text must be converted to  use the target document's line delimiters.    An IDocument does not care about mixed line delimiters. Clients who  want to ensure a single line delimiter in their document should use the line  delimiter returned by TextUtilities.getDefaultLineDelimiter(IDocument).    IDocument throws BadLocationException if the parameters of  queries or manipulation requests are not inside the bounds of the document. The purpose  of this style of exception handling is    prepare document for multi-thread access    allow clients to implement backtracking recovery methods    prevent clients from up-front contract checking when dealing with documents.      A document support for searching has deprecated since version 3.0. The recommended way  for searching is to use a FindReplaceDocumentAdapter.    In order to provide backward compatibility for clients of IDocument_ extension  interfaces are used to provide a means of evolution. The following extension interfaces  exist:    IDocumentExtension since version 2.0 introducing the concept  of post notification replaces in order to allow document listeners to manipulate the document  while receiving a document change notification   IDocumentExtension2 since version 2.1 introducing configuration  methods for post notification replaces and document change notification.   IDocumentExtension3 since version 3.0 replacing the original  partitioning concept by allowing multiple partitionings at the same time and introducing zero-  length partitions in conjunction with the distinction between open and closed partitions.   IDocumentExtension4 since version 3.1 introducing the  concept of rewrite sessions. A rewrite session is a sequence of document replace operations  that form a semantic unit. It also introduces a modification stamp and the ability to  set the initial line delimiter and to query the default line delimiter.    Clients may implement this interface and its extension interfaces or use the default  implementation provided by AbstractDocument and Document.  See Also:  IDocumentExtension_  IDocumentExtension2_  IDocumentExtension3_  IDocumentExtension4_  Position_  IPositionUpdater_  IDocumentPartitioner_  ILineTracker_  IDocumentListener_  IDocumentPartitioningListener    
1041,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/FindReplaceDocumentAdapter.html,extends Object implements CharSequence Provides search and replace operations on  IDocument.    Replaces  IDocument.search(int_ String_ boolean_ boolean_ boolean).  Since:  3.0    
1042,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IRegion.html,A region describes a certain range in an indexed text store. Text stores are  for example documents or strings. A region is defined by its offset into the  text store and its length.    A region is considered a value object. Its offset and length do not change  over time.    Clients may implement this interface or use the standard implementation  Region.      
1043,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonViewerWorkbenchSite.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends IAdaptable Provides context for extensions including a valid shell_ a selection  provider_ and a unique identifier corresponding to the abstract viewer behind  the viewer site.  Since:  3.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
extends ICommonViewerSite Provides a page_ set of action bars_ menu registration callback_ and active  window.  Since:  3.2  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
1044,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/contentoutline/IContentOutlinePage.html,extends IPage_ ISelectionProvider Marker-style interface for a content outline page. This interface defines  the minimum requirement for pages within the content outline view_ namely  they must be pages (implement IPage) and provide selections  (implement ISelectionProvider).    Access to a content outline page begins when an editor is activated. When  activation occurs_ the content outline view will ask the editor for its  content outline page. This is done by invoking   getAdapter(IContentOutlinePage.class) on the editor.   If the editor returns a page_ the view then creates the controls for that  page (using createControl) and makes the page visible.      Clients may implement this interface from scratch_ or subclass the  abstract base class ContentOutlinePage.      Note that this interface extends ISelectionProvider.  This is no longer required in the case of implementors who also   implement IPageBookViewPage (or extend Page)  as they are now passed an IPageSite during their initialization   and this site can be configured with a selection provider.   However to avoid a breaking change   1) this interface will continue to extend ISelectionProvider   2) if an IContentOutlinePage does not set a selection provider for its   site_ the ContentOutline will continue to use the page itself for   this purpose.     See Also:  ContentOutlinePage    
1045,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/contentoutline/ContentOutlinePage.html,"A listener which is notified when a viewer's selection changes.  See Also:  ISelection_  ISelectionProvider_  SelectionChangedEvent    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends IPage Interface for a page in a pagebook view.    Pages should implement this interface.    See Also:  PageBookView_  Page    
extends IPage_ ISelectionProvider Marker-style interface for a content outline page. This interface defines  the minimum requirement for pages within the content outline view_ namely  they must be pages (implement IPage) and provide selections  (implement ISelectionProvider).    Access to a content outline page begins when an editor is activated. When  activation occurs_ the content outline view will ask the editor for its  content outline page. This is done by invoking   getAdapter(IContentOutlinePage.class) on the editor.   If the editor returns a page_ the view then creates the controls for that  page (using createControl) and makes the page visible.      Clients may implement this interface from scratch_ or subclass the  abstract base class ContentOutlinePage.      Note that this interface extends ISelectionProvider.  This is no longer required in the case of implementors who also   implement IPageBookViewPage (or extend Page)  as they are now passed an IPageSite during their initialization   and this site can be configured with a selection provider.   However to avoid a breaking change   1) this interface will continue to extend ISelectionProvider   2) if an IContentOutlinePage does not set a selection provider for its   site_ the ContentOutline will continue to use the page itself for   this purpose.     See Also:  ContentOutlinePage    
extends Page implements IContentOutlinePage_ ISelectionChangedListener An abstract base class for content outline pages.    Clients who are defining an editor may elect to provide a corresponding  content outline page. This content outline page will be presented to the  user via the standard Content Outline View (the user decides whether their  workbench window contains this view) whenever that editor is active.  This class should be subclassed.      Internally_ each content outline page consists of a standard tree viewer;   selections made in the tree viewer are reported as selection change events   by the page (which is a selection provider). The tree viewer is not created   until createPage is called; consequently_ subclasses must extend  createControl to configure the tree viewer with a proper content   provider_ label provider_ and input element.    Subclasses may provide a hint for constructing the tree viewer  using getTreeStyle().    Note that those wanting to use a control other than internally created  TreeViewer will need to implement   IContentOutlinePage directly rather than subclassing this class.      "
1046,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/IPropertySheetPage.html,"extends EventListener Interface for listening to selection changes.    This interface may be implemented by clients.    See Also:  ISelectionService.addSelectionListener(ISelectionListener)_  ISelectionService.addSelectionListener(String_ ISelectionListener)_  INullSelectionListener    
extends IPage_ ISelectionListener Interface for a property sheet page that appears in a property sheet view.  This interface defines the minimum requirement for pages within the  property sheet view_ namely they must be pages (implement IPage)  be prepared to contribute actions to the property sheet view's tool bar  and status line_ and listen for selection changes in the active part.    Clients may implement this interface from scratch if the property sheet  viewer's default page is unsuitable for displaying a part's properties.    See Also:  PropertySheetPage    "
1047,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextSelection.html,"Interface for a selection.  See Also:  ISelectionProvider_  ISelectionChangedListener_  SelectionChangedEvent    
extends ISelection This interface represents a textual selection. A text selection is a range of  characters. Although a text selection is a snapshot taken at a particular  point in time_ it must not copy the line information and the selected text  from the selection provider.    If_ for example_ the selection provider is a text viewer (  ITextViewer)_ and a text selection is created  for the range [5_ 10]_ the line formation for the 5th character must not be  determined and remembered at the point of creation. It can rather be  determined at the point_ when getStartLine is called. If the  source viewer range [0_ 15] has been changed in the meantime between the  creation of the text selection object and the invocation of  getStartLine_ the returned line number may differ from the  line number of the 5th character at the point of creation of the text  selection object.    The contract of this interface is that weak in order to allow for efficient  implementations.    Clients may implement this interface or use the default implementation  provided by TextSelection.  See Also:  TextSelection    "
1048,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/IPropertyDescriptor.html,A descriptor for a property to be presented by a standard property sheet page  (PropertySheetPage). These descriptors originate with property   sources (IPropertySource).    A property descriptor carries the following information:    property id (required)  display name (required)  brief description of the property (optional)  category for grouping related properties (optional)  label provider used to display the property value (optional)  cell editor for changing the property value (optional)  help context id (optional)      Clients may implement this interface to provide specialized property   descriptors; however_ there are standard implementations declared in  this package that take care of the most common cases:    PropertyDescriptor - read-only property  TextPropertyDescriptor - edits with a   TextCellEditor  CheckboxPropertyDescriptor - edits with a   CheckboxCellEditor  ComboBoxPropertyDescriptor - edits with a  ComboBoxCellEditor  ColorPropertyDescriptor - edits with a   ColorCellEditor    See Also:  IPropertySource.getPropertyDescriptors()    
1049,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/PropertyDescriptor.html,"A descriptor for a property to be presented by a standard property sheet page  (PropertySheetPage). These descriptors originate with property   sources (IPropertySource).    A property descriptor carries the following information:    property id (required)  display name (required)  brief description of the property (optional)  category for grouping related properties (optional)  label provider used to display the property value (optional)  cell editor for changing the property value (optional)  help context id (optional)      Clients may implement this interface to provide specialized property   descriptors; however_ there are standard implementations declared in  this package that take care of the most common cases:    PropertyDescriptor - read-only property  TextPropertyDescriptor - edits with a   TextCellEditor  CheckboxPropertyDescriptor - edits with a   CheckboxCellEditor  ComboBoxPropertyDescriptor - edits with a  ComboBoxCellEditor  ColorPropertyDescriptor - edits with a   ColorCellEditor    See Also:  IPropertySource.getPropertyDescriptors()    
extends Object implements IPropertyDescriptor Standard implementation for property descriptors.    The required attributes of property descriptors (id and display name) are  passed to the constructor; the optional attributes can be configured using  the various set methods (all have reasonable default values):    setDescription  setCategory  setLabelProvider  setHelpContexts  Subclasses should reimplement getPropertyEditor to provide a  cell editor for changing the value; otherwise the property will be   effectively read only.      There are several concrete subclasses provided in this package that cover  the most common cases:    TextPropertyDescriptor - edits with a   TextCellEditor  ComboBoxPropertyDescriptor - edits with a  ComboBoxCellEditor  ColorPropertyDescriptor - edits with a   ColorCellEditor      "
1050,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ElementListSelectionDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends AbstractElementListSelectionDialog A class to select elements out of a list of elements.  Since:  2.0    "
1051,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/TabbedPropertySheetPage.html,"A listener which is notified when a label provider's state changes.  See Also:  IBaseLabelProvider.addListener(org.eclipse.jface.viewers.ILabelProviderListener)_  IBaseLabelProvider.removeListener(org.eclipse.jface.viewers.ILabelProviderListener)    
extends EventListener Interface for listening to selection changes.    This interface may be implemented by clients.    See Also:  ISelectionService.addSelectionListener(ISelectionListener)_  ISelectionService.addSelectionListener(String_ ISelectionListener)_  INullSelectionListener    
extends IPage Interface for a page in a pagebook view.    Pages should implement this interface.    See Also:  PageBookView_  Page    
extends EventListener Interface for listening to selection changes.    This interface may be implemented by clients.    See Also:  ISelectionService.addSelectionListener(ISelectionListener)_  ISelectionService.addSelectionListener(String_ ISelectionListener)_  INullSelectionListener    
extends IPage_ ISelectionListener Interface for a property sheet page that appears in a property sheet view.  This interface defines the minimum requirement for pages within the  property sheet view_ namely they must be pages (implement IPage)  be prepared to contribute actions to the property sheet view's tool bar  and status line_ and listen for selection changes in the active part.    Clients may implement this interface from scratch if the property sheet  viewer's default page is unsuitable for displaying a part's properties.    See Also:  PropertySheetPage    
extends Page implements IPropertySheetPage_ ILabelProviderListener A property sheet page that provides a tabbed UI.    "
1052,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/editor/FormEditor.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
Minimal interface to a page change provider. Used for dialogs which can  switch between multiple pages.  Since:  3.1    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
extends MultiPageEditorPart This class forms a base of multi-page form editors that typically use one or  more pages with forms and one page for raw source of the editor input.    Pages are added 'lazily' i.e. adding a page reserves a tab for it but does  not cause the page control to be created. Page control is created when an  attempt is made to select the page in question. This allows editors with  several tabs and complex pages to open quickly.    Subclasses should extend this class and implement addPages  method. One of the two addPage methods should be called to  contribute pages to the editor. One adds complete (standalone) editors as  nested tabs. These editors will be created right away and will be hooked so  that key bindings_ selection service etc. is compatible with the one for the  standalone case. The other method adds classes that implement  IFormPage interface. These pages will be created lazily and  they will share the common key binding and selection service. Since 3.1_  FormEditor is a page change provider. It allows listeners to attach to it and  get notified when pages are changed. This new API in JFace allows dynamic  help to update on page changes.  Since:  3.0    "
1053,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/FormText.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Canvas This class is a read-only text control that is capable of rendering wrapped  text. Text can be rendered as-is or by parsing the formatting XML tags.  Independently_ words that start with http:// can be converted into hyperlinks  on the fly.    When configured to use formatting XML_ the control requires the root element  form to be used and requires any ampersand (&) characters in the text to  be replaced by the entity &amp;. The following tags can be children of the  form element:    p - for defining paragraphs. The following attributes are  allowed:  vspace - if set to 'false'_ no vertical space will be added  (default is 'true')    li - for defining list items. The following attributes are  allowed:  vspace - the same as with the p tag  style - could be 'bullet' (default)_ 'text' and 'image'  value - not used for 'bullet'. For text_ it is the value of the  text that is rendered as a bullet. For image_ it is the href of the image to  be rendered as a bullet.  indent - the number of pixels to indent the text in the list item    bindent - the number of pixels to indent the bullet itself      Text in paragraphs and list items will be wrapped according to the width of  the control. The following tags can appear as children of either p or  li elements:    img - to render an image. Element accepts attribute 'href' that  is a key to the Image set using 'setImage' method. Vertical  position of image relative to surrounding text is optionally controlled by  the attribute align that can have values top_ middle  and bottom  a - to render a hyperlink. Element accepts attribute 'href' that  will be provided to the hyperlink listeners via HyperlinkEvent object. The  element also accepts 'nowrap' attribute (default is false). When set to  'true'_ the hyperlink will not be wrapped. Hyperlinks automatically created  when 'http://' is encountered in text are not wrapped.  b - the enclosed text will use bold font.  br - forced line break (no attributes).  span - the enclosed text will have the color and font specified  in the element attributes. Color is provided using 'color' attribute and is a  key to the Color object set by 'setColor' method. Font is provided using  'font' attribute and is a key to the Font object set by 'setFont' method. As with  hyperlinks_ it is possible to block wrapping by setting 'nowrap' to true  (false by default).    control (new in 3.1) - to place a control that is a child of the  text control. Element accepts attribute 'href' that is a key to the Control  object set using 'setControl' method. Optionally_ attribute 'fill' can be set  to true to make the control fill the entire width of the text.  Form text is not responsible for creating or disposing controls_ it only  places them relative to the surrounding text. Similar to img_  vertical position of the control can be set using the align  attribute. In addition_ width and height attributes can  be used to force the dimensions of the control. If not used_  the preferred control size will be used.      None of the elements can nest. For example_ you cannot have b inside  a span . This was done to keep everything simple and transparent.  Since 3.1_ an exception to this rule has been added to support nesting images  and text inside the hyperlink tag (a). Image enclosed in the  hyperlink tag acts as a hyperlink_ can be clicked on and can accept and  render selection focus. When both text and image is enclosed_ selection and  rendering will affect both as a single hyperlink.      Since 3.1_ it is possible to select text. Text selection can be  programmatically accessed and also copied to clipboard. Non-textual objects  (images_ controls etc.) in the selection range are ignored.    Care should be taken when using this control. Form text is not an HTML  browser and should not be treated as such. If you need complex formatting  capabilities_ use Browser widget. If you need editing capabilities and  font/color styles of text segments is all you need_ use StyleText widget.  Finally_ if all you need is to wrap text_ use SWT Label widget and create it  with SWT.WRAP style.  Since:  3.0  See Also:  FormToolkit_  TableWrapLayout    "
1054,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ILayoutExtension.html,Classes that extend abstract class Layout and implement this interface can  take part in layout computation of the TableWrapLayout manager. This layout  uses alternative algorithm that computes columns before rows. It allows it  to 'flow' wrapped text proportionally (similar to the way web browser  renders tables). Custom layout managers that implement this interface will  allow TableWrapLayout to properly compute width hint to pass.  Since:  3.0  See Also:  TableWrapLayout_  ColumnLayout    
1055,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/TableWrapLayout.html,"Classes that extend abstract class Layout and implement this interface can  take part in layout computation of the TableWrapLayout manager. This layout  uses alternative algorithm that computes columns before rows. It allows it  to 'flow' wrapped text proportionally (similar to the way web browser  renders tables). Custom layout managers that implement this interface will  allow TableWrapLayout to properly compute width hint to pass.  Since:  3.0  See Also:  TableWrapLayout_  ColumnLayout    
extends Layout implements ILayoutExtension This implementation of the layout algorithm attempts to position controls in  the composite using a two-pass autolayout HTML table algorithm recommended by  HTML 4.01 W3C specification (see  http://www.w3.org/TR/html4/appendix/notes.html#h-B.5.2.2). The main  differences with GridLayout is that it has two passes and that width and  height are not calculated in the same pass.    The advantage of the algorithm over GridLayout is that it is capable of  flowing text controls capable of line wrap. These controls do not have  natural 'preferred size'. Instead_ they are capable of providing the required  height if the width is set. Consequently_ this algorithm first calculates the  widths that will be assigned to columns_ and then passes those widths to the  controls to calculate the height. When a composite with this layout is a  child of the scrolling composite_ they should interact in such a way that  reduction in the scrolling composite width results in the reflow and increase  of the overall height.    If none of the columns contain expandable and wrappable controls_ the  end-result will be similar to the one provided by GridLayout. The difference  will show up for layouts that contain controls whose minimum and maximum  widths are not the same.  Since:  3.0  See Also:  TableWrapData    "
1056,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ControlContribution.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
extends ContributionItem An abstract contribution item implementation for adding an arbitrary   SWT control to a tool bar.   Note_ however_ that these items cannot be contributed to menu bars.    The createControl framework method must be implemented  by concrete subclasses.      "
1057,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/editor/IFormPage.html,extends IEditorPart Interface that all GUI pages need to implement in order  to be added to FormEditor part. The interface makes   several assumptions:  The form page has a managed form  The form page has a unique id  The form page can be GUI but can also wrap a complete  editor class (in that case_ it should return true  from isEditor() method).  The form page is lazy i.e. understands that   its part control will be created at the last possible  moment. .    Existing editors can be wrapped by implementing  this interface. In this case_ 'isEditor' should return true.  A common editor to wrap in TextEditor that is  often added to show the raw source code of the file open into  the multi-page editor.  Since:  3.0    
1058,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/editor/FormPage.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
extends IEditorPart Interface that all GUI pages need to implement in order  to be added to FormEditor part. The interface makes   several assumptions:  The form page has a managed form  The form page has a unique id  The form page can be GUI but can also wrap a complete  editor class (in that case_ it should return true  from isEditor() method).  The form page is lazy i.e. understands that   its part control will be created at the last possible  moment. .    Existing editors can be wrapped by implementing  this interface. In this case_ 'isEditor' should return true.  A common editor to wrap in TextEditor that is  often added to show the raw source code of the file open into  the multi-page editor.  Since:  3.0    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
extends EditorPart implements IFormPage A base class that all pages that should be added to FormEditor must subclass.  Form page has an instance of PageForm that extends managed form. Subclasses  should override method 'createFormContent(ManagedForm)' to fill the form with  content. Note that page itself can be loaded lazily (on first open).  Consequently_ the call to create the form content can come after the editor  has been opened for a while (in fact_ it is possible to open and close the  editor and never create the form because no attempt has been made to show the  page).  Since:  3.0    "
1059,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/TableWrapData.html,extends Object Layout data used in conjunction with TableWrapLayout.  Children in a composite that uses this layout should call setLayoutData  and pass an instance of this class to control physical placement in  the parent.  Since:  3.0  See Also:  TableWrapLayout    
1060,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ImageHyperlink.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Hyperlink This class extends hyperlink widget by adding the capability to render an  image relative to the text. If no text has been set_ only image will be  shown. Images for hover and active states can be set in addition to the  normal state image.    When image is taller than the text_ additional style can be provided to  control vertical alignment (supported values are SWT.TOP_ SWT.BOTTOM and  SWT.CENTER).    The class does not need to be sublassed but it is allowed to do so if some  aspect of the image hyperlink needs to be modified.      Styles:  SWT.WRAP_ SWT.BOTTOM_ SWT.TOP_ SWT.MIDDLE_ SWT.LEFT_ SWT.RIGHT  Since:  3.0    "
1061,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/KeySequenceText.html,extends Object  A wrapper around the SWT text widget that traps literal key presses and  converts them into key sequences for display. There are two types of key  strokes that are displayed: complete and incomplete. A complete key stroke is  one with a natural key_ while an incomplete one has no natural key.  Incomplete key strokes are only displayed until they are made complete or  their component key presses are released.    Since:  3.1    
1062,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/INavigationLocationProvider.html,Should be implemented by editors that wish to contribute to the  navigation history. The message createNavigationLocation  will be sent when a new location is marked in the history.  Since:  2.1    
1063,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/ITextEditorExtension.html,Extension interface for ITextEditor. Adds  the following functions:  status fields    read-only state of the editor's input    ruler context menu listeners.    Since:  2.0    
1064,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/ITextEditorExtension2.html,Extension interface for ITextEditor. Adds  the following functions:  modifiable state of the editor's input  validate state of editor input  Since:  2.1    
1065,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/ITextEditorExtension3.html,Extension interface for ITextEditor. Adds  the following functions:  insert mode management  Since:  3.0    
1066,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/ITextEditorExtension4.html,Extension interface for ITextEditor. Adds  the following functions:  annotation navigation  revision information display    This interface may be implemented by clients.    Since:  3.2    
1067,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/ITextEditorExtension5.html,Extension interface for ITextEditor. Adds the following  functions:  block selection mode    This interface may be implemented by clients.    Since:  3.5    
1068,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/AbstractTextEditor.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Should be implemented by editors that wish to contribute to the  navigation history. The message createNavigationLocation  will be sent when a new location is marked in the history.  Since:  2.1    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IPersistable An editor can implement this interface and participate in the workbench  session save/restore cycle using IMemento_ similar to how  IViewPart currently works.    Refer to IWorkbenchPart for the part lifecycle.      If a memento is available_ restoreState(*) will be inserted into the editor  startup.    editor.init(site_ input)  editor.restoreState(memento)  editor.createPartControl(parent)  ...      On workbench shutdown_ the editor state will be persisted when the editor  references are saved.    Since:  3.3    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IEditorPart Interface for reusable editors.     An editors may support changing its input so that   the workbench may change its contents instead of   opening a new editor.    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
Represents a source of Saveable objects (units of saveability). Workbench  parts that show more than one unit of saveability_ or whose units of  saveability change over time_ should implement this interface in order to  provide better integration with workbench facilities like the Save command_  prompts to save on part close or shutdown_ etc.    IMPORTANT: As of 3.2_ implementers of ISaveablesSource must  satisfy the following conditions:    If ISaveablesSource is implemented by an IWorkbenchPart:  the part must implement ISaveablePart  if any of its Saveable objects are dirty_ the part must return  true from ISaveablePart.isDirty()  the part must return true from  ISaveablePart.isSaveOnCloseNeeded() if it is dirty (the default  behaviour implemented by EditorPart)  the part must not implement ISaveablePart2    If ISaveablesSource is implemented by a non-part (possible as of 3.2.1 and 3.3):  the Workbench's ISaveablesLifecycleListener (obtained from the  Workbench by calling  workbench.getService(ISaveablesLifecycleListener.class)) must  be notified of any change to the result of getSaveables()   getActiveSaveables() should be implemented to return an empty array      If any of these conditions are not met_ it is undefined whether the Workbench  will prompt to save dirty Saveables when closing parts or the Workbench.      These conditions may be relaxed in future releases.    Since:  3.2    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IEditorPart Interface to a text editor. This interface defines functional extensions to  IEditorPart as well as the configuration capabilities of a text editor.    Text editors are configured with an IDocumentProvider which delivers a textual  presentation (IDocument) of the editor's input. The editor works on the document and  forwards all input element related calls_ such as save_ to the document provider.  The provider also delivers the input's annotation model which is used by the editor's vertical  ruler.      Clients may implement this interface from scratch_ but the recommended way is to subclass the  abstract base class AbstractTextEditor.      In order to provided backward compatibility for clients of ITextEditor_ extension  interfaces are used to provide a means of evolution. The following extension interfaces exist:    ITextEditorExtension since version 2.0 introducing status  fields_ read-only state and ruler context menu listeners.  ITextEditorExtension2 since version 2.1 introducing  modifiable state for the editor input and validate state handling.  ITextEditorExtension3 since version 3.0 adding input state  and change information control.  ITextEditorExtension4 since version 3.2 adding annotation  navigation and revision information display.  ITextEditorExtension5 since version 3.5 adding block  selection mode.    See Also:  IDocumentProvider_  IAnnotationModel_  ITextEditorExtension_  ITextEditorExtension2_  ITextEditorExtension3_  ITextEditorExtension4_  ITextEditorExtension5    
Extension interface for ITextEditor. Adds  the following functions:  status fields    read-only state of the editor's input    ruler context menu listeners.    Since:  2.0    
Extension interface for ITextEditor. Adds  the following functions:  modifiable state of the editor's input  validate state of editor input  Since:  2.1    
Extension interface for ITextEditor. Adds  the following functions:  insert mode management  Since:  3.0    
Extension interface for ITextEditor. Adds  the following functions:  annotation navigation  revision information display    This interface may be implemented by clients.    Since:  3.2    
Extension interface for ITextEditor. Adds the following  functions:  block selection mode    This interface may be implemented by clients.    Since:  3.5    
extends EditorPart implements ITextEditor_ IReusableEditor_ ITextEditorExtension_ ITextEditorExtension2_ ITextEditorExtension3_ ITextEditorExtension4_ ITextEditorExtension5_ INavigationLocationProvider_ ISaveablesSource_ IPersistableEditor Abstract base implementation of a text editor.    Subclasses are responsible for configuring the editor appropriately. The standard text editor_  TextEditor_ is one such example.      If a subclass calls setEditorContextMenuId the  argument is used as the id under which the editor's context menu is registered for extensions. If  no id is set_ the context menu is registered under [editor_id].EditorContext whereby  [editor_id] is replaced with the editor's part id. If the editor is instructed to run in version  1.0 context menu registration compatibility mode_ the latter form of the registration even  happens if a context menu id has been set via setEditorContextMenuId. If no id is set while in compatibility mode_ the menu is registered  under DEFAULT_EDITOR_CONTEXT_MENU_ID.      If a subclass calls setRulerContextMenuId the  argument is used as the id under which the ruler's context menu is registered for extensions. If  no id is set_ the context menu is registered under [editor_id].RulerContext whereby  [editor_id] is replaced with the editor's part id. If the editor is instructed to run in version  1.0 context menu registration compatibility mode_ the latter form of the registration even  happens if a context menu id has been set via setRulerContextMenuId. If no id is set while in compatibility mode_ the menu is registered under  DEFAULT_RULER_CONTEXT_MENU_ID.      As of 3.5_ contributers can contribute editor and ruler context menu actions to all subclasses of  this class by using COMMON_EDITOR_CONTEXT_MENU_ID and  COMMON_RULER_CONTEXT_MENU_ID.      "
1069,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/ICommand.html,A builder command names a builder and supplies a table of  name-value argument pairs.    Changes to a command will only take effect if the modified command is installed  into a project description via IProjectDescription.setBuildSpec(ICommand[]).    See Also:  IProjectDescription  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
1070,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/AggregateValidationStatus.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable A value whose changes can be tracked by value change listeners.  Since:  1.0  See Also:  AbstractObservableValue  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends ComputedValue This class can be used to aggregate status values from a data binding context  into a single status value. Instances of this class can be used as an  observable value with a value type of IStatus_ or the static methods  can be called directly if an aggregated status result is only needed once.  Since:  1.0    "
1071,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/conversion/NumberToStringConverter.html,"A one-way converter.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should subclass Converter.  Restriction:  This interface is not intended to be extended by clients.    
extends Converter Converts a Number to a String using NumberFormat.format(...).  This class is thread safe.  Since:  1.0    "
1072,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/conversion/StringToNumberConverter.html,"A one-way converter.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should subclass Converter.  Restriction:  This interface is not intended to be extended by clients.    
extends org.eclipse.core.internal.databinding.validation.NumberFormatConverter Converts a String to a Number using NumberFormat.parse(...).  This class is thread safe.  Since:  1.0    "
1073,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/UpdateListStrategy.html,extends Object Customizes a Binding between two observable  lists. The following behaviors can be customized via the strategy:  Conversion  Automatic processing    Conversion:  When elements are added they can be converted to the  destination element type.      Automatic processing:  The processing to perform when the source observable changes. This behavior  is configured via policies provided on construction of the strategy (e.g.  POLICY_NEVER_ POLICY_ON_REQUEST_ POLICY_UPDATE).    Since:  1.0  See Also:  DataBindingContext.bindList(IObservableList_ IObservableList_  UpdateListStrategy_ UpdateListStrategy)_  IConverter    
1074,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/ListChangeEvent.html,extends ObservableEvent List change event describing an incremental change of an  IObservableList object.  Since:  1.0  See Also:  Serialized Form    
1075,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/MapChangeEvent.html,extends ObservableEvent Map change event describing an incremental change of an  IObservableMap object.  Since:  1.0  See Also:  Serialized Form    
1076,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/AbstractObservable.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends Object implements IObservable  Since:  1.0    "
1077,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/WritableMap.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends Map_ IObservable Observable Map.  Since:  1.1  See Also:  AbstractObservableMap_  ObservableMap  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends ObservableMap  This class is thread safe. All state accessing methods must be invoked from  the current realm. Methods for adding and removing  listeners may be invoked from any thread.    Since:  1.0    "
1078,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/ComputedValue.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable A value whose changes can be tracked by value change listeners.  Since:  1.0  See Also:  AbstractObservableValue  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends AbstractObservableValue A Lazily calculated value that automatically computes and registers listeners  on its dependencies as long as all of its dependencies are  IObservable objects. Any change to one of the observable dependencies  causes the value to be recomputed.    This class is thread safe. All state accessing methods must be invoked from  the current realm. Methods for adding and removing  listeners may be invoked from any thread.      Example: compute the sum of all elements in an IObservableList <  Integer >.        final IObservableList addends = WritableValue.withValueType(Integer.TYPE);  addends.add(new Integer(0));  addends.add(new Integer(1));  addends.add(new Integer(2));    IObservableValue sum = new ComputedValue() {  protected Object calculate() {  int sum = 0;  for (Iterator it = addends.iterator(); it.hasNext();) {  Integer addend = (Integer) it.next();  sum += addend.intValue();  }  return sum;  }  };    System.out.println(sum.getValue()); // => 3    addends.add(new Integer(10));  System.out.println(sum.getValue()); // => 13    Since:  1.0    "
1079,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/ObservablesManager.html,extends Object An observables manager can be used for lifecycle management of  IObservable objects.  Since:  1.0  Restriction:  This class is not intended to be subclassed by clients.    
1080,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/util/ILogger.html,A mechanism to log errors throughout JFace Data Binding.    Clients may provide their own implementation to change how errors are logged  from within JFace Data Binding.    Since:  1.1  See Also:  Policy.getLog()_  Policy.setLog(ILogger)    
1081,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/UpdateValueStrategy.html,extends Object Customizes a Binding between two observable  values. The following behaviors can be customized via the strategy:  Validation  Conversion  Automatic processing    The update phases are:    Validate after get - validateAfterGet(Object)  Conversion - convert(Object)  Validate after conversion - validateAfterConvert(Object)  Validate before set - validateBeforeSet(Object)  Value set - doSet(IObservableValue_ Object)      Validation:  Validators validate the value at multiple phases in the  update process. Statuses returned from validators are aggregated into a  MultiStatus until a status of ERROR or  CANCEL is encountered. Either of these statuses will abort the  update process. These statuses are available as the  binding validation status.      Conversion:  A converter will convert the value from the type of the  source observable into the type of the destination. The strategy has the  ability to default converters for common scenarios.      Automatic processing:  The processing to perform when the source observable changes. This behavior  is configured via policies provided on construction of the strategy (e.g.  POLICY_NEVER_ POLICY_CONVERT_ POLICY_ON_REQUEST_  POLICY_UPDATE).    Since:  1.0  See Also:  DataBindingContext.bindValue(IObservableValue_ IObservableValue_  UpdateValueStrategy_ UpdateValueStrategy)_  ValidationStatusProvider.getValidationStatus()_  IValidator_  IConverter    
1082,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ContentViewer.html,"Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends Viewer A content viewer is a model-based adapter on a widget which accesses its  model by means of a content provider and a label provider.    A viewer's model consists of elements_ represented by objects.  A viewer defines and implements generic infrastructure for handling model   input_ updates_ and selections in terms of elements.  Input is obtained by querying an IContentProvider which returns  elements. The elements themselves are not displayed directly. They are  mapped to labels_ containing text and/or an image_ using the viewer's   ILabelProvider.      Implementing a concrete content viewer typically involves the following steps:      create SWT controls for viewer (in constructor) (optional)      initialize SWT controls from input (inputChanged)      define viewer-specific update methods      support selections (setSelection_ getSelection)        "
1083,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/conversion/Converter.html,"A one-way converter.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should subclass Converter.  Restriction:  This interface is not intended to be extended by clients.    
extends Object implements IConverter Abstract base class for converters.  Since:  1.0    "
1084,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IObserving.html,Mixin interface for IObservables that observe other objects.  Since:  1.0    
1085,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/IPropertyObservable.html,"Mixin interface for IObservables that observe other objects.  Since:  1.0    
extends IObserving Provides access to the details of property observables  Since:  1.2    "
1086,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IDecoratingObservable.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable Interface for observables which decorate other observables.  Since:  1.2  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    "
1087,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ToolTip.html,extends Widget Instances of this class represent popup windows that are used  to inform or warn the user.      Styles:  BALLOON_ ICON_ERROR_ ICON_INFORMATION_ ICON_WARNING  Events:  Selection    Note: Only one of the styles ICON_ERROR_ ICON_INFORMATION_  and ICON_WARNING may be specified.    IMPORTANT: This class is not intended to be subclassed.    Since:  3.2  See Also:  Tool Tips snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
1088,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Tray.html,extends Widget Instances of this class represent the system tray that is part  of the task bar status area on some operating systems.    Styles:  (none)  Events:  (none)    IMPORTANT: This class is not intended to be subclassed.    Since:  3.0  See Also:  Display.getSystemTray()_  Tray_ TrayItem snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
1089,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TrayItem.html,extends Item Instances of this class represent icons that can be placed on the  system tray or task bar status area.      Styles:  (none)  Events:  DefaultSelection_ MenuDetect_ Selection    IMPORTANT: This class is not intended to be subclassed.    Since:  3.0  See Also:  Tray_ TrayItem snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
1090,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/DialogSettings.html,"An interface to a storage mechanism for making dialog settings persistent.  The store manages a collection of key/value pairs. The keys must be strings  and the values can be either_ strings or array of strings. Convenience API to  convert primitive types to strings is provided.  See Also:  DialogSettings    
extends Object implements IDialogSettings Concrete implementation of a dialog settings (IDialogSettings)  using a hash table and XML. The dialog store can be read  from and saved to a stream. All keys and values must be strings or array of  strings. Primitive types are converted to strings.    This class was not designed to be subclassed.  Here is an example of using a DialogSettings:        DialogSettings settings = new DialogSettings(""root"");  settings.put(""Boolean1""_true);  settings.put(""Long1""_100);  settings.put(""Array1""_new String[]{""aaaa1""_""bbbb1""_""cccc1""});  DialogSettings section = new DialogSettings(""sectionName"");  settings.addSection(section);  section.put(""Int2""_200);  section.put(""Float2""_1.1);  section.put(""Array2""_new String[]{""aaaa2""_""bbbb2""_""cccc2""});  settings.save(""c:\\temp\\test\\dialog.xml"");      Restriction:  This class is not intended to be subclassed by clients.    "
1091,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/SimpleContentProposalProvider.html,"IContentProposalProvider provides an array of IContentProposals that are  appropriate for a textual dialog field_ given the field's current content and  the current cursor position.  Since:  3.2  See Also:  SimpleContentProposalProvider    
extends Object implements IContentProposalProvider SimpleContentProposalProvider is a class designed to map a static list of  Strings to content proposals.  Since:  3.2  See Also:  IContentProposalProvider    "
1092,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/IContentProposal.html,IContentProposal describes a content proposal to be shown. It consists of the  content that will be provided if the proposal is accepted_ an optional label  used to describe the content to the user_ and an optional description that  further elaborates the meaning of the proposal. It also includes a a  zero-based index position within the contents where the cursor should be  placed after a proposal is accepted.  Since:  3.2  See Also:  ContentProposal    
1093,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IconAndMessageDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends Dialog The IconAndMessageDialog is the abstract superclass of dialogs that have an  icon and a message as the first two widgets. In this dialog the icon and  message are direct children of the shell in order that they can be read by  accessibility tools more easily.    Note: Clients are expected to call createMessageArea(Composite)_  otherwise neither the icon nor the message will appear.      "
1094,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/DecoratingStyledCellLabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends DelegatingStyledCellLabelProvider A DecoratingStyledCellLabelProvider is a  DelegatingStyledCellLabelProvider that uses a nested  DelegatingStyledCellLabelProvider.IStyledLabelProvider to compute  styled text label and image and takes a ILabelDecorator to decorate  the label.      Use this label provider as a replacement for the  DecoratingLabelProvider when decorating styled text labels.        The DecoratingStyledCellLabelProvider will try to evaluate the text  decoration added by the ILabelDecorator and will apply the style  returned by getDecorationStyle(Object)      The ILabelDecorator can optionally implement IColorDecorator  and IFontDecorator to provide foreground and background color and  font decoration.    Since:  3.4    "
1095,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/IPersistentPreferenceStore.html,extends IPreferenceStore IPersistentPreferenceStore is a preference store that can   be saved.    
1096,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferenceStore.html,"extends IPreferenceStore IPersistentPreferenceStore is a preference store that can   be saved.    
The IPreferenceStore interface represents a table mapping  named preferences to values. If there is no value for a given name_  then that preferences's default value is returned; and if there is no  default value for that preference_ then a default-default value is returned.  The default-default values for the primitive types are as follows:  boolean = false  double = 0.0  float = 0.0f  int = 0  long = 0  String = """" (the empty string)    Thus a preference store maintains two values for each of a set of  names: a current value and a default value.  The typical usage is to establish the defaults for all known preferences  and then restore previously stored values for preferences whose values  were different from their defaults. After the current values of  the preferences have been modified_ it is a simple matter to write  out only those preferences whose values are different from their defaults.  This two-tiered approach to saving and restoring preference setting  minimized the number of preferences that need to be persisted; indeed_  the normal starting state does not require storing any preferences  at all.      A property change event is reported whenever a preferences current  value actually changes (whether through setValue_  setToDefault_ or other unspecified means). Note_ however_  that manipulating default values (with setDefault)  does not cause such events to be reported.      Clients who need a preference store may implement this interface or  instantiate the standard implementation PreferenceStore.    See Also:  PreferenceStore    
extends EventManager implements IPersistentPreferenceStore A concrete preference store implementation based on an internal  java.util.Properties object_ with support for persisting the  non-default preference values to files or streams.    This class was not designed to be subclassed.    See Also:  IPreferenceStore  Restriction:  This class is not intended to be subclassed by clients.    "
1097,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/BooleanFieldEditor.html,extends FieldEditor A field editor for a boolean type preference.    
1098,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/LabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider Extends IBaseLabelProvider with the methods  to provide the text and/or image for the label of a given element.   Used by most structured viewers_ except table viewers.    
extends BaseLabelProvider implements ILabelProvider A label provider implementation which_ by default_ uses an element's  toString value for its text and null for its  image.    This class may be used as is_ or subclassed to provide richer labels.  Subclasses may override any of the following methods:    isLabelProperty  getImage  getText  dispose      "
1099,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/ViewForm.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite Instances of this class implement a Composite that positions and sizes  children and allows programmatic control of layout and border parameters.   ViewForm is used in the workbench to lay out a view's label/menu/toolbar  local bar.    Note that although this class is a subclass of Composite_  it does not make sense to set a layout on it.      Styles:  BORDER_ FLAT  Events:  (None)    IMPORTANT: This class is not intended to be subclassed.    See Also:  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
1100,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/navigator/ResourceSorter.html,extends ViewerSorter Sorter for viewers that display items of type IResource.  The sorter supports two sort criteria:    NAME: Folders are given order precedence_ followed by files.  Within these two groups resources are ordered by name. All name comparisons  are case-insensitive.      TYPE: Folders are given order precedence_ followed by files.  Within these two groups resources are ordered by extension. All extension  comparisons are case-insensitive.      This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    
1101,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/DrillDownAdapter.html,"A listener which is notified when a viewer's selection changes.  See Also:  ISelection_  ISelectionProvider_  SelectionChangedEvent    
extends Object implements ISelectionChangedListener Implements a simple web style navigation metaphor for a TreeViewer.   Home_ back_ and ""drill into"" functions are supported for the viewer_    To use the DrillDownAdapter ..    Create an instance of TreeViewer.   Create a DrillDownAdapter for the viewer.   Create a container for your viewer with a toolbar or a popup menu.  Add actions for ""goBack""_ ""goHome""_ and ""goInto"" to either one by calling  addNavigationActions with the popup menu or toolbar.  If the input for the underlying viewer is changed by something other than the   adapter the reset method should be called. This will clear  the drill stack and update the navigation buttons to reflect the new   state of the underlying viewer.        "
1102,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/DecoratingLabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
Interface to provide color representation for a given element.  See Also:  IColorDecorator    
Interface to provide font representation for a given element.  Since:  3.0  See Also:  IFontDecorator    
A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider Extends IBaseLabelProvider with the methods  to provide the text and/or image for the label of a given element.   Used by most structured viewers_ except table viewers.    
A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider An extension to ILabelProvider that is given the   path of the element being decorated_ when it is available.  Since:  3.2    
A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider Extends IBaseLabelProvider with the methods  to update the label for a given element. The label is represented by a   ViewerLabel.  Unlike ILabelProvider_ this allows the text and image to be  set in the same request_ rather than via separate requests.     It also allows the current values for the text and image to be considered by   the label provider_ allowing for potential optimizations.  For example_ decorating label providers that run in the background can hold off  applying an update to a previously populated label until the decoration is ready_  thereby reducing flicker.    Since:  3.0  See Also:  IDelayedLabelDecorator    
extends LabelProvider implements ILabelProvider_ IViewerLabelProvider_ IColorProvider_ IFontProvider_ ITreePathLabelProvider A decorating label provider is a label provider which combines   a nested label provider and an optional decorator.  The decorator decorates the label text_ image_ font and colors provided by   the nested label provider.    "
1103,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/ICountable.html,Objects that are adaptable to ICountable can be used  as the default variable in a count expression.  Since:  3.3  See Also:  IAdaptable_  IAdapterManager    
1104,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/IIterable.html,Objects that are adaptable to IIterable can be used  as the default variable in an iterate expression.  Since:  3.3  See Also:  IAdaptable_  IAdapterManager    
1105,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IAggregateWorkingSet.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IPersistable Interface for asking an object to store its state in a memento.    This interface is typically included in interfaces where   persistance is required.    When the workbench is shutdown objects which implement this interface   will be persisted. At this time the getFactoryId method   is invoked to discover the id of the element factory that will be used   to re-create the object from a memento. Then the saveState   method is invoked to store the element data into a newly created memento.   The resulting mementos are collected up and written out to a single file.      During workbench startup these mementos are read from the file. The  factory Id for each is retrieved and mapped to an IElementFactory   which has been registered in the element factory extension point. If a   factory exists for the Id it will be engaged to re-create the original   object.    See Also:  IAdaptable_  IMemento_  IElementFactory    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IPersistable Interface for asking an object to store its state in a memento.    This interface is typically included in interfaces where   persistance is required.    When the workbench is shutdown objects which implement this interface   will be persisted. At this time the getFactoryId method   is invoked to discover the id of the element factory that will be used   to re-create the object from a memento. Then the saveState   method is invoked to store the element data into a newly created memento.   The resulting mementos are collected up and written out to a single file.      During workbench startup these mementos are read from the file. The  factory Id for each is retrieved and mapped to an IElementFactory   which has been registered in the element factory extension point. If a   factory exists for the Id it will be engaged to re-create the original   object.    See Also:  IAdaptable_  IMemento_  IElementFactory    
extends IPersistableElement_ IAdaptable A working set holds a number of IAdaptable elements.   A working set is intended to group elements for presentation to   the user or for operations on a set of elements.  Since:  2.0 initial version_ 3.0 now extends IPersistableElement_ 3.2 now extends IAdaptable  Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkingSet Contains a set of IWorkingSet.     Sets of working sets are used by viewers to contain all of the working  sets being shown. Sets can also be nested.    In classes that implement this_ the IWorkingSet.getElements() returns  all of the elements of each of the working sets in this set.    Instances of IWorkingSet can be cast to IAggregateWorkingSet if  IWorkingSet.isAggregateWorkingSet() is true.  Since:  3.5 initial version  Restriction:  This interface is not intended to be implemented by clients.    "
1106,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/ILogListener.html,extends EventListener A log listener is notified of entries added to a plug-in's log.    This interface can be used without OSGi running.    Clients may implement this interface.      
1107,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/contentoutline/ContentOutline.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
A listener which is notified when a viewer's selection changes.  See Also:  ISelection_  ISelectionProvider_  SelectionChangedEvent    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
Interface for listening to part lifecycle events.    This interface may be implemented by clients.    See Also:  IPartService.addPartListener(IPartListener)    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ IPersistable A view is a visual component within a workbench page. It is typically used to  navigate a hierarchy of information (like the workspace)_ open an editor_ or  display properties for the active editor. Modifications made in a view are  saved immediately (in contrast to an editor part_ which conforms to a more  elaborate open-save-close lifecycle).    Only one instance of a particular view type may exist within a workbench  page. This policy is designed to simplify part management for a user.      This interface may be implemented directly. For convenience_ a base  implementation is defined in ViewPart.      A view is added to the workbench in two steps:    A view extension is contributed to the workbench registry. This  extension defines the extension id and extension class.  The view is included in the default layout for a perspective.  Alternatively_ the user may open the view from the Perspective menu.      Views implement the IAdaptable interface; extensions are  managed by the platform's adapter manager.      As of 3.4_ views may optionally adapt to ISizeProvider if they have  a preferred size. The default presentation will make a best effort to  allocate the preferred size to a view if it is the only part in a stack. If  there is more than one part in the stack_ the constraints will be disabled  for that stack. The size constraints are adjusted for the size of the tab and  border trim. Note that this is considered to be a hint to the presentation_  and not all presentations may honor size constraints.    See Also:  IWorkbenchPage.showView(java.lang.String)_  ViewPart_  ISizeProvider    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
extends PageBookView implements ISelectionProvider_ ISelectionChangedListener Main class for the Content Outline View.    This standard view has id ""org.eclipse.ui.views.ContentOutline"".    When a content outline view notices an editor being activated_ it   asks the editor whether it has a content outline page to include  in the outline view. This is done using getAdapter:    IEditorPart editor = ...;  IContentOutlinePage outlinePage = (IContentOutlinePage) editor.getAdapter(IContentOutlinePage.class);  if (outlinePage != null) {  // editor wishes to contribute outlinePage to content outline view  }    If the editor supports a content outline page_ the editor instantiates  and configures the page_ and returns it. This page is then added to the   content outline view (a pagebook which presents one page at a time) and   immediately made the current page (the content outline view need not be  visible). If the editor does not support a content outline page_ the content  outline view shows a special default page which makes it clear to the user  that the content outline view is disengaged. A content outline page is free  to report selection events; the content outline view forwards these events   along to interested parties. When the content outline view notices a  different editor being activated_ it flips to the editor's corresponding  content outline page. When the content outline view notices an editor being  closed_ it destroys the editor's corresponding content outline page.      The workbench will automatically instantiate this class when a Content  Outline view is needed for a workbench window. This class was not intended  to be instantiated or subclassed by clients.    Restriction:  This class is not intended to be subclassed by clients.  Restriction:  This class is not intended to be instantiated by clients.    "
1108,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/testing/IWorkbenchPartTestable.html,This interface provides methods that allow introspection of workbench parts.  Instances may be obtained by calling  IAdaptable.getAdapter(Class) on  IWorkbenchPartSite.      This interface is not intended to be implemented or extended by clients.    Since:  3.3    
1109,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IHandler.html,A handler is the pluggable piece of a command that handles execution. Each  command can have zero or more handlers associated with it (in general)_ of  which only one will be active at any given moment in time. When the command  is asked to execute_ it will simply pass that request on to its active  handler_ if any.    This interface is not intended to be extended by clients.    Since:  3.0  See Also:  IHandler    
1110,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IHandler.html#removeHandlerListener(org.eclipse.ui.commands.IHandlerListener),A handler is the pluggable piece of a command that handles execution. Each  command can have zero or more handlers associated with it (in general)_ of  which only one will be active at any given moment in time. When the command  is asked to execute_ it will simply pass that request on to its active  handler_ if any.    This interface is not intended to be extended by clients.    Since:  3.0  See Also:  IHandler    
1111,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ActionHandler.html,"A handler is the pluggable piece of a command that handles execution. Each  command can have zero or more handlers associated with it (in general)_ of  which only one will be active at any given moment in time. When the command  is asked to execute_ it will simply pass that request on to its active  handler_ if any.    This interface is not intended to be extended by clients.    Since:  3.0  See Also:  IHandler    
extends AbstractHandler This class adapts instances of IAction to  IHandler.  Since:  3.0  See Also:  ActionHandler    "
1112,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/Parameterization.html,extends Object  A parameter with a specific value. This is usually a part of a  ParameterizedCommand_ which is used to refer to a command  with a collection of parameterizations.    Since:  3.1    
1113,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/menus/TextState.html,"extends PersistentState  A piece of state carrying a single String.      If this state is registered using INamedHandleStateIds.NAME or  INamedHandleStateIds.DESCRIPTION_ then this allows the handler to  communicate a textual change for a given command. This is typically used by  graphical applications to allow more specific text to be displayed in the  menus. For example_ ""Undo"" might become ""Undo Typing"" through the use of a  TextState.      Clients may instantiate this class_ but must not extend.    Since:  3.2  See Also:  INamedHandleStateIds    "
1114,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/handlers/RegistryRadioState.html,"Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
extends RadioState implements IExecutableExtension  A radio state that can be read from the registry. This stores a piece of  boolean state information that is grouped with other boolean state to form a  radio group. In a single radio group_ there can be at most one state who  value is Boolean.TRUE all the others must be Boolean.FALSE.      When parsing from the registry_ this state understands three parameters:  default_ which is the default value for this item;  persisted_ which is whether the state should be persisted  between sessions; id_ which is the identifier of the group to  which this radio handler belongs. The default parameter  defaults to false_ and the persisted parameter  defaults to true. If only one parameter is passed (i.e._  using the class name followed by a colon)_ then it is assumed to be the  id parameter. The id is required for this class  to function properly.      Clients may instantiate this class_ but must not extend.    Since:  3.2    "
1115,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/ILock.html,A lock is used to control access to an exclusive resource.    Locks are reentrant. That is_ they can be acquired multiple times by the same thread  without releasing. Locks are only released when the number of successful acquires   equals the number of successful releases.    Locks are capable of detecting and recovering from programming errors that cause  circular waiting deadlocks. When a deadlock between two or more ILock   instances is detected_ detailed debugging information is printed to the log file. The   locks will then automatically recover from the deadlock by employing a release   and wait strategy. One thread will lose control of the locks it owns_ thus breaking   the deadlock and allowing other threads to proceed. Once that thread's locks are   all available_ it will be given exclusive access to all its locks and allowed to proceed.   A thread can only lose locks while it is waiting on an acquire() call.       Successive acquire attempts by different threads are queued and serviced on  a first come_ first served basis.    It is very important that acquired locks eventually get released. Calls to release  should be done in a finally block to ensure they execute. For example:    try {  lock.acquire();  // ... do work here ...  } finally {  lock.release();  }    Note: although lock.acquire should never fail_ it is good practice to place   it inside the try block anyway. Releasing without acquiring is far less catastrophic   than acquiring without releasing.    Since:  3.0  See Also:  IJobManager.newLock()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
1116,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IImportWizard.html,"extends IWorkbenchWizard Interface for import wizards.    Clients should implement this interface and include the name of their class  in a wizard contributed to the workbench's import wizard extension point   (named ""org.eclipse.ui.importWizards"").  For example_ the plug-in's XML markup might contain:    <extension point=""org.eclipse.ui.importWizards"">  <wizard  id=""com.example.myplugin.blob""  name=""Blob File""  class=""com.example.myplugin.BlobFileImporter""  icon=""icons/import_blob_wiz.gif"">  <description>Import resources from a BLOB file</description>  <selection class=""org.eclipse.core.resources.IResource"" />   </wizard>  </extension>      See Also:  IWizard    "
1117,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/datatransfer/ExternalProjectImportWizard.html,"Interface for a wizard. A wizard maintains a list of wizard pages_  stacked on top of each other in card layout fashion.    The class Wizard provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if Wizard does not suit their needs.    See Also:  Wizard    
extends IWorkbenchWizard Interface for import wizards.    Clients should implement this interface and include the name of their class  in a wizard contributed to the workbench's import wizard extension point   (named ""org.eclipse.ui.importWizards"").  For example_ the plug-in's XML markup might contain:    <extension point=""org.eclipse.ui.importWizards"">  <wizard  id=""com.example.myplugin.blob""  name=""Blob File""  class=""com.example.myplugin.BlobFileImporter""  icon=""icons/import_blob_wiz.gif"">  <description>Import resources from a BLOB file</description>  <selection class=""org.eclipse.core.resources.IResource"" />   </wizard>  </extension>      See Also:  IWizard    
extends IWizard Implementors represent creation wizards that are to be  contributed to the workbench's creation wizard extension point.  See Also:  IWizard    
extends Wizard implements IImportWizard Standard workbench wizard for importing projects defined  outside of the currently defined projects into Eclipse.    This class may be instantiated and used without further configuration;  this class is not intended to be subclassed.      Example:    IWizard wizard = new ExternalProjectImportWizard();  wizard.init(workbench_ selection);  WizardDialog dialog = new WizardDialog(shell_ wizard);  dialog.open();    During the call to open_ the wizard dialog is presented to the  user. When the user hits Finish_ a project is created with the location  specified by the user.    Restriction:  This class is not intended to be subclassed by clients.    "
1118,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/YesNoCancelListSelectionDialog.html,extends ListSelectionDialog YesNoCancelListSelectionDialog is a list selection dialog that also allows  the user to select no as a result.    
1119,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/newresource/BasicNewProjectResourceWizard.html,"Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
Interface for a wizard. A wizard maintains a list of wizard pages_  stacked on top of each other in card layout fashion.    The class Wizard provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if Wizard does not suit their needs.    See Also:  Wizard    
extends IWorkbenchWizard Interface for creation wizards.    Clients should implement this interface and include the name of their class  in a wizard contributed to the workbench's creation wizard extension point   (named ""org.eclipse.ui.newWizards"").  For example_ the plug-in's XML markup might contain:    <extension point=""org.eclipse.ui.newWizards"">  <wizard  id=""com.example.myplugin.new.blob""  name=""Blob""  class=""com.example.myplugin.BlobCreator""  icon=""icons/new_blob_wiz.gif"">  <description>Create a new BLOB file</description>  <selection class=""org.eclipse.core.resources.IResource"" />   </wizard>  </extension>      See Also:  IWizard    
extends IWizard Implementors represent creation wizards that are to be  contributed to the workbench's creation wizard extension point.  See Also:  IWizard    
extends BasicNewResourceWizard implements IExecutableExtension Standard workbench wizard that creates a new project resource in the  workspace.    This class may be instantiated and used without further configuration; this  class is not intended to be subclassed.      Example:      IWorkbenchWizard wizard = new BasicNewProjectResourceWizard();  wizard.init(workbench_ selection);  WizardDialog dialog = new WizardDialog(shell_ wizard);  dialog.open();      During the call to open_ the wizard dialog is presented to  the user. When the user hits Finish_ a project resource with the  user-specified name is created_ the dialog closes_ and the call to  open returns.    Restriction:  This class is not intended to be subclassed by clients.    "
1120,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/WizardNewProjectReferencePage.html,"Interface for a page in a multi-page dialog.    
Minimal interface to a message provider. Used for dialog pages which can  provide a message with an icon.  Since:  2.0    
extends IDialogPage Interface for a wizard page.    The class WizardPage provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if WizardPage does not suit their needs.      
extends WizardPage Standard project reference page for a wizard that creates a   project resource.    This page may be used by clients as-is; it may be also be  subclassed to suit.      Example usage:    referencePage = new WizardNewProjectReferencePage(""basicReferenceProjectPage"");  referencePage.setTitle(""Project"");  referencePage.setDescription(""Select referenced projects."");        "
1121,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/SearchPattern.html,extends Object A search pattern defines how search results are found.      This class is intended to be subclassed by clients. A default behavior is  provided for each of the methods above_ that clients can override if they  wish.    Since:  3.3    
1122,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/ErrorDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends IconAndMessageDialog A dialog to display one or more errors to the user_ as contained in an  IStatus object. If an error contains additional detailed  information then a Details button is automatically supplied_ which shows or  hides an error details viewer when pressed by the user.      This dialog should be considered being a ""local"" way of error handling. It  cannot be changed or replaced by ""global"" error handling facility (  org.eclipse.ui.statushandler.StatusManager). If product defines  its own way of handling errors_ this error dialog may cause UI inconsistency_  so until it is absolutely necessary_ StatusManager should be  used.    See Also:  IStatus    "
1123,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/FilteredResourcesSelectionDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends FilteredItemsSelectionDialog Shows a list of resources to the user with a text entry field for a string  pattern used to filter the list of resources.  Since:  3.3    "
1124,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/common/NamedHandleObject.html," An object that is unique identifiable based on the combination of its class  and its identifier.    Since:  3.2  See Also:  HandleObject    
extends HandleObject A handle object that carries with it a name and a description. This type of  handle object is quite common across the commands code base. For example_  Command_ Context and Scheme.  Since:  3.1    "
1125,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/IStickyViewDescriptor.html,Supplemental view interface that describes various sticky characteristics  that a view may possess.    This interface is not intended to be implemented by clients.    Since:  3.1  See Also:  IViewRegistry_  IViewDescriptor  Restriction:  This interface is not intended to be implemented by clients.    
1126,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/navigator/ResourceNavigator.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ IPersistable A view is a visual component within a workbench page. It is typically used to  navigate a hierarchy of information (like the workspace)_ open an editor_ or  display properties for the active editor. Modifications made in a view are  saved immediately (in contrast to an editor part_ which conforms to a more  elaborate open-save-close lifecycle).    Only one instance of a particular view type may exist within a workbench  page. This policy is designed to simplify part management for a user.      This interface may be implemented directly. For convenience_ a base  implementation is defined in ViewPart.      A view is added to the workbench in two steps:    A view extension is contributed to the workbench registry. This  extension defines the extension id and extension class.  The view is included in the default layout for a perspective.  Alternatively_ the user may open the view from the Perspective menu.      Views implement the IAdaptable interface; extensions are  managed by the platform's adapter manager.      As of 3.4_ views may optionally adapt to ISizeProvider if they have  a preferred size. The default presentation will make a best effort to  allocate the preferred size to a view if it is the only part in a stack. If  there is more than one part in the stack_ the constraints will be disabled  for that stack. The size constraints are adjusted for the size of the tab and  border trim. Note that this is considered to be a hint to the presentation_  and not all presentations may honor size constraints.    See Also:  IWorkbenchPage.showView(java.lang.String)_  ViewPart_  ISizeProvider    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
Interface for views which support reveal and select.    This interface may be implemented by subclasses of ViewPart.  This interface is commonly used by a New wizard to reveal and select a  resource in a workbench part which it has just created.    See Also:  IViewPart_  ViewPart    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
extends ViewPart implements ISetSelectionTarget_ IResourceNavigator Implements the Resource Navigator view.    "
1127,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/TextActionHandler.html,extends Object Handles the redirection of the global Cut_ Copy_ Paste_ and  Select All actions to either the current inline text control  or the part's supplied action handler.    This class may be instantiated; it is not intended to be subclassed.    Example usage:    textActionHandler = new TextActionHandler(this.getViewSite().getActionBars());  textActionHandler.addText((Text)textCellEditor1.getControl());  textActionHandler.addText((Text)textCellEditor2.getControl());  textActionHandler.setSelectAllAction(selectAllAction);      Restriction:  This class is not intended to be subclassed by clients.    
1128,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/source/IVerticalRulerInfo.html,A vertical ruler is a visual component which may serve text viewers as an  annotation presentation area. The vertical ruler info provides interested  clients with the mapping and interaction aspect of the vertical ruler. This  covers the mapping between coordinates of the ruler's control and line  numbers based on the connected text viewer's document.  In order to provide backward compatibility for clients of  IVerticalRulerInfo_ extension interfaces are used as a means  of evolution. The following extension interfaces exist:  IVerticalRulerInfoExtension since  version 3.0 allowing custom annotation hovers and specific annotation models.    Since:  2.0  See Also:  IVerticalRulerInfoExtension    
1129,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/source/IVerticalRuler.html,"A vertical ruler is a visual component which may serve text viewers as an  annotation presentation area. The vertical ruler info provides interested  clients with the mapping and interaction aspect of the vertical ruler. This  covers the mapping between coordinates of the ruler's control and line  numbers based on the connected text viewer's document.  In order to provide backward compatibility for clients of  IVerticalRulerInfo_ extension interfaces are used as a means  of evolution. The following extension interfaces exist:  IVerticalRulerInfoExtension since  version 3.0 allowing custom annotation hovers and specific annotation models.    Since:  2.0  See Also:  IVerticalRulerInfoExtension    
extends IVerticalRulerInfo This interface defines a visual component which may serve text viewers as an  annotation presentation area. Implementers of this interface have to define  the presentation modus. This can either depend on the connected viewer's view  port or not. If the modus is view port dependent the ruler only shows those  annotations that are attached to document regions that are visible in the  view port. If independent_ the presented annotations can also be attached to  invisible document regions.  This interfaces comprises three contracts:  The vertical ruler retrieves the annotations it presents from an  annotation model.    The ruler is a visual component which must be integrated in a hierarchy  of SWT controls.    The ruler provides interested clients with mapping and interaction  information. This covers the mapping between coordinates of the ruler's  control and line numbers based on the connected text viewer's document (see  IVerticalRulerInfo).      In order to provide backward compatibility for clients of  IVerticalRuler_ extension interfaces are used as a means of  evolution. The following extension interfaces exist:    IVerticalRulerExtension since  version 2.0 introducing setters for font and mouse button activity location.    Clients may implement this interface or use the default implementation  provided by CompositeRuler and  VerticalRuler.  See Also:  IVerticalRulerExtension_  ITextViewer    "
1130,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextViewer.html,A text viewer connects a text widget with an  IDocument. The document is used as the  widget's text model.    It supports the following kinds of listeners:    view port listeners to inform about changes of the viewer's view port  text listeners to inform about changes of the document and the  subsequent viewer change  text input listeners to inform about changes of the viewer's input  document.  A text viewer supports a set of configuration options and plug-ins defining  its behavior:  undo manager  double click behavior  auto indentation  text hover  Installed plug-ins are not automatically activated. Plug-ins must be  activated with the activatePlugins call. Most plug-ins can be  defined per content type. Content types are derived from a partitioning of  the text viewer's input document. In case of documents that support multiple  partitionings_ the implementer is responsible for determining the  partitioning to use.    A text viewer also provides the concept of event consumption. Events handled  by the viewer can be filtered and processed by a dynamic event consumer. With  ITextViewerExtension_ this mechanism has been  replaced with the support for  VerifyKeyListener.    A text viewer provides several text editing functions_ some of them are  configurable_ through a text operation target interface. It also supports a  presentation mode in which it only shows a specified section of its document.  By calling setVisibleRegion clients define which section is  visible. Clients can get access to this section by calling  getVisibleRegion. The viewer's presentation mode does not  affect any client of the viewer other than text listeners. With  ITextViewerExtension5 the visible region  support has been reworked. With that extension interface_ text viewers are  allowed to show fractions of their input document. I.e. a widget selection of  two visually neighboring characters is no longer guaranteed to be two  neighboring characters in the viewer's input document. Thus_ viewers  implementing ITextViewerExtension5 are  potentially forced to change the fractions of the input document that are  shown when clients ask for the visible region.    In order to provide backward compatibility for clients of  ITextViewer_ extension interfaces are used as a means of  evolution. The following extension interfaces exist:    ITextViewerExtension since version 2.0  replacing the event consumer mechanism and introducing the concept of rewrite  targets and means to manage the viewer's redraw behavior  ITextViewerExtension2since version 2.1  adding a way to invalidate a viewer's presentation and setters for hovers.    ITextViewerExtension3 since version 2.1  which itself was replaced by  ITextViewerExtension5 in version 3.0  ITextViewerExtension4 since version 3.0  introducing focus handling for widget token keepers and the concept of text  presentation listeners.  ITextViewerExtension5 since version 3.0  extending the visible region concept with explicit handling and conversion  of widget and model coordinates.  ITextViewerExtension6 since version 3.1  extending the text viewer with the ability to detect hyperlinks and access the undo manager.  ITextViewerExtension7 since version 3.3  extending the text viewer with the ability to install tabs to spaces conversion.  ITextViewerExtension8 since version 3.4  extending the text viewer with the ability to print and rich hover support.    Clients may implement this interface and its extension interfaces or use the  standard implementation TextViewer.  See Also:  ITextViewerExtension_  ITextViewerExtension2_  ITextViewerExtension3_  ITextViewerExtension4_  ITextViewerExtension5_  ITextViewerExtension6_  ITextViewerExtension7_  ITextViewerExtension8_  IDocument_  ITextInputListener_  IViewportListener_  ITextListener_  IEventConsumer    
1131,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/source/ISourceViewer.html,"A text viewer connects a text widget with an  IDocument. The document is used as the  widget's text model.    It supports the following kinds of listeners:    view port listeners to inform about changes of the viewer's view port  text listeners to inform about changes of the document and the  subsequent viewer change  text input listeners to inform about changes of the viewer's input  document.  A text viewer supports a set of configuration options and plug-ins defining  its behavior:  undo manager  double click behavior  auto indentation  text hover  Installed plug-ins are not automatically activated. Plug-ins must be  activated with the activatePlugins call. Most plug-ins can be  defined per content type. Content types are derived from a partitioning of  the text viewer's input document. In case of documents that support multiple  partitionings_ the implementer is responsible for determining the  partitioning to use.    A text viewer also provides the concept of event consumption. Events handled  by the viewer can be filtered and processed by a dynamic event consumer. With  ITextViewerExtension_ this mechanism has been  replaced with the support for  VerifyKeyListener.    A text viewer provides several text editing functions_ some of them are  configurable_ through a text operation target interface. It also supports a  presentation mode in which it only shows a specified section of its document.  By calling setVisibleRegion clients define which section is  visible. Clients can get access to this section by calling  getVisibleRegion. The viewer's presentation mode does not  affect any client of the viewer other than text listeners. With  ITextViewerExtension5 the visible region  support has been reworked. With that extension interface_ text viewers are  allowed to show fractions of their input document. I.e. a widget selection of  two visually neighboring characters is no longer guaranteed to be two  neighboring characters in the viewer's input document. Thus_ viewers  implementing ITextViewerExtension5 are  potentially forced to change the fractions of the input document that are  shown when clients ask for the visible region.    In order to provide backward compatibility for clients of  ITextViewer_ extension interfaces are used as a means of  evolution. The following extension interfaces exist:    ITextViewerExtension since version 2.0  replacing the event consumer mechanism and introducing the concept of rewrite  targets and means to manage the viewer's redraw behavior  ITextViewerExtension2since version 2.1  adding a way to invalidate a viewer's presentation and setters for hovers.    ITextViewerExtension3 since version 2.1  which itself was replaced by  ITextViewerExtension5 in version 3.0  ITextViewerExtension4 since version 3.0  introducing focus handling for widget token keepers and the concept of text  presentation listeners.  ITextViewerExtension5 since version 3.0  extending the visible region concept with explicit handling and conversion  of widget and model coordinates.  ITextViewerExtension6 since version 3.1  extending the text viewer with the ability to detect hyperlinks and access the undo manager.  ITextViewerExtension7 since version 3.3  extending the text viewer with the ability to install tabs to spaces conversion.  ITextViewerExtension8 since version 3.4  extending the text viewer with the ability to print and rich hover support.    Clients may implement this interface and its extension interfaces or use the  standard implementation TextViewer.  See Also:  ITextViewerExtension_  ITextViewerExtension2_  ITextViewerExtension3_  ITextViewerExtension4_  ITextViewerExtension5_  ITextViewerExtension6_  ITextViewerExtension7_  ITextViewerExtension8_  IDocument_  ITextInputListener_  IViewportListener_  ITextListener_  IEventConsumer    
extends ITextViewer In addition to the text viewer functionality a source viewer supports:  visual annotations based on an annotation model    visual range indication    management of text viewer add-ons    explicit configuration    It is assumed that range indication and visual annotations are shown inside  the same presentation area. There are no assumptions about whether this area  is different from the viewer's text widget.    As the visibility of visual annotations can dynamically be changed_ it is  assumed that the annotation presentation area can dynamically be hidden if it  is different from the text widget.    In order to provide backward compatibility for clients of  ISourceViewer_ extension interfaces are used as a means of  evolution. The following extension interfaces exist:    ISourceViewerExtension since version 2.1  introducing the concept of an annotation overview.  ISourceViewerExtension2 since version 3.0  allowing source viewers to roll back a previously performed configuration and  allows access to the viewer's visual annotation model.  ISourceViewerExtension3 since version 3.2  introducing the concept of a quick assist assistant and providing access  to the quick assist invocation context as well as the current annotation hover.  ISourceViewerExtension4 since version 3.4  introducing API to access a minimal set of content assistant APIs.    Clients may implement this interface and its extension interfaces or use the  default implementation provided by  SourceViewer.  See Also:  ISourceViewerExtension_  ISourceViewerExtension2_  ISourceViewerExtension3_  ISourceViewerExtension4    "
1132,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/IContributionRoot.html,Instances of this interface represent a position in the contribution  hierarchy into which AbstractContributionFactory instances may insert  elements. Instances of this interface are provided by the platform and this  interface should NOT be implemented by clients.  Since:  3.3    
1133,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MultiEditor.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
extends AbstractMultiEditor A MultiEditor is a composite of editors.    This class is intended to be subclassed.    "
1134,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IRegistryEventListener.html,extends EventListener A registry event listener is notified of changes to extension points. Changes  include modifications of extension points and their extensions. Listeners will  only receive a notification if the extension point they are registered for is  modified. (Which includes modifications of extensions under the extension point.)    This interface can be used without OSGi running.    Clients may implement this interface.    Since:  3.4  See Also:  IExtensionRegistry.addListener(IRegistryEventListener_ String)    
1135,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/PropertySheet.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
extends EventListener A registry event listener is notified of changes to extension points. Changes  include modifications of extension points and their extensions. Listeners will  only receive a notification if the extension point they are registered for is  modified. (Which includes modifications of extensions under the extension point.)    This interface can be used without OSGi running.    Clients may implement this interface.    Since:  3.4  See Also:  IExtensionRegistry.addListener(IRegistryEventListener_ String)    
Interface for listening to part lifecycle events.    This interface may be implemented by clients.    See Also:  IPartService.addPartListener(IPartListener)    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends EventListener Interface for listening to selection changes.    This interface may be implemented by clients.    See Also:  ISelectionService.addSelectionListener(ISelectionListener)_  ISelectionService.addSelectionListener(String_ ISelectionListener)_  INullSelectionListener    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ IPersistable A view is a visual component within a workbench page. It is typically used to  navigate a hierarchy of information (like the workspace)_ open an editor_ or  display properties for the active editor. Modifications made in a view are  saved immediately (in contrast to an editor part_ which conforms to a more  elaborate open-save-close lifecycle).    Only one instance of a particular view type may exist within a workbench  page. This policy is designed to simplify part management for a user.      This interface may be implemented directly. For convenience_ a base  implementation is defined in ViewPart.      A view is added to the workbench in two steps:    A view extension is contributed to the workbench registry. This  extension defines the extension id and extension class.  The view is included in the default layout for a perspective.  Alternatively_ the user may open the view from the Perspective menu.      Views implement the IAdaptable interface; extensions are  managed by the platform's adapter manager.      As of 3.4_ views may optionally adapt to ISizeProvider if they have  a preferred size. The default presentation will make a best effort to  allocate the preferred size to a view if it is the only part in a stack. If  there is more than one part in the stack_ the constraints will be disabled  for that stack. The size constraints are adjusted for the size of the tab and  border trim. Note that this is considered to be a hint to the presentation_  and not all presentations may honor size constraints.    See Also:  IWorkbenchPage.showView(java.lang.String)_  ViewPart_  ISizeProvider    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
Parts which need to provide a particular context to a Show In...  target can provide this interface.  The part can either directly implement this interface_ or provide it  via IAdaptable.getAdapter(IShowInSource.class).  Since:  2.1  See Also:  IShowInTarget    
This interface must be provided by Show In targets (parts listed  in the Show In prompter).  The part can either directly implement this interface_ or provide it  via IAdaptable.getAdapter(IShowInTarget.class).  Since:  2.1  See Also:  IPageLayout.addShowInPart(java.lang.String)    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
extends PageBookView implements ISelectionListener_ IShowInTarget_ IShowInSource_ IRegistryEventListener Main class for the Property Sheet View.    This standard view has id ""org.eclipse.ui.views.PropertySheet"".      Note that property sheets and property sheet pages are not the  same thing as property dialogs and their property pages (the property  pages extension point is for contributing property pages to property dialogs).  Within the property sheet view_ all pages are IPropertySheetPages.      Property sheet pages are discovered by the property sheet view automatically  when a part is first activated. The property sheet view asks the active part  for its property sheet page; this is done by invoking  getAdapter(IPropertySheetPage.class) on the part. If the part  returns a page_ the property sheet view then creates the controls for that  property sheet page (using createControl)_ and adds the page to  the property sheet view. Whenever this part becomes active_ its corresponding  property sheet page is shown in the property sheet view (which may or may not  be visible at the time). A part's property sheet page is discarded when the  part closes. The property sheet view has a default page (an instance of  PropertySheetPage) which services all parts without a property  sheet page of their own.      The workbench will automatically instantiates this class when a Property  Sheet view is needed for a workbench window. This class is not intended  to be instantiated or subclassed by clients.    See Also:  IPropertySheetPage_  PropertySheetPage  Restriction:  This class is not intended to be subclassed by clients.  Restriction:  This class is not intended to be instantiated by clients.    "
1136,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/editors/text/TextEditor.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Should be implemented by editors that wish to contribute to the  navigation history. The message createNavigationLocation  will be sent when a new location is marked in the history.  Since:  2.1    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IPersistable An editor can implement this interface and participate in the workbench  session save/restore cycle using IMemento_ similar to how  IViewPart currently works.    Refer to IWorkbenchPart for the part lifecycle.      If a memento is available_ restoreState(*) will be inserted into the editor  startup.    editor.init(site_ input)  editor.restoreState(memento)  editor.createPartControl(parent)  ...      On workbench shutdown_ the editor state will be persisted when the editor  references are saved.    Since:  3.3    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IEditorPart Interface for reusable editors.     An editors may support changing its input so that   the workbench may change its contents instead of   opening a new editor.    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
Represents a source of Saveable objects (units of saveability). Workbench  parts that show more than one unit of saveability_ or whose units of  saveability change over time_ should implement this interface in order to  provide better integration with workbench facilities like the Save command_  prompts to save on part close or shutdown_ etc.    IMPORTANT: As of 3.2_ implementers of ISaveablesSource must  satisfy the following conditions:    If ISaveablesSource is implemented by an IWorkbenchPart:  the part must implement ISaveablePart  if any of its Saveable objects are dirty_ the part must return  true from ISaveablePart.isDirty()  the part must return true from  ISaveablePart.isSaveOnCloseNeeded() if it is dirty (the default  behaviour implemented by EditorPart)  the part must not implement ISaveablePart2    If ISaveablesSource is implemented by a non-part (possible as of 3.2.1 and 3.3):  the Workbench's ISaveablesLifecycleListener (obtained from the  Workbench by calling  workbench.getService(ISaveablesLifecycleListener.class)) must  be notified of any change to the result of getSaveables()   getActiveSaveables() should be implemented to return an empty array      If any of these conditions are not met_ it is undefined whether the Workbench  will prompt to save dirty Saveables when closing parts or the Workbench.      These conditions may be relaxed in future releases.    Since:  3.2    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IEditorPart Interface to a text editor. This interface defines functional extensions to  IEditorPart as well as the configuration capabilities of a text editor.    Text editors are configured with an IDocumentProvider which delivers a textual  presentation (IDocument) of the editor's input. The editor works on the document and  forwards all input element related calls_ such as save_ to the document provider.  The provider also delivers the input's annotation model which is used by the editor's vertical  ruler.      Clients may implement this interface from scratch_ but the recommended way is to subclass the  abstract base class AbstractTextEditor.      In order to provided backward compatibility for clients of ITextEditor_ extension  interfaces are used to provide a means of evolution. The following extension interfaces exist:    ITextEditorExtension since version 2.0 introducing status  fields_ read-only state and ruler context menu listeners.  ITextEditorExtension2 since version 2.1 introducing  modifiable state for the editor input and validate state handling.  ITextEditorExtension3 since version 3.0 adding input state  and change information control.  ITextEditorExtension4 since version 3.2 adding annotation  navigation and revision information display.  ITextEditorExtension5 since version 3.5 adding block  selection mode.    See Also:  IDocumentProvider_  IAnnotationModel_  ITextEditorExtension_  ITextEditorExtension2_  ITextEditorExtension3_  ITextEditorExtension4_  ITextEditorExtension5    
Extension interface for ITextEditor. Adds  the following functions:  status fields    read-only state of the editor's input    ruler context menu listeners.    Since:  2.0    
Extension interface for ITextEditor. Adds  the following functions:  modifiable state of the editor's input  validate state of editor input  Since:  2.1    
Extension interface for ITextEditor. Adds  the following functions:  insert mode management  Since:  3.0    
Extension interface for ITextEditor. Adds  the following functions:  annotation navigation  revision information display    This interface may be implemented by clients.    Since:  3.2    
Extension interface for ITextEditor. Adds the following  functions:  block selection mode    This interface may be implemented by clients.    Since:  3.5    
extends AbstractDecoratedTextEditor The standard/default text editor.    This editor has id ""org.eclipse.ui.DefaultTextEditor"".  The editor's context menu has id #TextEditorContext. The editor's ruler context menu  has id #TextRulerContext.      The workbench will automatically instantiate this class when the default editor is needed for a  workbench window.      "
1137,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/TextSelection.html,"Interface for a selection.  See Also:  ISelectionProvider_  ISelectionChangedListener_  SelectionChangedEvent    
extends ISelection This interface represents a textual selection. A text selection is a range of  characters. Although a text selection is a snapshot taken at a particular  point in time_ it must not copy the line information and the selected text  from the selection provider.    If_ for example_ the selection provider is a text viewer (  ITextViewer)_ and a text selection is created  for the range [5_ 10]_ the line formation for the 5th character must not be  determined and remembered at the point of creation. It can rather be  determined at the point_ when getStartLine is called. If the  source viewer range [0_ 15] has been changed in the meantime between the  creation of the text selection object and the invocation of  getStartLine_ the returned line number may differ from the  line number of the 5th character at the point of creation of the text  selection object.    The contract of this interface is that weak in order to allow for efficient  implementations.    Clients may implement this interface or use the default implementation  provided by TextSelection.  See Also:  TextSelection    
Interface for a selection.  See Also:  ISelectionProvider_  ISelectionChangedListener_  SelectionChangedEvent    
extends Object implements ITextSelection Standard implementation of ITextSelection.    Takes advantage of the weak contract of correctness of its interface. If  generated from a selection provider_ it only remembers its offset and length  and computes the remaining information on request.    "
1138,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/ICompositeOperation.html," IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends IUndoableOperation  ICompositeOperation defines an undoable operation that is composed of child  operations. Requests to execute_ undo_ or redo a composite result in the the  execution_ undo_ or redo of the composite as a whole. Similarly_ a request to   dispose the composite should result in all child operations being disposed.    Since:  3.1    "
1139,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IContextReplacingOperation.html,IContextReplacingOperation defines an interface for undoable operations that  can replace one undo context with another undo context. It is used by  operations_ such as composite operations_ where removing and adding an undo  context would not have the same semantic as replacing one undo context with  another.  Since:  3.2    
1140,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/TriggeredOperations.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends IUndoableOperation  ICompositeOperation defines an undoable operation that is composed of child  operations. Requests to execute_ undo_ or redo a composite result in the the  execution_ undo_ or redo of the composite as a whole. Similarly_ a request to   dispose the composite should result in all child operations being disposed.    Since:  3.1    
IContextReplacingOperation defines an interface for undoable operations that  can replace one undo context with another undo context. It is used by  operations_ such as composite operations_ where removing and adding an undo  context would not have the same semantic as replacing one undo context with  another.  Since:  3.2    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractOperation implements ICompositeOperation_ IAdvancedUndoableOperation_ IAdvancedUndoableOperation2_ IContextReplacingOperation Triggered operations are a specialized implementation of a composite  operation that keeps track of operations triggered by the execution of some  primary operation. The composite knows which operation was the trigger for  subsequent operations_ and adds all triggered operations as children. When  execution_ undo_ or redo is performed_ only the triggered operation is  executed_ undone_ or redone if it is still present. If the trigger is removed  from the triggered operations_ then the child operations will replace the  triggered operations in the history.    This class may be instantiated by clients.    Since:  3.1    "
1141,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IOperationApprover.html, IOperationApprover defines an interface for approving the undo or redo of a  particular operation within an operation history. Operations that are  candidates for undo or redo have already been validated against their current  state and according to the rules of the history.      By the time an IOperationApprover is consulted_ the undo has already been  requested. Approvers should return an IStatus object with  severity OK if the operation should proceed_ and any other  severity if it should not. When an operation is not approved_ it is expected  that the object not allowing the operation has already consulted the user if  necessary or otherwise provided any necessary information to the user about  the fact that the operation is not approved.      Operation approvers must be prepared to receive the approval messages from a  background thread. Any UI access occurring inside the implementation must be  properly synchronized using the techniques specified by the client's widget  library.    Since:  3.1    
1142,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/UpdateMarkersOperation.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractWorkspaceOperation An UpdateMarkersOperation represents an undoable operation for updating one  or more markers in the workspace with one or more sets of attributes. Clients  may call the public API from a background thread.    This class is intended to be instantiated and used by clients. It is not  intended to be subclassed by clients.  Since:  3.3    "
1143,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/CreateProjectOperation.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractWorkspaceOperation A CreateProjectOperation represents an undoable operation for creating a  project in the workspace. Clients may call the public API from a background  thread.    This class is intended to be instantiated and used by clients. It is not  intended to be subclassed by clients.    Since:  3.3  Restriction:  This class is not intended to be subclassed by clients.    "
1144,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/MoveProjectOperation.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractWorkspaceOperation A MoveProjectOperation represents an undoable operation for moving a  project's content to a different location. Clients may call the public API  from a background thread.    This class is intended to be instantiated and used by clients. It is not  intended to be subclassed by clients.    Since:  3.3  Restriction:  This class is not intended to be subclassed by clients.    "
1145,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/CopyProjectOperation.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractWorkspaceOperation A CopyProjectOperation represents an undoable operation for copying a  project_ also specifying the location of its contents. Clients may call the  public API from a background thread.      This class is intended to be instantiated and used by clients. It is not  intended to be subclassed by clients.    Since:  3.3  Restriction:  This class is not intended to be subclassed by clients.    "
1146,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/DeleteResourcesOperation.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractWorkspaceOperation A DeleteResourcesOperation represents an undoable operation for deleting one  or more resources in the workspace. Clients may call the public API from a  background thread.    This class is intended to be instantiated and used by clients. It is not  intended to be subclassed by clients.    Since:  3.3  Restriction:  This class is not intended to be subclassed by clients.    "
1147,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/CreateFolderOperation.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractWorkspaceOperation A CreateFolderOperation represents an undoable operation for creating a  folder in the workspace. If a link location is specified_ the folder is  considered to be linked to the specified location. If a link location is not  specified_ the folder will be created in the location specified by the  handle_ and the entire containment path of the folder will be created if it  does not exist. The folder should not already exist_ and the existence   of the containment path should not be changed between the time this operation  is created and the time it is executed.    Clients may call the public API from a background thread.      This class is intended to be instantiated and used by clients. It is not  intended to be subclassed by clients.    Since:  3.3  Restriction:  This class is not intended to be subclassed by clients.    "
1148,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/CreateFileOperation.html," IAdvancedUndoableOperation defines an interface for undoable operations that  modify one or more elements in a model and attempt to keep model listeners up  to date with changes that occur in the undo and redo history involving particular  model elements. It also defines methods for computing the validity of an operation  for undo or redo before attempting to perform the undo or redo.      This interface is intended to be used by legacy frameworks that are adapting  their original undo and redo support to this framework. The methods in this  interface allow legacy clients to maintain features not supported in the  basic operations framework.    Since:  3.1    
 IAdvancedUndoableOperation2 defines a method for computing the validity of  executing an operation before attempting to execute it. It also defines a way  for clients to specify that computing status should be done quietly_ without  consulting the user. This interface is useful when implementing  IOperationApprover2_ or any other object that performs validation of  the undo history. It also allows operations to specify whether they should be  run in the UI thread.    Since:  3.3    
 IUndoableOperation defines an operation that can be executed_ undone_ and  redone. Operations typically have fully defined parameters. That is_ they are  usually created after the user has been queried for any input needed to  define the operation.      Operations determine their ability to execute_ undo_ or redo according to the  current state of the application. They do not make decisions about their  validity based on where they occur in the operation history. That is left to  the particular operation history.    Since:  3.1    
extends AbstractWorkspaceOperation A CreateFileOperation represents an undoable operation for creating a file in  the workspace. If a link location is specified_ the file is considered to  be linked to the file at the specified location. If a link location is not  specified_ the file will be created in the location specified by the handle_  and the entire containment path of the file will be created if it does not  exist. The file should not already exist_ and the existence of the   containment path should not be changed between the time this operation   is created and the time it is executed.    Clients may call the public API from a background thread.      This class is intended to be instantiated and used by clients. It is not  intended to be subclassed by clients.    Since:  3.3  Restriction:  This class is not intended to be subclassed by clients.    "
1149,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/ILogger.html,A mechanism to log errors throughout JFace.    Clients may provide their own implementation to change  how errors are logged from within JFace.    Since:  3.1  See Also:  Policy.getLog()_  Policy.setLog(ILogger)    
1150,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/preferences/ScopedPreferenceStore.html,"extends IPreferenceStore IPersistentPreferenceStore is a preference store that can   be saved.    
The IPreferenceStore interface represents a table mapping  named preferences to values. If there is no value for a given name_  then that preferences's default value is returned; and if there is no  default value for that preference_ then a default-default value is returned.  The default-default values for the primitive types are as follows:  boolean = false  double = 0.0  float = 0.0f  int = 0  long = 0  String = """" (the empty string)    Thus a preference store maintains two values for each of a set of  names: a current value and a default value.  The typical usage is to establish the defaults for all known preferences  and then restore previously stored values for preferences whose values  were different from their defaults. After the current values of  the preferences have been modified_ it is a simple matter to write  out only those preferences whose values are different from their defaults.  This two-tiered approach to saving and restoring preference setting  minimized the number of preferences that need to be persisted; indeed_  the normal starting state does not require storing any preferences  at all.      A property change event is reported whenever a preferences current  value actually changes (whether through setValue_  setToDefault_ or other unspecified means). Note_ however_  that manipulating default values (with setDefault)  does not cause such events to be reported.      Clients who need a preference store may implement this interface or  instantiate the standard implementation PreferenceStore.    See Also:  PreferenceStore    
extends EventManager implements IPreferenceStore_ IPersistentPreferenceStore The ScopedPreferenceStore is an IPreferenceStore that uses the scopes  provided in org.eclipse.core.runtime.preferences.    A ScopedPreferenceStore does the lookup of a preference based on it's search  scopes and sets the value of the preference based on its store scope.      The default scope is always included in the search scopes when searching for  preference values.    Since:  3.1  See Also:  org.eclipse.core.runtime.preferences    "
1151,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/preferences/WorkingCopyManager.html,"IWorkingCopyManager is the interface for the working copy  support for references to shared preference nodes.  Since:  3.1    
extends Object implements IWorkingCopyManager WorkingCopyManager is a concrete implementation of an  IWorkingCopyManager.    This class is not intended to be sub-classed by clients.    Since:  3.2    "
1152,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/PropertyShowInContext.html,extends ShowInContext  Since:  3.4    
1153,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/statushandlers/WorkbenchStatusDialogManager.html,extends Object  The WorkbenchStatusDialogManager is a utility class for displaying  one or more messages (errors_ warnings or infos) to the user. The dialog  supplied has a Details button that opens/closes the details area. The default  AbstractStatusAreaProvider displays a tree of StatusAdapters  related to the selected item on the messages list. The dialog also hasa  Support button that opens/closes the support area which contains the provided  AbstractStatusAreaProvider. The Support button is disabled and not  visible unless  enableDefaultSupportArea(boolean) is  invoked.        The default details area can be replaced using  setDetailsAreaProvider(AbstractStatusAreaProvider)        The default support area can be replaced using  setSupportAreaProvider(AbstractStatusAreaProvider)  or Policy.setErrorSupportProvider(ErrorSupportProvider).        The manager can switch from a non-modal dialog to a modal dialog. See  addStatusAdapter(StatusAdapter_ boolean)    Since:  3.4  See Also:  Policy.setErrorSupportProvider(ErrorSupportProvider)_  ErrorSupportProvider_  AbstractStatusAreaProvider  Restriction:  This class is not intended to be subclassed by clients.    
1154,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/statushandlers/WorkbenchErrorHandler.html,extends AbstractStatusHandler This is a default workbench error handler.  Since:  3.3  See Also:  WorkbenchAdvisor.getWorkbenchErrorHandler()    
1155,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/TrayDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends Dialog A TrayDialog is a specialized Dialog that can contain  a tray on its side. The tray's content is provided as a DialogTray.    It is recommended to subclass this class instead of Dialog in all  cases except where the dialog should never show a tray. For example_ dialogs  which are very short_ simple_ and quick to dismiss (e.g. a message dialog with  an OK button) should subclass Dialog.      Note: Trays are not supported on dialogs that use a custom layout on the   Shell by overriding Window#getLayout().    Since:  3.2  See Also:  DialogTray_  Window.getLayout()    "
1156,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ColumnLayout.html,"Classes that extend abstract class Layout and implement this interface can  take part in layout computation of the TableWrapLayout manager. This layout  uses alternative algorithm that computes columns before rows. It allows it  to 'flow' wrapped text proportionally (similar to the way web browser  renders tables). Custom layout managers that implement this interface will  allow TableWrapLayout to properly compute width hint to pass.  Since:  3.0  See Also:  TableWrapLayout_  ColumnLayout    
extends Layout implements ILayoutExtension This layout manager arranges children of the composite parent in vertical  columns. All the columns are identical size and children are stretched  horizontally to fill the column width. The goal is to give layout some  reasonable range of column numbers to allow it to handle various parent  widths. That way_ column number will drop to the lowest number in the range  when width decreases_ and grow up to the highest number in the range when  allowed by the parent width.    In addition_ the layout attempts to 'fill the space' equally i.e. to avoid  large gaps at the and of the last column.    Child controls are layed out according to their 'natural' (preferred) size.  For 'stretchy' controls that do not have natural preferred size_ it is  possible to set width and/or height hints using ColumnLayoutData objects.  Since:  3.0  See Also:  ColumnLayoutData    "
1157,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/IJobManager.html,The job manager provides facilities for scheduling_ querying_ and maintaining jobs  and locks. In particular_ the job manager provides the following services:  Maintains a queue of jobs that are waiting to be run. Items can be added to  the queue using the schedule method.  Allows manipulation of groups of jobs called job families. Job families can  be canceled_ put to sleep_ or woken up atomically. There is also a mechanism  for querying the set of known jobs in a given family.  Allows listeners to find out about progress on running jobs_ and to find out  when jobs have changed states.  Provides a factory for creating lock objects. Lock objects are smart monitors  that have strategies for avoiding deadlock.  Provide feedback to a client that is waiting for a given job or family of jobs  to complete.  Since:  3.0  See Also:  Job_  ILock  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
1158,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/Plugin.html,"extends Object implements BundleActivator The abstract superclass of all plug-in runtime class  implementations. A plug-in subclasses this class and overrides  the appropriate life cycle methods in order to react to the life cycle   requests automatically issued by the platform.  For compatibility reasons_ the methods called for those life cycle events   vary_ please see the ""Constructors and life cycle methods"" section below.       Conceptually_ the plug-in runtime class represents the entire plug-in  rather than an implementation of any one particular extension the  plug-in declares. A plug-in is not required to explicitly  specify a plug-in runtime class; if none is specified_ the plug-in  will be given a default plug-in runtime object that ignores all life   cycle requests (it still provides access to the corresponding  plug-in descriptor).      In the case of more complex plug-ins_ it may be desirable  to define a concrete subclass of Plugin.  However_ just subclassing Plugin is not  sufficient. The name of the class must be explicitly configured  in the plug-in's manifest (plugin.xml) file  with the class attribute of the &ltplugin> element markup.      Instances of plug-in runtime classes are automatically created   by the platform in the course of plug-in activation. For compatibility reasons_   the constructor used to create plug-in instances varies_ please see the ""Constructors   and life cycle methods"" section below.    The concept of bundles underlies plug-ins. However it is safe to regard plug-ins   and bundles as synonyms.       Clients must never explicitly instantiate a plug-in runtime class.      A typical implementation pattern for plug-in runtime classes is to  provide a static convenience method to gain access to a plug-in's  runtime object. This way_ code in other parts of the plug-in  implementation without direct access to the plug-in runtime object  can easily obtain a reference to it_ and thence to any plug-in-wide  resources recorded on it. An example for Eclipse 3.0 follows:    package myplugin;  public class MyPluginClass extends Plugin {  private static MyPluginClass instance;  public static MyPluginClass getInstance() { return instance; }  public void MyPluginClass() {  super();  instance = this;  // ... other initialization  }  // ... other methods  }    In the above example_ a call to MyPluginClass.getInstance()  will always return an initialized instance of MyPluginClass.      Constructors and life cycle methods     If the plugin.xml of a plug-in indicates <?eclipse version=""3.0""?> and its prerequisite  list includes org.eclipse.core.runtime_ the default constructor of the plug-in   class is used and start(BundleContext) and stop(BundleContext) are  called as life cycle methods.     If the plugin.xml of a plug-in indicates <?eclipse version=""3.0""?> and its prerequisite list includes  org.eclipse.core.runtime.compatibility_ the Plugin(IPluginDescriptor)  constructor is used and startup() and shutdown() are called as life cycle methods.  Note that in this situation_ start() is called before startup() and stop() is called  after shutdown.     If the plugin.xml of your plug-in does not indicate <?eclipse version=""3.0""?> it is therefore  not a 3.0 plug-in. Consequently the Plugin(IPluginDescriptor) is used and startup() and   shutdown() are called as life cycle methods.    Since Eclipse 3.0 APIs of the Plugin class can be called only when the Plugin is in an active state_ i.e._  after it was started up and before it is shutdown. In particular_ it means that Plugin APIs should not  be called from overrides of Plugin().       "
1159,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonViewerMapper.html,Allows improved performance by optimizing label updates of the CommonViewer.    Often label updates come in the form of resource updates_ and the resources  themselves are not directly stored in the CommonViewer; instead other model  objects are stored. In addition_ it may be the case where the objects that  have changed are not present in the Tree associated with the CommonViewer  because they have not been opened or expanded.    You can use an instance of this class to define a mapping between the current  Tree Items associated with the CommonViewer and the (typically resource) objects  where a change is notified. The change is notified to the   CommonViewer.handleLabelProviderChanged(org.eclipse.jface.viewers.LabelProviderChangedEvent).    The mapper object (implementing this interface) is associated with the CommonViewer using   the CommonViewer.setMapper(ICommonViewerMapper) method.    When this mapper wishes to update the CommonViewer_ the   CommonViewer.doUpdateItem(org.eclipse.swt.widgets.Widget)   method is used.  Since:  3.4  Restriction:  This interface is not intended to be extended by clients.    
1160,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/NavigatorActionService.html,"Clients may use mementos to persist interesting state between sessions.  Clients should ensure that the memento keys are unique; generally by using  the id of the content extension as a prefix.  Since:  3.2    
extends ActionGroup implements IMementoAware  Provides context menu items and IActionBars contributions for a particular abstract  viewer. The interface matches that of ActionGroup and may be used in the same manner.  Clients must call  prepareMenuForPlatformContributions(MenuManager_ ISelectionProvider_ boolean)  when using this class to allow object or viewer contributions. The  org.eclipse.ui.navigator.viewer/viewer/popupMenu element may override whether platform  contributions are allowed to the menu with its allowsPlatformContributions attribute.  ""Platform Contributions"" are menu items that are added through the org.eclipse.ui.popupMenus  extension point.      A CommonActionProvider has opportunities to contribute to the context menu and  IActionBars whenever the selection in the viewer changes. Action Providers  are selected based on the enablement expressions of their associated content extension or their  own enablement expression if it is declared as a top-level <actionProvider /> element (of  the org.eclipse.ui.navigator.navigatorContent extension point). See the schema  documentation of org.eclipse.ui.navigator.navigatorContent for more information on how to  specify an Action Provider.      Clients that reuse this service outside of an instance of CommonNavigator must be sure  that {fillActionBars(IActionBars) is called whenever the selection changes. The  retargetable actions for each selection could change_ based on who contributed the items.  Since:  3.2    "
1161,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/IPartMenu.html,Interface to a menu created by a part that will be displayed in a  presentation.    This interface is not intended to be implemented by clients.  Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    
1162,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeNode.html,extends Object A simple data structure that is useful for implemented tree models. This can  be returned by  IStructuredContentProvider.getElements(Object).  It allows simple delegation of methods from  ITreeContentProvider such as  ITreeContentProvider.getChildren(Object)_  ITreeContentProvider.getParent(Object) and  ITreeContentProvider.hasChildren(Object)  Since:  3.2    
1163,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IEditingSupportRegistry.html,A registry for IEditingSupports.    This interface is not meant to be implemented outside the JFace text  framework.  Since:  3.1  See Also:  IEditingSupport  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
1164,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextOperationTarget.html,Defines the target for text operations. canDoOperation informs  the clients about the ability of the target to perform the specified  operation at the current point in time. doOperation executes  the specified operation.    In order to provide backward compatibility for clients of  ITextOperationTarget_ extension interfaces are used as a  means of evolution. The following extension interfaces exist:    ITextOperationTargetExtension since  version 2.0 introducing text operation enabling/disabling.  See Also:  ITextOperationTargetExtension    
1165,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextOperationTargetExtension.html,Extension interface for ITextOperationTarget.    Allows a client to control the enable state of operations provided by this  target.  Since:  2.0  See Also:  ITextOperationTarget    
1166,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextViewerExtension.html,Extension interface for ITextViewer.    This extension interface replaces the event consumer mechanism (  ITextViewer.setEventConsumer(IEventConsumer))  with a set of methods that allow to manage a sequence of  VerifyKeyListenerobjects. It also adds    access to the control of this viewer  marked region support as in emacs  control of the viewer's redraw behavior by introducing  setRedraw(boolean)    access to the viewer's rewrite target.    A rewrite target (IRewriteTarget) represents  an facade offering the necessary methods to manipulate a document that is the  input document of a text viewer.  Since:  2.0    
1167,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextViewerExtension2.html,Extension interface for ITextViewer.    It provides    text presentation invalidation enhancements  text hover management enhancements  a replacement for auto indent strategies  support for custom painters  It extends the means for text presentation invalidation by allowing a  specific region of the presentation to get invalidated. It replaces  ITextViewer.setTextHover(ITextHover_ String)  with a new method that allows to specify state masks for a better control of  the hover behavior.    An IAutoEditStrategy is a generalization of  the original IAutoIndentStrategy. Auto edit  strategies can be arranged in a list that is executed like a pipeline when  the viewer content is changed.    A IPainteris creating and managing visual  decorations on the viewer's text widget. Viewer's can have an open number of  painters. Painters are informed about changes to the viewer content and state  and can take the necessary action in responds to the notification.  Since:  2.1    
1168,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextViewerExtension4.html,Extension interface for ITextViewer.  Introduces the concept of text presentation listeners and improves focus  handling among widget token keepers.    A ITextPresentationListeneris a listener that  is informed by the viewer that a text presentation is about to be applied.  During this callback the listener is allowed to modify the presentation. Text  presentation listeners are thus a mean to participate in the process of text  presentation creation.  Since:  3.0    
1169,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextViewerExtension6.html,Extension interface for ITextViewer.  Introduces the concept of text hyperlinks and adds access to the undo manager.  Since:  3.1  See Also:  IHyperlink_  IHyperlinkDetector    
1170,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextViewerExtension7.html,Extension interface for ITextViewer.  Adds the ability to install tabs to spaces conversion.  Since:  3.3    
1171,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextViewerExtension8.html,Extension interface for ITextViewer. Adds the  ability to print and set how hovers should be enriched when the mouse is moved into them.  Since:  3.4    
1172,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IWidgetTokenOwner.html,In order to display information in a temporary window_ a widget token must be  acquired. The intent behind this concept is that only one temporary window  should be presented at any moment in time and also to avoid overlapping  temporary windows. This concept is used by the  ITextViewer.    In order to provide backward compatibility for clients of  IWidgetTokenOwner_ extension interfaces are used as a means  of evolution. The following extension interfaces exist:    IWidgetTokenOwnerExtension since version  3.0 introducing priorities when requesting a widget token and thus replacing  the non-prioritized scheme.  Since:  2.0  See Also:  IWidgetTokenOwnerExtension    
1173,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IWidgetTokenOwnerExtension.html,Extension interface for IWidgetTokenOwner.    Replaces the original requestWidgetToken functionality with a  new priority based approach.  Since:  3.0    
1174,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/TextViewer.html,"A registry for IEditingSupports.    This interface is not meant to be implemented outside the JFace text  framework.  Since:  3.1  See Also:  IEditingSupport  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
Defines the target for text operations. canDoOperation informs  the clients about the ability of the target to perform the specified  operation at the current point in time. doOperation executes  the specified operation.    In order to provide backward compatibility for clients of  ITextOperationTarget_ extension interfaces are used as a  means of evolution. The following extension interfaces exist:    ITextOperationTargetExtension since  version 2.0 introducing text operation enabling/disabling.  See Also:  ITextOperationTargetExtension    
Extension interface for ITextOperationTarget.    Allows a client to control the enable state of operations provided by this  target.  Since:  2.0  See Also:  ITextOperationTarget    
A text viewer connects a text widget with an  IDocument. The document is used as the  widget's text model.    It supports the following kinds of listeners:    view port listeners to inform about changes of the viewer's view port  text listeners to inform about changes of the document and the  subsequent viewer change  text input listeners to inform about changes of the viewer's input  document.  A text viewer supports a set of configuration options and plug-ins defining  its behavior:  undo manager  double click behavior  auto indentation  text hover  Installed plug-ins are not automatically activated. Plug-ins must be  activated with the activatePlugins call. Most plug-ins can be  defined per content type. Content types are derived from a partitioning of  the text viewer's input document. In case of documents that support multiple  partitionings_ the implementer is responsible for determining the  partitioning to use.    A text viewer also provides the concept of event consumption. Events handled  by the viewer can be filtered and processed by a dynamic event consumer. With  ITextViewerExtension_ this mechanism has been  replaced with the support for  VerifyKeyListener.    A text viewer provides several text editing functions_ some of them are  configurable_ through a text operation target interface. It also supports a  presentation mode in which it only shows a specified section of its document.  By calling setVisibleRegion clients define which section is  visible. Clients can get access to this section by calling  getVisibleRegion. The viewer's presentation mode does not  affect any client of the viewer other than text listeners. With  ITextViewerExtension5 the visible region  support has been reworked. With that extension interface_ text viewers are  allowed to show fractions of their input document. I.e. a widget selection of  two visually neighboring characters is no longer guaranteed to be two  neighboring characters in the viewer's input document. Thus_ viewers  implementing ITextViewerExtension5 are  potentially forced to change the fractions of the input document that are  shown when clients ask for the visible region.    In order to provide backward compatibility for clients of  ITextViewer_ extension interfaces are used as a means of  evolution. The following extension interfaces exist:    ITextViewerExtension since version 2.0  replacing the event consumer mechanism and introducing the concept of rewrite  targets and means to manage the viewer's redraw behavior  ITextViewerExtension2since version 2.1  adding a way to invalidate a viewer's presentation and setters for hovers.    ITextViewerExtension3 since version 2.1  which itself was replaced by  ITextViewerExtension5 in version 3.0  ITextViewerExtension4 since version 3.0  introducing focus handling for widget token keepers and the concept of text  presentation listeners.  ITextViewerExtension5 since version 3.0  extending the visible region concept with explicit handling and conversion  of widget and model coordinates.  ITextViewerExtension6 since version 3.1  extending the text viewer with the ability to detect hyperlinks and access the undo manager.  ITextViewerExtension7 since version 3.3  extending the text viewer with the ability to install tabs to spaces conversion.  ITextViewerExtension8 since version 3.4  extending the text viewer with the ability to print and rich hover support.    Clients may implement this interface and its extension interfaces or use the  standard implementation TextViewer.  See Also:  ITextViewerExtension_  ITextViewerExtension2_  ITextViewerExtension3_  ITextViewerExtension4_  ITextViewerExtension5_  ITextViewerExtension6_  ITextViewerExtension7_  ITextViewerExtension8_  IDocument_  ITextInputListener_  IViewportListener_  ITextListener_  IEventConsumer    
Extension interface for ITextViewer.    This extension interface replaces the event consumer mechanism (  ITextViewer.setEventConsumer(IEventConsumer))  with a set of methods that allow to manage a sequence of  VerifyKeyListenerobjects. It also adds    access to the control of this viewer  marked region support as in emacs  control of the viewer's redraw behavior by introducing  setRedraw(boolean)    access to the viewer's rewrite target.    A rewrite target (IRewriteTarget) represents  an facade offering the necessary methods to manipulate a document that is the  input document of a text viewer.  Since:  2.0    
Extension interface for ITextViewer.    It provides    text presentation invalidation enhancements  text hover management enhancements  a replacement for auto indent strategies  support for custom painters  It extends the means for text presentation invalidation by allowing a  specific region of the presentation to get invalidated. It replaces  ITextViewer.setTextHover(ITextHover_ String)  with a new method that allows to specify state masks for a better control of  the hover behavior.    An IAutoEditStrategy is a generalization of  the original IAutoIndentStrategy. Auto edit  strategies can be arranged in a list that is executed like a pipeline when  the viewer content is changed.    A IPainteris creating and managing visual  decorations on the viewer's text widget. Viewer's can have an open number of  painters. Painters are informed about changes to the viewer content and state  and can take the necessary action in responds to the notification.  Since:  2.1    
Extension interface for ITextViewer.  Introduces the concept of text presentation listeners and improves focus  handling among widget token keepers.    A ITextPresentationListeneris a listener that  is informed by the viewer that a text presentation is about to be applied.  During this callback the listener is allowed to modify the presentation. Text  presentation listeners are thus a mean to participate in the process of text  presentation creation.  Since:  3.0    
Extension interface for ITextViewer.  Introduces the concept of text hyperlinks and adds access to the undo manager.  Since:  3.1  See Also:  IHyperlink_  IHyperlinkDetector    
Extension interface for ITextViewer.  Adds the ability to install tabs to spaces conversion.  Since:  3.3    
Extension interface for ITextViewer. Adds the  ability to print and set how hovers should be enriched when the mouse is moved into them.  Since:  3.4    
In order to display information in a temporary window_ a widget token must be  acquired. The intent behind this concept is that only one temporary window  should be presented at any moment in time and also to avoid overlapping  temporary windows. This concept is used by the  ITextViewer.    In order to provide backward compatibility for clients of  IWidgetTokenOwner_ extension interfaces are used as a means  of evolution. The following extension interfaces exist:    IWidgetTokenOwnerExtension since version  3.0 introducing priorities when requesting a widget token and thus replacing  the non-prioritized scheme.  Since:  2.0  See Also:  IWidgetTokenOwnerExtension    
Extension interface for IWidgetTokenOwner.    Replaces the original requestWidgetToken functionality with a  new priority based approach.  Since:  3.0    
Interface common to all objects that provide an input.    
extends IInputProvider_ ISelectionProvider Interface common to all objects that provide both an input and  a selection.    
extends ISelectionProvider Selection provider extension interface to allow providers  to notify about post selection changed events.  A post selection changed event is equivalent to selection changed event  if the selection change was triggered by the mouse_ but it has a delay  if the selection change is triggered by keyboard navigation.  Since:  3.0  See Also:  ISelectionProvider    
Interface common to all objects that provide a selection.  See Also:  ISelection_  ISelectionChangedListener_  SelectionChangedEvent    
extends Viewer implements ITextViewer_ ITextViewerExtension_ ITextViewerExtension2_ ITextViewerExtension4_ ITextViewerExtension6_ ITextViewerExtension7_ ITextViewerExtension8_ IEditingSupportRegistry_ ITextOperationTarget_ ITextOperationTargetExtension_ IWidgetTokenOwner_ IWidgetTokenOwnerExtension_ IPostSelectionProvider SWT based implementation of ITextViewer and its extension interfaces.  Once the viewer and its SWT control have been created the viewer can only  indirectly be disposed by disposing its SWT control.    Clients are supposed to instantiate a text viewer and subsequently to  communicate with it exclusively using the  ITextViewer interface or any of the  implemented extension interfaces.    A text viewer serves as text operation target. It only partially supports the  external control of the enable state of its text operations. A text viewer is  also a widget token owner. Anything that wants to display an overlay window  on top of a text viewer should implement the  IWidgetTokenKeeper interface and participate  in the widget token negotiation between the text viewer and all its potential  widget token keepers.    This class is not intended to be subclassed outside the JFace Text component.  Restriction:  This class is not intended to be subclassed by clients.    "
1175,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/ModelService.html,extends ModelHandlerBase  Since:  1.0  Restriction:  This class is not intended to be referenced by clients.    
1176,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/IStackPresentationSite.html,Represents the main interface between a StackPresentation and the workbench.    Not intended to be implemented by clients.  Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    
1177,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/StackDropResult.html,extends Object This structure describes a drop event that will cause a dragged part to be  stacked in a position currently occupied by another part.  Since:  3.0    
1178,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/IPresentationSerializer.html,This interface is given to a StackPresentation when it is loading or saving  its state.    Not intended to be implemented by clients  Since:  3.0  Restriction:  This interface is not intended to be implemented by clients.    
1179,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/fragment/MStringModelFragment.html," A representation of the model object 'Model Fragment'.        Developers:  Add more detailed documentation by editing this comment in   /org.eclipse.e4.ui.model.workbench/model/ModelFragment.ecore.   There is a GenModel/documentation node under each type and attribute.    Since:  1.0      The following features are supported:    Elements      
extends MModelFragment  A representation of the model object 'String Model Fragment'.        Developers:  Add more detailed documentation by editing this comment in   /org.eclipse.e4.ui.model.workbench/model/ModelFragment.ecore.   There is a GenModel/documentation node under each type and attribute.    Since:  1.0      The following features are supported:    Featurename  Parent Element Id  Position In List      "
1180,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/Window.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends Object implements IShellProvider A JFace window is an object that has no visual representation (no widgets)  until it is told to open.    Creating a window involves the following steps:    creating an instance of a concrete subclass of Window    creating the window's shell and widget tree by calling  create (optional)  assigning the window to a window manager using  WindowManager.add (optional)  opening the window by calling open  Opening the window will create its shell and widget tree if they have not  already been created. When the window is closed_ the shell and widget tree  are disposed of and are no longer referenced_ and the window is automatically  removed from its window manager. A window may be reopened.      The JFace window framework (this package) consists of this class_  Window_ the abstract base of all windows_ and one concrete  window classes (ApplicationWindow) which may also be  subclassed. Clients may define additional window subclasses as required.      The Window class provides methods that subclasses may   override to configure the window_ including:    close- extend to free other SWT resources  configureShell- extend or reimplement to set shell  properties before window opens  createContents- extend or reimplement to create controls  before window opens  getInitialSize- reimplement to give the initial size for  the shell  getInitialLocation- reimplement to give the initial  location for the shell  getShellListener- extend or reimplement to receive shell  events  handleFontChange- reimplement to respond to font changes    handleShellCloseEvent- extend or reimplement to handle  shell closings      "
1181,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/ApplicationWindow.html,"Interface for UI components which can execute a long-running operation  in the form of an IRunnableWithProgress.  The context is responsible for displaying a progress indicator and Cancel  button to the end user while the operation is in progress; the context  supplies a progress monitor to be used from code running inside the operation.  Note that an IRunnableContext is not a runnable itself.    For examples of UI components which implement this interface_  see ApplicationWindow_ ProgressMonitorDialog_  and WizardDialog.    See Also:  IRunnableWithProgress_  ApplicationWindow_  ProgressMonitorDialog_  WizardDialog    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends Window implements IRunnableContext An application window is a high-level ""main window""_ with built-in  support for an optional menu bar with standard menus_ an optional toolbar_  and an optional status line.    Creating an application window involves the following steps:    creating an instance of ApplicationWindow    assigning the window to a window manager (optional)    opening the window by calling open    Only on the last step_ when the window is told to open_ are  the window's shell and widget tree created. When the window is  closed_ the shell and widget tree are disposed of and are no longer  referenced_ and the window is automatically removed from its window  manager. Like all windows_ an application window may be reopened.      An application window is also a suitable context in which to perform   long-running operations (that is_ it implements IRunnableContext).      "
1182,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/menus/IWidget.html," Provides a hook by which third-party code can contribute SWT widgets to a  menu_ tool bar or status line. This can be used_ for example_ to add a combo  box to the status line_ or a ""Location"" bar to the tool bar.      It is possible for fill and dispose to be called multiple times for a single  instance of IWidget.      Clients may implement_ but must not extend.    Since:  3.2    "
1183,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/IWorkbenchWidget.html," Provides a hook by which third-party code can contribute SWT widgets to a  menu_ tool bar or status line. This can be used_ for example_ to add a combo  box to the status line_ or a ""Location"" bar to the tool bar.      It is possible for fill and dispose to be called multiple times for a single  instance of IWidget.      Clients may implement_ but must not extend.    Since:  3.2    
extends IWidget Interface used for IWidget's contributed to the  Workbench. Allows the contributed widget to be  informed as to which WorkbenchWindow it's being  hosted in.  Since:  3.2  See Also:  IWidget    "
1184,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPropertyPage.html,"Interface for a page in a multi-page dialog.    
extends IDialogPage An interface for a preference page. This interface  is used primarily by the page's container    
extends IPreferencePage Interface for workbench property pages. Property pages generally show up in  the workbench's Property Pages dialog.    Clients should implement this interface and include the name of their class  in an extension contributed to the workbench's property page extension point   (named ""org.eclipse.ui.propertyPages"").  For example_ the plug-in's XML markup might contain:    <extension point=""org.eclipse.ui.propertyPages"">  <page id=""com.example.myplugin.props""  name=""Knobs""  objectClass=""org.eclipse.core.resources.IResource""  class=""com.example.myplugin.MyPropertyPage"" />  </extension>        Property pages that support multiple selected objects should  implement IWorkbenchPropertyPageMulti instead.    See Also:  IWorkbenchPropertyPageMulti    "
1185,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/AbstractMultiEditor.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
extends EditorPart A AbstractMultiEditor is a composite of editors.    This class is intended to be subclassed.  Since:  3.5    "
1186,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TaskItem.html,extends Item Instances of this class represent a task item.    Styles:  (none)  Events:  (none)  Since:  3.6  See Also:  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
1187,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CTabFolderEvent.html,extends TypedEvent This event is sent when an event is generated in the CTabFolder.  See Also:  Sample code and further information_  Serialized Form    
1188,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/InstanceScope.html,"Clients implement this interface to provide context to a   particular scope. Instances of implementations of this interface are   passed to the IPreferencesService for use in   preference searching.    Clients may implement this interface.    Since:  3.0  See Also:  IPreferencesService    
extends org.eclipse.core.internal.preferences.AbstractScope Object representing the instance scope in the Eclipse preferences  hierarchy. Can be used as a context for searching for preference  values (in the IPreferencesService APIs) or for determining the   correct preference node to set values in the store.    Instance preferences are stored on a per instance basis in the  platform's instance area as specified by the Location class  and the Location.INSTANCE_FILTER filter.    The path for preferences defined in the instance scope hierarchy  is as follows: /instance/<qualifier>      This class is not intended to be subclassed. This class may be instantiated.    Since:  3.0  See Also:  Location.INSTANCE_FILTER    "
1189,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TaskBar.html,extends Widget Instances of this class represent the system task bar.    Styles:  (none)  Events:  (none)  Since:  3.6  See Also:  Display.getSystemTaskBar()_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
1190,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/JobChangeAdapter.html,"Callback interface for clients interested in being notified when jobs change state.    A single job listener instance can be added either to the job manager_ for notification  of all scheduled jobs_ or to any set of individual jobs. A single listener instance should  not be added to both the job manager_ and to individual jobs (such a listener may  receive duplicate notifications).    Clients should not rely on the result of the Job#getState()   method on jobs for which notification is occurring. Listeners are notified of   all job state changes_ but whether the state change occurs before_ during_ or   after listeners are notified is unspecified.    Clients may implement this interface.    Since:  3.0  See Also:  JobChangeAdapter_  IJobManager.addJobChangeListener(IJobChangeListener)_  IJobManager.removeJobChangeListener(IJobChangeListener)_  Job.addJobChangeListener(IJobChangeListener)_  Job.getState()_  Job.removeJobChangeListener(IJobChangeListener)    
extends Object implements IJobChangeListener This adapter class provides default implementations for the  methods described by the IJobChangeListener interface.    Classes that wish to listen to the progress of scheduled jobs can  extend this class and override only the methods which they are  interested in.    Since:  3.0  See Also:  IJobChangeListener    "
1191,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/PopupDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends Window A lightweight_ transient dialog that is popped up to show contextual or  temporal information and is easily dismissed. Clients control whether the  dialog should be able to receive input focus. An optional title area at the  top and an optional info area at the bottom can be used to provide additional  information.    Because the dialog is short-lived_ most of the configuration of the dialog is  done in the constructor. Set methods are only provided for those values that  are expected to be dynamically computed based on a particular instance's  internal state.    Clients are expected to override the creation of the main dialog area_ and  may optionally override the creation of the title area and info area in order  to add content. In general_ however_ the creation of stylistic features_ such  as the dialog menu_ separator styles_ and fonts_ is kept private so that all  popup dialogs will have a similar appearance.  Since:  3.2    "
1192,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseTrackListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated as the mouse  pointer passes (or hovers) over controls.    After creating an instance of a class that implements  this interface it can be added to a control using the  addMouseTrackListener method and removed using  the removeMouseTrackListener method. When the  mouse pointer passes into or out of the area of the screen  covered by a control or pauses while over a control_ the  appropriate method will be invoked.    See Also:  MouseTrackAdapter_  MouseEvent    
1193,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseTrackAdapter.html,"extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated as the mouse  pointer passes (or hovers) over controls.    After creating an instance of a class that implements  this interface it can be added to a control using the  addMouseTrackListener method and removed using  the removeMouseTrackListener method. When the  mouse pointer passes into or out of the area of the screen  covered by a control or pauses while over a control_ the  appropriate method will be invoked.    See Also:  MouseTrackAdapter_  MouseEvent    
extends Object implements MouseTrackListener This adapter class provides default implementations for the  methods described by the MouseTrackListener interface.    Classes that wish to deal with MouseEvents which  occur as the mouse pointer passes (or hovers) over controls can  extend this class and override only the methods which they are  interested in.    See Also:  MouseTrackListener_  MouseEvent_  Sample code and further information    "
1194,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/fieldassist/ContentAssistCommandAdapter.html,extends ContentProposalAdapter ContentAssistCommandAdapter extends ContentProposalAdapter to invoke  content proposals using a specified Command.  The ability to specify a KeyStroke  that explicitly invokes content proposals is hidden by this class_ and  instead the String id of a command is used. If no command id is specified by  the client_ then the default workbench content assist command is used.    As of 3.3_ ContentAssistCommandAdapter can be optionally configured to  install the content assist decoration on its control.    This class is not intended to be subclassed.  Since:  3.2    
1195,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IMenuListener.html,A menu listener that gets informed when a menu is about to show.  See Also:  MenuManager.addMenuListener(org.eclipse.jface.action.IMenuListener)    
1196,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/update/configurator/IPlatformConfiguration.html,Platform configuration interface. Represents the runtime  configuration used by the Eclipse platform. Any configuration  changes do not take effect until next startup of the Eclipse  platform.    Do not provide implementations of this interface or its nested interfaces. Use the factory methods   on IPlatformConfigurationFactory to create a IPlatformConfiguration_ then use the factory methods  on the IPlatformConfiguration to create instances of ISiteEntry_IFeatureEntry and ISitePolicy.      Note: This class/interface is part of an interim API that is still under development and expected to  change significantly before reaching stability. It is being made available at this early stage to solicit feedback  from pioneering adopters on the understanding that any code that uses this API will almost certainly be broken  (repeatedly) as the API evolves.    Since:  3.0    
1197,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/about/IInstallationPageContainer.html,Interface for a container that hosts one or more installation pages (  InstallationPage).  Since:  3.5  Restriction:  This interface is not intended to be implemented by clients.    
1198,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IKeySequenceBinding.html,extends Comparable  An instance of IKeySequenceBinding represents a binding  between a command and a key sequence. This is a wrapper for the a key  sequence.      This interface is not intended to be extended or implemented by clients.    Since:  3.0  See Also:  ICommand_  KeyBinding  Restriction:  This interface is not intended to be implemented by clients.    
1199,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/CompoundContributionItem.html,"A contribution item represents a contribution to a shared UI resource such as a  menu or tool bar. More generally_ contribution items are managed by a contribution  manager.  For instance_ in a tool bar a contribution item is a tool bar button or a separator.  In a menu bar a contribution item is a menu_ and in a menu a contribution item   is a menu item or separator.    A contribution item can realize itself in different SWT widgets_ using the different   fill methods. The same type of contribution item can be used with a   MenuBarManager_ ToolBarManager_ CoolBarManager_   or a StatusLineManager.      This interface is internal to the framework; it should not be implemented outside  the framework.    See Also:  IContributionManager  Restriction:  This interface is not intended to be implemented by clients.    
extends ContributionItem A compound contribution is a contribution item consisting of a  dynamic list of contribution items.  Since:  3.1    "
1200,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/StatusLineLayoutData.html,extends Object Represents the layout data object for Control within the status line.  To set a StatusLineLayoutData object into a Control_ use  the setLayoutData() method.     NOTE: Do not reuse StatusLineLayoutData objects. Every control in the  status line must have a unique StatusLineLayoutData instance or  null.    Since:  2.1    
1201,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ltk/ui/refactoring/resource/DeleteResourcesWizard.html,"Interface for a wizard. A wizard maintains a list of wizard pages_  stacked on top of each other in card layout fashion.    The class Wizard provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if Wizard does not suit their needs.    See Also:  Wizard    
extends RefactoringWizard A wizard for the delete resources refactoring.  Since:  3.4    "
1202,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ltk/ui/refactoring/RefactoringWizardOpenOperation.html,extends Object A helper class to open a refactoring wizard dialog. The class first checks  the initial conditions of the refactoring and depending on its outcome  the wizard dialog or an error dialog is shown.    Note: this class is not intended to be extended by clients.    Since:  3.0  Restriction:  This class is not intended to be subclassed by clients.    
1203,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ltk/ui/refactoring/resource/MoveResourcesWizard.html,"Interface for a wizard. A wizard maintains a list of wizard pages_  stacked on top of each other in card layout fashion.    The class Wizard provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if Wizard does not suit their needs.    See Also:  Wizard    
extends RefactoringWizard A wizard for the move resources refactoring.  Since:  3.4    "
1204,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ltk/ui/refactoring/resource/RenameResourceWizard.html,"Interface for a wizard. A wizard maintains a list of wizard pages_  stacked on top of each other in card layout fashion.    The class Wizard provides an abstract implementation  of this interface. However_ clients are also free to implement this   interface if Wizard does not suit their needs.    See Also:  Wizard    
extends RefactoringWizard A wizard for the rename resource refactoring.  Since:  3.4    "
1205,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILazyTreeContentProvider.html,"A content provider mediates between the viewer's model  and the viewer itself.  See Also:  ContentViewer.setContentProvider(IContentProvider)    
extends IContentProvider The ILazyTreeContentProvider is the content provider for tree viewers created  using the SWT.VIRTUAL flag that only wish to return their contents as they  are queried.  Since:  3.2    "
1206,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/UnionSet.html,"An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
An object with state that allows to listen for state changes.      Implementations must not manage listeners themselves_ listener management  must be delegated to a private instance of type ChangeSupport if it  is not inherited from AbstractObservable.    Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes in the  framework that implement this interface. Note that direct  implementers of this interface outside of the framework will be  broken in future releases when methods are added to this  interface.    
extends IObservable_ Collection Interface for observable collections. Only general change listeners can be  added to an observable collection. Listeners interested in incremental  changes have to be added using more concrete subtypes such as  IObservableList or IObservableSet.  Since:  1.0  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.   Restriction:  This interface is not intended to be extended by clients.    
extends Set_ IObservableCollection A set whose changes can be tracked by set change listeners.  Since:  1.0  See Also:  AbstractObservableSet_  ObservableSet  Restriction:  This interface is not intended to be implemented by clients.  Clients should instead subclass one of the classes that  implement this interface. Note that direct implementers of this  interface outside of the framework will be broken in future  releases when methods are added to this interface.    
extends ObservableSet Represents a set consisting of the union of elements from one or more other  sets. This object does not need to be explicitly disposed. If nobody is  listening to the UnionSet_ the set will remove its listeners.      This class is thread safe. All state accessing methods must be invoked from  the current realm. Methods for adding and removing  listeners may be invoked from any thread.    Since:  1.0    "
1207,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ISectionDescriptorProvider.html,Represents a section descriptor provider for tabbed property sections.    
1208,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/PerspectiveLabelProvider.html,"A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider Extends IBaseLabelProvider with the methods  to provide the text and/or image for the label of a given element.   Used by most structured viewers_ except table viewers.    
A label provider maps an element of the viewer's model to  an optional image and optional text string used to display  the element in the viewer's control. Certain label providers  may allow multiple labels per element.  This is an ""abstract interface""_ defining methods common  to all label providers_ but does not actually define the methods  to get the label(s) for an element. This interface should never  be directly implemented.  Most viewers will take either an ILabelProvider or  an ITableLabelProvider.    A label provider must not be shared between viewers  since a label provider generally manages SWT resources (images)_  which must be disposed when the viewer is disposed.  To simplify life cycle management_ the current label provider  of a viewer is disposed when the viewer is disposed.      Label providers can be used outside the context of viewers wherever  images are needed. When label providers are used in this fashion  it is the responsibility of the user to ensure dispose  is called when the provider is no longer needed.    See Also:  ILabelProvider_  ITableLabelProvider    
extends IBaseLabelProvider Extends IBaseLabelProvider with the methods  to provide the text and/or image for each column of a given element.   Used by table viewers.  See Also:  TableViewer    
extends LabelProvider implements ITableLabelProvider A table label provider implementation for showing workbench perspectives   (objects of type IPerspectiveDescriptor) in table- and   tree-structured viewers.    Clients may instantiate this class. It is not intended to be subclassed.    Since:  3.0    "
1209,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/datatransfer/FileSystemStructureProvider.html,"Interface which can provide structure and content information   for an element (for example_ a file system element).  Used by the import wizards to abstract the commonalities  between importing from the file system and importing from an archive.    
extends Object implements IImportStructureProvider This class provides information regarding the structure and  content of specified file system File objects.    "
1210,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/DecoratedField.html,extends Object DecoratedField manages image decorations around a control. It allows clients  to specify an image decoration and a position for the decoration relative to  the field. Decorations may be assigned descriptions_ which are shown when the  user hovers over the decoration. Clients can decorate any kind of control by  supplying a IControlCreator to create the control that is decorated.    Decorations always appear on either horizontal side of the field_ never above  or below it. Decorations can be positioned at the top or bottom of either  side. Future implementations may provide additional positioning options for  decorations.    By default_ DecoratedField will consult the FieldDecorationRegistry  to determine how much space should be reserved for each decoration. This  allows fields with decorations from different sources to align properly on  the same dialog_ since the registry tracks the size of all decorations  registered. Therefore_ it is recommended_ but not required_ that clients of  DecoratedField register the decorations used. In cases where alignment  between different fields is not a concern_ clients can use  setUseMaximumDecorationWidth(false) and need not register  their decorations.    This class is not intended to be subclassed.  Since:  3.2    
1211,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/ManagedForm.html,"Managed form wraps a form widget and adds life cycle methods for form parts.  A form part is a portion of the form that participates in form life cycle  events.    There is no 1/1 mapping between widgets and form parts. A widget like Section  can be a part by itself_ but a number of widgets can gather around one form  part.    This interface should not be extended or implemented. New form instances  should be created using ManagedForm.  Since:  3.0  See Also:  ManagedForm  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
extends Object implements IManagedForm Managed form wraps a form widget and adds life cycle methods for form parts.  A form part is a portion of the form that participates in form life cycle  events.    There is requirement for 1/1 mapping between widgets and form parts. A widget  like Section can be a part by itself_ but a number of widgets can join around  one form part.    Note to developers: this class is left public to allow its use beyond the  original intention (inside a multi-page editor's page). You should limit the  use of this class to make new instances inside a form container (wizard page_  dialog etc.). Clients that need access to the class should not do it  directly. Instead_ they should do it through IManagedForm interface as much  as possible.  Since:  3.0    "
1212,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ScrolledFormText.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends SharedScrolledComposite ScrolledFormText is a control that is capable of scrolling an instance of  the FormText class. It should be created in a parent that will allow it to  use all the available area (for example_ a shell_ a view or an editor). The  form text can be created by the class itself_ or set from outside. In the  later case_ the form text instance must be a direct child of the  ScrolledFormText instance.    The class assumes that text to be rendered contains formatting tags. In case  of a string_ it will enclose the text in 'form' root element if missing from  the text as a convinience. For example:      ftext.setText(""<p>Some text here</>"");      will not cause an error. The same behavior does not exist for content from  the input stream_ however - it must be well formed in that case.    Since:  3.0  See Also:  FormText    "
1213,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/common/HandleObject.html," An object that is unique identifiable based on the combination of its class  and its identifier.    Since:  3.2  See Also:  HandleObject    
extends EventManager implements IIdentifiable  An object that can exist in one of two states: defined and undefined. This is  used by APIs that want to give a handle to an object_ even though the object  does not fully exist yet. This way_ users can attach listeners to objects  before they come into existence. It also protects the API from users that do  not release references when they should.      To enforce good coding practice_ all handle objects must implement  equals and toString. Please use  string to cache the result for toString once  calculated.      All handle objects are referred to using a single identifier. This identifier  is a instance of String. It is important that this identifier  remain unique within whatever context that handle object is being used. For  example_ there should only ever be one instance of Command  with a given identifier.    Since:  3.1    "
1214,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/AbstractWorkbenchTrimWidget.html," Provides a hook by which third-party code can contribute SWT widgets to a  menu_ tool bar or status line. This can be used_ for example_ to add a combo  box to the status line_ or a ""Location"" bar to the tool bar.      It is possible for fill and dispose to be called multiple times for a single  instance of IWidget.      Clients may implement_ but must not extend.    Since:  3.2    
 Provides a hook by which third-party code can contribute SWT widgets to a  menu_ tool bar or status line. This can be used_ for example_ to add a combo  box to the status line_ or a ""Location"" bar to the tool bar.      It is possible for fill and dispose to be called multiple times for a single  instance of IWidget.      Clients may implement_ but must not extend.    Since:  3.2    
extends IWidget Interface used for IWidget's contributed to the  Workbench. Allows the contributed widget to be  informed as to which WorkbenchWindow it's being  hosted in.  Since:  3.2  See Also:  IWidget    
extends AbstractTrimWidget implements IWorkbenchWidget Extension for trim widgets contributed to the workbench.  The extension point handler will call the init  method to inform the contributed widgets as to which  workbench window they're currently being hosted in.  Since:  3.2    "
1215,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/WorkbenchViewerSorter.html,extends ViewerSorter A viewer sorter that sorts elements with registered workbench adapters by their text property.  Note that capitalization differences are not considered by this  sorter_ so a > B > c  See Also:  IWorkbenchAdapter    
1216,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/ControlAnimator.html,extends Object ControlAnimator provides a simple implementation to display or hide a control  at the bottom of the parent composite. Other animations will be written as  subclasses of this class.   Instances of this class can be created using an AnimatorFactory.  Since:  3.2    
1217,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/ControlEnableState.html,extends Object Helper class to save the enable/disable state of a control including all its  descendent controls.    
1218,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceDeltaVisitor.html,An objects that visits resource deltas.    Usage:    class Visitor implements IResourceDeltaVisitor {  public boolean visit(IResourceDelta delta) {  switch (delta.getKind()) {  case IResourceDelta.ADDED :  // handle added resource  break;  case IResourceDelta.REMOVED :  // handle removed resource  break;  case IResourceDelta.CHANGED :  // handle changed resource  break;  }  return true;  }  }  IResourceDelta rootDelta = ...;  rootDelta.accept(new Visitor());        Clients may implement this interface.    See Also:  IResource.accept(IResourceVisitor)    
1219,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/datatransfer/ZipFileStructureProvider.html,"Interface which can provide structure and content information   for an element (for example_ a file system element).  Used by the import wizards to abstract the commonalities  between importing from the file system and importing from an archive.    
extends Object implements IImportStructureProvider This class provides information regarding the context structure and  content of specified zip file entry objects.    "
1220,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ICellModifier.html,A cell modifier is used to access the data model from a cell  editor in an abstract way. It offers methods to:  to check if a a model element's property can be edited or not  retrieve a value a model element's property  to store a cell editor's value back into the model   element's property    This interface should be implemented by classes that wish to  act as cell modifiers.      
1221,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/PluginDropAdapter.html,"extends org.eclipse.swt.internal.SWTEventListener The DropTargetListener class provides event notification to the application   for DropTarget events.  As the user moves the cursor into_ over and out of a Control that has been designated   as a DropTarget_ events indicate what operation can be performed and what data can be   transferred if a drop where to occur at that point.  The application can respond to these events and change the type of data that will   be dropped by modifying event.currentDataType_ or change the operation that will be performed   by modifying the event.detail field or stop any drop from happening on the current target  by setting the event.detail field to DND_DROP_NONE.  When the user causes a drop to happen by releasing the mouse over a valid drop target_   the application has one last chance to change the data type of the drop through the   DropAccept event. If the drop is still allowed_ the DropAccept event is immediately   followed by the Drop event. In the Drop event_ the application can still change the  operation that is performed but the data type is fixed.  See Also:  DropTargetEvent    
extends ViewerDropAdapter Adapter for adding handling of the PluginTransfer drag and drop  transfer type to a drop action.    This class may be instantiated or subclassed.      "
1222,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/ModelProvider.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
extends PlatformObject Represents the provider of a logical model. The main purpose of this  API is to support batch operations on sets of ResourceMapping  objects that are part of the same model.      This class may be subclassed by clients.    Since:  3.2  See Also:  ResourceMapping    "
1223,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleAdapter.html,"extends org.eclipse.swt.internal.SWTEventListener Classes that implement this interface provide methods  that deal with the events that are generated when an  accessibility client sends a message to a control.    After creating an instance of a class that implements  this interface it can be added to a control using the  addAccessibleListener method and removed  using the removeAccessibleListener method.  When a client requests information_ the appropriate method  will be invoked.    Note: Accessibility clients use child identifiers to specify  whether they want information about a control or one of its children.  Child identifiers are increasing integers beginning with 0.  The identifier CHILDID_SELF represents the control itself.    Since:  2.0  See Also:  AccessibleAdapter_  AccessibleEvent    
extends Object implements AccessibleListener This adapter class provides default implementations for the  methods described by the AccessibleListener interface.    Classes that wish to deal with AccessibleEvents can  extend this class and override only the methods that they are  interested in.    Note: Accessibility clients use child identifiers to specify  whether they want information about a control or one of its children.  Child identifiers are increasing integers beginning with 0.  The identifier CHILDID_SELF represents the control itself.    Since:  2.0  See Also:  AccessibleListener_  AccessibleEvent_  Sample code and further information    "
1224,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IOpenListener.html,A listener which is notified of open events on viewers.    
1225,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/SelectionDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends TrayDialog The abstract implementation of a selection dialog. It can be primed with  initial selections (setInitialSelections)_ and returns the  final selection (via getResult) after completion.    Clients may subclass this dialog to inherit its selection facilities.      "
1226,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/GlyphMetrics.html,extends Object Instances of this class represent glyph metrics.    The hashCode() method in this class uses the values of the public  fields to compute the hash value. When storing instances of the  class in hashed collections_ do not modify these fields after the  object has been inserted.       Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.    Since:  3.2  See Also:  TextStyle_  TextLayout_  Sample code and further information    
1227,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IPluginRegistry.html,The plug-in registry holds the master list of all  discovered plug-ins_ extension points_ and extensions.    The plug-in registry can be queried_ by name_ for   plug-ins_ extension points_ and extensions.    Restriction:  This interface is not intended to be implemented by clients.    
1228,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/testing/ITestHarness.html,Represents an arbitrary test harness.  Since:  3.0    
1229,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/ListenerList.html,extends ListenerList This class is used to maintain a list of listeners_ and is used in the  implementations of several classes within JFace which allow you to register  listeners of various kinds. It is a fairly lightweight object_ occupying  minimal space when no listeners are registered.    Note that the add method checks for and eliminates duplicates  based on identity (not equality). Likewise_ the remove method  compares based on identity.      Use the getListeners method when notifying listeners. Note  that no garbage is created if no listeners are registered. The recommended  code sequence for notifying all registered listeners of say_  FooListener.eventHappened_ is:      Object[] listeners = myListenerList.getListeners();  for (int i = 0; i < listeners.length; ++i) {  ((FooListener) listeners[i]).eventHappened(event);  }          
1230,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICategoryListener.html, An instance of ICategoryListener can be used by clients to  receive notification of changes to one or more instances of  ICategory.      This interface may be implemented by clients.    Since:  3.0  See Also:  CategoryEvent_  ICategory.addCategoryListener(ICategoryListener)_  ICategory.removeCategoryListener(ICategoryListener)_  ICategoryListener    
1231,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/CategoryEvent.html,extends Object An instance of this class describes changes to an instance of  ICategory.    This class is not intended to be extended by clients.    Since:  3.0  See Also:  ICategoryListener.categoryChanged(CategoryEvent)_  CategoryEvent    
1232,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/UndoContext.html," An undo context is used to ""tag"" operations as being applicable to a certain  context. The undo context is used to filter the history of operations  available for undo or redo so that only operations appropriate for a given  undo context are shown when the application is presenting that context.      The scope of an undo context is defined by the application that is making  undo and redo of operations available. Undo contexts may be related to  application models_ or may be associated with UI objects that are providing  undo and redo support.      An undo context may be defined as ""matching"" another context. This allows  applications to provide specialized implementations of an undo context that  will appear in the operation history for their matching context.  Since:  3.1    
extends Object implements IUndoContext  A simple_ lightweight undo context that can be used to tag any operation. It  does not provided a specialized label. This class may be instantiated by  clients. This class may also be subclassed.    Since:  3.1    "
1233,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/ContextEvent.html,extends Object An instance of this class describes changes to an instance of  IContext.    This class is not intended to be extended by clients.    Since:  3.0  See Also:  IContextListener.contextChanged(ContextEvent)_  ContextEvent    
1234,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/CommandEvent.html,extends Object An instance of this class describes changes to an instance of  ICommand.    This class is not intended to be extended by clients.    Since:  3.0  See Also:  ICommandListener.commandChanged(CommandEvent)_  CommandEvent    
1235,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/KeyConfigurationEvent.html,extends Object An instance of this class describes changes to an instance of  IKeyConfiguration.    This class is not intended to be extended by clients.    Since:  3.0  See Also:  IKeyConfigurationListener.keyConfigurationChanged(KeyConfigurationEvent)_  SchemeEvent    
1236,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/FileSelectionDialog.html,extends SelectionDialog A standard file selection dialog which solicits a list of files from the user.  The getResult method returns the selected files.    This class may be instantiated; it is not intended to be subclassed.      Example:    FileSelectionDialog dialog =   new FileSelectionDialog(getShell()_ rootElement_ msg);  dialog.setInitialSelections(selectedResources);  dialog.open();  return dialog.getResult();      Restriction:  This class is not intended to be subclassed by clients.    
1237,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/datatransfer/SelectFilesOperation.html,"The IRunnableWithProgress interface should be implemented by any  class whose instances are intended to be executed as a long-running operation.  Long-running operations are typically presented at the UI via a modal dialog  showing a progress indicator and a Cancel button.  The class must define a run method that takes a progress monitor.  The run method is usually not invoked directly_ but rather by  passing the IRunnableWithProgress to the run method of  an IRunnableContext_ which provides the UI for the progress monitor  and Cancel button.  See Also:  IRunnableContext    
extends Object implements IRunnableWithProgress Operation responsible for traversing a specified file system position  recursively and building  - a tree that represents the container structure  - a collection containing all files meeting a specified extension criteria  This is implemented as an Operation in order to provide an escape to the user  (the Cancel button) if the operation drags on for too long    "
1238,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/ViewPart.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ IPersistable A view is a visual component within a workbench page. It is typically used to  navigate a hierarchy of information (like the workspace)_ open an editor_ or  display properties for the active editor. Modifications made in a view are  saved immediately (in contrast to an editor part_ which conforms to a more  elaborate open-save-close lifecycle).    Only one instance of a particular view type may exist within a workbench  page. This policy is designed to simplify part management for a user.      This interface may be implemented directly. For convenience_ a base  implementation is defined in ViewPart.      A view is added to the workbench in two steps:    A view extension is contributed to the workbench registry. This  extension defines the extension id and extension class.  The view is included in the default layout for a perspective.  Alternatively_ the user may open the view from the Perspective menu.      Views implement the IAdaptable interface; extensions are  managed by the platform's adapter manager.      As of 3.4_ views may optionally adapt to ISizeProvider if they have  a preferred size. The default presentation will make a best effort to  allocate the preferred size to a view if it is the only part in a stack. If  there is more than one part in the stack_ the constraints will be disabled  for that stack. The size constraints are adjusted for the size of the tab and  border trim. Note that this is considered to be a hint to the presentation_  and not all presentations may honor size constraints.    See Also:  IWorkbenchPage.showView(java.lang.String)_  ViewPart_  ISizeProvider    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
extends WorkbenchPart implements IViewPart Abstract base implementation of all workbench views.    This class should be subclassed by clients wishing to define new views.  The name of the subclass should be given as the ""class""   attribute in a view extension contributed to the workbench's  view extension point (named ""org.eclipse.ui.views"").  For example_ the plug-in's XML markup might contain:    <extension point=""org.eclipse.ui.views"">  <view id=""com.example.myplugin.view""  name=""My View""  class=""com.example.myplugin.MyView""  icon=""images/eview.gif""  />  </extension>    where com.example.myplugin.MyView is the name of the  ViewPart subclass.      Subclasses must implement the following methods:    createPartControl - to create the view's controls   setFocus - to accept focus      Subclasses may extend or reimplement the following methods as required:    setInitializationData - extend to provide additional   initialization when view extension is instantiated  init(IWorkbenchPartSite) - extend to provide additional  initialization when view is assigned its site  dispose - extend to provide additional cleanup  getAdapter - reimplement to make their view adaptable      "
1239,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/IJavaElement.html,"extends IAdaptable Common protocol for all elements provided by the Java model.  Java model elements are exposed to clients as handles to the actual underlying element.  The Java model may hand out any number of handles for each element. Handles  that refer to the same element are guaranteed to be equal_ but not necessarily identical.    Methods annotated as ""handle-only"" do not require underlying elements to exist.  Methods that require underlying elements to exist throw  a JavaModelException when an underlying element is missing.  JavaModelException.isDoesNotExist can be used to recognize  this common special case.    Restriction:  This interface is not intended to be implemented by clients.    "
1240,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/help/IHelpResource.html,A help resource_ usually a help topic.    This interface models a help resource. In general_ help resources are either  html help files_ or table of contents XML files.    Since:  2.0    
1241,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/help/IUAElement.html,An element in a UA document_ which may have conditional enablement (may be  filtered based on certain conditions) and may have sub-elements_ or children.  Since:  3.3    
1242,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/help/ITopic.html,"A help resource_ usually a help topic.    This interface models a help resource. In general_ help resources are either  html help files_ or table of contents XML files.    Since:  2.0    
An element in a UA document_ which may have conditional enablement (may be  filtered based on certain conditions) and may have sub-elements_ or children.  Since:  3.3    
extends IUAElement_ IHelpResource An ITopic is one topic in the table of contents_ which may  contain subtopics.  Since:  2.0    "
1243,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/search/ui/ISearchQuery.html,"Represents a particular search query (in a Java example_ a query might be  ""find all occurrences of 'foo' in workspace""). When its run method is called_ the query places  any results it finds in the ISearchResult that can be accessed via  getSearchResult(). Note that getSearchResult may be called at any time_ even before  the run() method has been called. An empty search result should be returned in that  case.    Clients may implement this interface.    Since:  3.0    "
1244,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/search/ui/ISearchResult.html,Implementors of this interface represent the result of a search. How the  results of a search are structured is up to the implementor of this  interface. The abstract base implementation provided with  AbstractTextSearchResult  uses a flat list of matches to represent the result of a search. Subclasses  of SearchResultEvent can be used in order to notify listeners  of search result changes.    To present search results to the user implementors of this interface must  also provide an extension for the extension point  org.eclipse.search.searchResultViewPage.      Clients may implement this interface.    Since:  3.0  See Also:  ISearchResultPage    
1245,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/search/ui/SearchResultEvent.html,extends EventObject The common superclass of all events sent from ISearchResults.  This class is supposed to be subclassed to provide more specific  notification.  Since:  3.0  See Also:  ISearchResultListener.searchResultChanged(SearchResultEvent)_  Serialized Form    
1246,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/DialogMessageArea.html,extends Object The DialogMessageArea is a resusable component for adding an accessible  message area to a dialog.    When the message is normal a CLabel is used but an errors replaces the  message area with a non editable text that can take focus for use by screen  readers.  Since:  3.0    
1247,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/PluginVersionIdentifier.html,extends Object  Version identifier for a plug-in. In its string representation_   it consists of up to 4 tokens separated by a decimal point.  The first 3 tokens are positive integer numbers_ the last token  is an uninterpreted string (no whitespace characters allowed).  For example_ the following are valid version identifiers   (as strings):    0.0.0  1.0.127564  3.7.2.build-127J  1.9 (interpreted as 1.9.0)  3 (interpreted as 3.0.0)      The version identifier can be decomposed into a major_ minor_   service level component and qualifier components. A difference  in the major component is interpreted as an incompatible version  change. A difference in the minor (and not the major) component  is interpreted as a compatible version change. The service  level component is interpreted as a cumulative and compatible  service update of the minor version component. The qualifier is  not interpreted_ other than in version comparisons. The   qualifiers are compared using lexicographical string comparison.      Version identifiers can be matched as perfectly equal_ equivalent_  compatible or greaterOrEqual.    This class can be used without OSGi running.    Clients may instantiate; not intended to be subclassed by clients.    See Also:  String.compareTo(java.lang.String)    
1248,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/content/IContentTypeManager.html,"An object that performs content type matching queries.     This interface is not intended to be implemented by clients.    Since:  3.1  See Also:  IContentTypeManager.getMatcher(IContentTypeManager.ISelectionPolicy_ IScopeContext)    
extends IContentTypeMatcher The content type manager provides facilities for file name and content-based  type lookup and content description.    This interface is not intended to be implemented by clients.    Since:  3.0  See Also:  IContentTypeMatcher    "
1249,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/ProgressMonitorPart.html,"The IProgressMonitor interface is implemented  by objects that monitor the progress of an activity; the methods  in this interface are invoked by code that performs the activity.    All activity is broken down into a linear sequence of tasks against  which progress is reported. When a task begins_ a beginTask(String_ int)  notification is reported_ followed by any number and mixture of   progress reports (worked()) and subtask notifications   (subTask(String)). When the task is eventually completed_ a   done() notification is reported. After the done()  notification_ the progress monitor cannot be reused; i.e._   beginTask(String_ int) cannot be called again after the call to   done().      A request to cancel an operation can be signaled using the   setCanceled method. Operations taking a progress  monitor are expected to poll the monitor (using isCanceled)  periodically and abort at their earliest convenience. Operation can however   choose to ignore cancelation requests.      Since notification is synchronous with the activity itself_ the listener should   provide a fast and robust implementation. If the handling of notifications would   involve blocking operations_ or operations which might throw uncaught exceptions_   the notifications should be queued_ and the actual processing deferred (or perhaps  delegated to a separate thread).    This interface can be used without OSGi running.    Clients may implement this interface.      
extends IProgressMonitor An extension to the IProgressMonitor interface for monitors that want to  support feedback when an activity is blocked due to concurrent activity in  another thread.    When a monitor that supports this extension is passed to an operation_ the  operation should call setBlocked whenever it knows that it  must wait for a lock that is currently held by another thread. The operation  should continue to check for and respond to cancelation requests while  blocked. When the operation is no longer blocked_ it must call clearBlocked  to clear the blocked state.    This interface can be used without OSGi running.    Clients may implement this interface.    Since:  3.0  See Also:  IProgressMonitor    
Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Composite implements IProgressMonitorWithBlocking A standard implementation of an IProgressMonitor. It consists  of a label displaying the task and subtask name_ and a  progress indicator to show progress. In contrast to  ProgressMonitorDialog this class only implements  IProgressMonitor.    "
1250,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/model/PluginFragmentModel.html,extends PluginModel An object which represents the user-defined contents of a plug-in fragment  in a plug-in manifest.    This class may be instantiated_ or further subclassed.      
1251,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/SpecialKey.html,"extends NaturalKey  Instances of SpecialKey represent the keys on keyboard  recognized as neither modifier keys nor character keys. These are special  control keys specific to computers (e.g._ ""left arrow""_ ""page down""_ ""F10""_  etc.). They do not include keys representing letters_ numbers or punctuation  from a natural language_ nor do they include any key that can be represented  by a Unicode character (e.g._ ""backspace"").      SpecialKey objects are immutable. Clients are not permitted to  extend this class.    Since:  3.0    "
1252,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/NewWizardAction.html,"An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
extends IAction Interface for a workbench action.    
extends Action implements ActionFactory.IWorkbenchAction Invoke the resource creation wizard selection Wizard.    This class may be instantiated; it is not intended to be subclassed.      This method automatically registers listeners so that it can keep its  enablement state up to date. Ordinarily_ the window's references to these  listeners will be dropped automatically when the window closes. However_  if the client needs to get rid of an action while the window is still open_  the client must call #dispose() to give the  action an opportunity to deregister its listeners and to perform any other  cleanup.    Restriction:  This class is not intended to be subclassed by clients.    "
1253,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/CharacterKey.html,extends NaturalKey  Instances of CharacterKey represent keys on the keyboard which  represent unicode characters.      CharacterKey objects are immutable. Clients are not permitted  to extend this class.    Since:  3.0    
1254,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/OpenInNewWindowAction.html,"An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
extends IAction Interface for a workbench action.    
extends Action implements ActionFactory.IWorkbenchAction Opens a new window. The initial perspective  for the new window will be the same type as  the active perspective in the window which this  action is running in. The default input for the  new window's page is application-specific.    "
1255,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/tasklist/TaskPropertiesDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends org.eclipse.ui.views.markers.internal.DialogTaskProperties Shows the properties of a new or existing task_ or a problem.    "
1256,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ListDialog.html,"Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends SelectionDialog A dialog that prompts for one element out of a list of elements. Uses  IStructuredContentProvider to provide the elements and  ILabelProvider to provide their labels.  Since:  2.1    "
1257,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/PageSite.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends IAdaptable_ IShellProvider_ IServiceLocator The common interface between the workbench and its parts_ including pages  within parts.    The workbench site supports a few services by  default. If these services are used to allocate resources_ it is important to  remember to clean up those resources after you are done with them. Otherwise_  the resources will exist until the workbench site is disposed. The supported  services are:    ICommandService  IContextService  IHandlerService  IBindingService. Resources allocated through this service will  not be cleaned up until the workbench shuts down.    This interface is not intended to be implemented or extended by clients.    Since:  2.0  See Also:  IWorkbenchPartSite_  IPageSite  Restriction:  This interface is not intended to be implemented by clients.    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
 A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2    
Interface for objects that can return a shell. This is normally used for   opening child windows. An object that wants to open child shells can take   an IShellProvider in its constructor_ and the object that implements IShellProvider  can dynamically choose where child shells should be opened.  Since:  3.1    
extends IAdaptable_ IShellProvider_ IServiceLocator The common interface between the workbench and its parts_ including pages  within parts.    The workbench site supports a few services by  default. If these services are used to allocate resources_ it is important to  remember to clean up those resources after you are done with them. Otherwise_  the resources will exist until the workbench site is disposed. The supported  services are:    ICommandService  IContextService  IHandlerService  IBindingService. Resources allocated through this service will  not be cleaned up until the workbench shuts down.    This interface is not intended to be implemented or extended by clients.    Since:  2.0  See Also:  IWorkbenchPartSite_  IPageSite  Restriction:  This interface is not intended to be implemented by clients.    
extends IWorkbenchSite The primary interface between a page and the outside world.    The workbench exposes its implemention of page sites via this interface_  which is not intended to be implemented or extended by clients.    Restriction:  This interface is not intended to be implemented by clients.    
 A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2    
extends Object implements IPageSite_ org.eclipse.ui.internal.services.INestable This implementation of IPageSite provides a site for a page  within a PageBookView. Most methods are forwarded to the  view's site.    "
1258,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IPluginPrerequisite.html,A prerequisite entry declared by a plug-in. The declaration causes  classes defined by the prerequisite plug-in to be visible  to the plug-in that declared the dependency.  See Also:  IPluginDescriptor.getPluginPrerequisites()  Restriction:  This interface is not intended to be implemented by clients.    
1259,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/NavigationLocation.html,"Represents the context marked for the user in the navigation history.    Not intended to be implemented by clients. Clients should subclass NavigationLocation  instead.  Since:  2.1  Restriction:  This interface is not intended to be implemented by clients.    
extends Object implements INavigationLocation Default implementation of INavigationLocation.  Since:  2.1    "
1260,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/VerifyKeyListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the event that is generated when a  key is pressed.  See Also:  VerifyEvent_  Sample code and further information    
1261,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/TypedPosition.html,extends Position Convenience class for positions that have a type_ similar to  ITypedRegion.    As Position_TypedPosition can  not be used as key in hash tables as it overrides equals and  hashCode as it would be a value object.    
1262,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/DocumentEvent.html,extends Object Specification of changes applied to documents. All changes are represented as  replace commands_ i.e. specifying a document range whose text gets replaced  with different text. In addition to this information_ the event also contains  the changed document.  See Also:  IDocument    
1263,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/Position.html,extends Object Positions describe text ranges of a document. Positions are adapted to  changes applied to that document. The text range is specified by an offset  and a length. Positions can be marked as deleted. Deleted positions are  considered to no longer represent a valid text range in the managing  document.    Positions attached to documents are usually updated by position updaters.  Because position updaters are freely definable and because of the frequency  in which they are used_ the fields of a position are made publicly  accessible. Clients other than position updaters are not allowed to access  these public fields.      Positions cannot be used as keys in hash tables as they override  equals and hashCode as they would be value  objects.    See Also:  IDocument    
1264,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITypedRegion.html,"A region describes a certain range in an indexed text store. Text stores are  for example documents or strings. A region is defined by its offset into the  text store and its length.    A region is considered a value object. Its offset and length do not change  over time.    Clients may implement this interface or use the standard implementation  Region.      
extends IRegion Describes a region of an indexed text store such as a document or a string.  The region consists of offset_ length_ and type. The region type is defined  as a string.    A typed region can_ e.g._ be used to described document partitions.    Clients may implement this interface or use the standard implementation  TypedRegion.    "
1265,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/TextAttribute.html,extends Object Description of textual attributes such as color and style. Text attributes  are considered value objects.    Clients usually instantiate object of the class.    
1266,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/TextPresentation.html,extends Object Describes the presentation styles for a section of an indexed text such as a  document or string. A text presentation defines a default style for the whole  section and in addition style differences for individual subsections. Text  presentations can be narrowed down to a particular result window. All methods  are result window aware_ i.e. ranges outside the result window are always  ignored.    All iterators provided by a text presentation assume that they enumerate non  overlapping_ consecutive ranges inside the default range. Thus_ all these  iterators do not include the default range. The default style range must be  explicitly asked for using getDefaultStyleRange.    
1267,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/printing/PrintDialog.html,extends Dialog Instances of this class allow the user to select  a printer and various print-related parameters  prior to starting a print job.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Printing snippets_  SWT Example: ControlExample_ Dialog tab_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
1268,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/printing/PrinterData.html,extends DeviceData Instances of this class are descriptions of a print job  in terms of the printer_ and the scope and type of printing  that is desired. For example_ the number of pages and copies  can be specified_ as well as whether or not the print job  should go to a file.    Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.    See Also:  Printer_  Printer.getPrinterList()_  PrintDialog.open()_  Printing snippets_  Sample code and further information    
1269,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/printing/Printer.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
extends Device Instances of this class are used to print to a printer.  Applications create a GC on a printer using new GC(printer)  and then draw on the printer GC using the usual graphics calls.    A Printer object may be constructed by providing  a PrinterData object which identifies the printer.  A PrintDialog presents a print dialog to the user  and returns an initialized instance of PrinterData.  Alternatively_ calling new Printer() will construct a  printer object for the user's default printer.    Application code must explicitly invoke the Printer.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    See Also:  PrinterData_  PrintDialog_  Printing snippets_  Sample code and further information    "
1270,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TextChangeListener.html,extends org.eclipse.swt.internal.SWTEventListener The StyledText widget implements this listener to receive  notifications when changes to the model occur.  It is not intended to be implemented by clients or by   implementors of StyledTextContent.   Clients should listen to the ModifyEvent or ExtendedModifyEvent   that is sent by the StyledText widget to receive text change   notifications.  Implementors of StyledTextContent should call the textChanging  and textChanged methods when text changes occur as described   below. If the entire text is replaced the textSet method   should be called instead.    
1271,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TextChangedEvent.html,extends TypedEvent This event is sent by the StyledTextContent implementor when a change to   the text occurs.  See Also:  Sample code and further information_  Serialized Form    
1272,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TextChangingEvent.html,extends TypedEvent This event is sent by the StyledTextContent implementor when a change  to the text is about to occur.  See Also:  Sample code and further information_  Serialized Form    
1273,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IInformationControlCreator.html,Interface of a factory for information controls (  IInformationControl).  In order to provide backward compatibility for clients of  IInformationControlCreator_ extension interfaces are used as  a means of evolution. The following extension interfaces exist:  IInformationControlCreatorExtension since  version 3.0 introducing checks of whether existing information control can  be reused and whether information control creators can replace each other.    Since:  2.0  See Also:  IInformationControlCreatorExtension    
1274,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IInformationControl.html,Interface of a control presenting information. The information is given in  the form of an input object. It can be either the content itself or a  description of the content. The specification of what is required from an  input object is left to the implementers of this interface.    If this information control is used by a AbstractHoverInformationControlManager  then that manager will own this control and override any properties that  may have been set before by any other client.    The information control must not grab focus when made visible using  setVisible(true).  In order to provide backward compatibility for clients of  IInformationControl_ extension interfaces are used as a means  of evolution. The following extension interfaces exist:    IInformationControlExtension since  version 2.0 introducing the predicate of whether the control has anything to  show or would be empty  IInformationControlExtension2 since  version 2.1 replacing the original concept of textual input by general input  objects.  IInformationControlExtension3 since  version 3.0 providing access to the control's bounds and introducing  the concept of persistent size and location.  IInformationControlExtension4 since  version 3.3_ adding API which allows to set this information control's status field text.  IInformationControlExtension5 since  version 3.4_ adding API to get the visibility of the control_ to  test whether another control is a child of the information control_  to compute size constraints based on the information control's main font  and to return a control creator for an enriched version of this information control.    Clients can implement this interface and its extension interfaces_  subclass AbstractInformationControl_ or use the (text-based)  default implementation DefaultInformationControl.  Since:  2.0  See Also:  IInformationControlExtension_  IInformationControlExtension2_  IInformationControlExtension3_  IInformationControlExtension4_  IInformationControlExtension5_  AbstractInformationControl_  DefaultInformationControl    
1275,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IUndoManager.html,An undo manager is connected to at most one  ITextViewer.    It monitors the text viewer and keeps a history of the changes applied to the  viewer. The undo manager groups those changes into user interactions which on  an undo request are rolled back in one atomic change.    In order to provide backward compatibility for clients of  IUndoManager_ extension interfaces are used as a means of  evolution. The following extension interfaces exist:    IUndoManagerExtension since version 3.1  introducing access to the undo context.    Clients may implement this interface or use the standard implementation  TextViewerUndoManager.    See Also:  TextViewerUndoManager_  IUndoManagerExtension    
1276,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/reconciler/IReconciler.html,An IReconciler defines and maintains a model of the content  of the text viewer's document in the presence of changes applied to this  document. An IReconciler is a ITextViewer add-on.    Reconcilers are assumed to be asynchronous_ i.e. they allow a certain  temporal window of inconsistency between the document and the model of  the content of this document.      Reconcilers have a list of IReconcilingStrategy  objects each of which is registered for a particular document content type.  The reconciler uses the strategy objects to react on the changes applied  to the text viewer's document.    In order to provide backward compatibility for clients of IReconciler_ extension  interfaces are used to provide a means of evolution. The following extension interfaces exist:    IReconcilerExtension since version 3.0 introducing  the ability to be aware of documents with multiple partitionings.      The interface can be implemented by clients. By default_ clients use  MonoReconciler or  Reconciler as the standard  implementers of this interface.    See Also:  ITextViewer_  IReconcilingStrategy    
1277,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/presentation/IPresentationReconciler.html,An IPresentationReconciler defines and maintains the  representation of a text viewer's document in the presence of changes applied  to the document. An IPresentationReconciler is a  ITextViewer add-on.    The presentation reconciler keeps track of changes applied to the text  viewer. It sends each change to presentation damagers which are registered  for the content types of the regions in which the change occurred. The  presentation reconciler passes the computed damage to presentation repairer  which construct text presentations. When applied to the presentation  reconciler's text viewer_ those text presentations bring the document's  presentation in sync with the document's content and thus repair the damage.  A presentation damager is expected to return damage which is a valid input  for a presentation repairer registered for the same content type as the  damager.      A presentation reconciler should always be configured with a pair of  damager/repairer strategies. I.e. for each damager there should be a  corresponding repairer.      The interface may be implemented by clients. Clients may use  PresentationReconciler as the standard implementation of this  interface.      In order to provided backward compatibility for clients of  IPresentationReconciler_ extension interfaces are used to  provide a means of evolution. The following extension interface exists:      IPresentationReconcilerExtension  since version 3.0 adding support for documents with multiple partitionings.      See Also:  IPresentationReconcilerExtension_  ITextViewer_  IPresentationDamager_  IPresentationRepairer_  TextPresentation    
1278,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/formatter/IContentFormatter.html,The interface of a document content formatter. The formatter formats ranges  within documents. The documents are modified by the formatter.  The content formatter is assumed to determine the partitioning of the document  range to be formatted. For each partition_ the formatter determines based  on the partition's content type the formatting strategy to be used. Before  the first strategy is activated all strategies are informed about the  start of the formatting process. After that_ the formatting strategies are  activated in the sequence defined by the partitioning of the document range to be  formatted. It is assumed that a strategy must be finished before the next strategy  can be activated. After the last strategy has been finished_ all strategies are  informed about the termination of the formatting process.    The interface can be implemented by clients. By default_ clients use ContentFormatter  or MultiPassContentFormatter as the standard implementers of this interface.  See Also:  IDocument_  IFormattingStrategy    
1279,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/contentassist/IContentAssistant.html,An IContentAssistant provides support on interactive content completion.  The content assistant is a ITextViewer add-on. Its  purpose is to propose_ display_ and insert completions of the content  of the text viewer's document at the viewer's cursor position. In addition  to handle completions_ a content assistant can also be requested to provide  context information. Context information is shown in a tool tip like popup.  As it is not always possible to determine the exact context at a given  document offset_ a content assistant displays the possible contexts and requests  the user to choose the one whose information should be displayed.    A content assistant has a list of IContentAssistProcessor  objects each of which is registered for a particular document content  type. The content assistant uses the processors to react on the request  of completing documents or presenting context information.      In order to provide backward compatibility for clients of IContentAssistant_ extension  interfaces are used to provide a means of evolution. The following extension interfaces exist:    IContentAssistantExtension since version 3.0 introducing  the following functions:  handle documents with multiple partitions  insertion of common completion prefixes    IContentAssistantExtension2 since version 3.2 introducing  the following functions:  repeated invocation (cycling) mode  completion listeners  a local status line for the completion popup  control over the behavior when no proposals are available    IContentAssistantExtension3 since version 3.2 introducing  the following function:  a key-sequence to listen for in repeated invocation mode    IContentAssistantExtension4 since version 3.4 introducing  the following function:  allows to get a handler for the given command identifier        The interface can be implemented by clients. By default_ clients use  ContentAssistant as the standard  implementer of this interface.    See Also:  ITextViewer_  IContentAssistProcessor    
1280,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IAutoEditStrategy.html,An auto edit strategy can adapt changes that will be applied to  a text viewer's document. The strategy is informed by the text viewer  about each upcoming change in form of a document command. By manipulating  this document command_ the strategy can influence in which way the text  viewer's document is changed. Clients may implement this interface.  Since:  2.1    
1281,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IAutoIndentStrategy.html,"An auto edit strategy can adapt changes that will be applied to  a text viewer's document. The strategy is informed by the text viewer  about each upcoming change in form of a document command. By manipulating  this document command_ the strategy can influence in which way the text  viewer's document is changed. Clients may implement this interface.  Since:  2.1    
extends IAutoEditStrategy Exists for backward compatibility.    "
1282,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextDoubleClickStrategy.html,A text double click strategy defines the reaction of a text viewer to mouse  double click events. The strategy must be installed on an  ITextViewer.    Clients may implement this interface or use the standard implementation  DefaultTextDoubleClickStrategy.  See Also:  ITextViewer_  MouseListener.mouseDoubleClick(org.eclipse.swt.events.MouseEvent)    
1283,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextHover.html,Computes the information to be shown in a hover popup which appears on top of  the text viewer's text widget when a hover event occurs. If the text hover  does not provide information no hover popup is shown. Any implementer of this  interface must be capable of operating in a non-UI thread.    In order to provide backward compatibility for clients of  ITextHover_ extension interfaces are used as a means of  evolution. The following extension interfaces exist:    ITextHoverExtension since version 3.0  allowing a text hover to provide a creator for the hover control. This allows  for sophisticated hovers in a way that information computed by the hover can  be displayed in the best possible form.  ITextHoverExtension2 since version 3.4  allowing a text hover to return hover-specific information objects.    Clients may implement this interface.  See Also:  ITextHoverExtension_  ITextHoverExtension2_  ITextViewer    
1284,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/information/IInformationPresenter.html,An information presenter shows information available at the text viewer's  current document position. An IInformationPresenter is a  ITextViewer add-on.    An information presenters has a list of IInformationProvider objects  each of which is registered for a particular document content type.  The presenter uses the strategy objects to retrieve the information to present.      In order to provide backward compatibility for clients of IInformationPresenter_ extension  interfaces are used to provide a means of evolution. The following extension interfaces exist:    IInformationPresenterExtension since version 3.0 introducing  the ability to handle documents with multiple partitions      The interface can be implemented by clients. By default_ clients use  InformationPresenter as the standard implementer of this interface.    Since:  2.0  See Also:  IInformationPresenterExtension_  ITextViewer_  IInformationProvider    
1285,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IPositionUpdater.html,A position updater is responsible for adapting document positions. When  installed on a document_ the position updater updates the document's  positions to changes applied to this document. Document updaters can be  selective_ i.e. they might only update positions of a certain category.    Position updaters are of primary importance for the definition of the  semantics of positions.    Clients may implement this interface or use the standard implementation  DefaultPositionUpdater.    See Also:  IDocument_  Position    
1286,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IDocumentExtension.html,Extension interface for IDocument.  It introduces the notion of sequentially rewriting a document. This is to tell a  document that a sequence of non-overlapping replace operation is about to be  performed. Implementers can use this knowledge for internal optimization.  Is also introduces the concept of post notification replaces. This is_ a document  listener who is informed about a document change can cause a derived document  change. As the listener is not allowed to directly modify the document_ it can  register a replace operation that is performed directly after all document listeners  have been notified.  Since:  2.0    
1287,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IDocumentExtension2.html,Extension interface for IDocument.  It adds configuration methods to post notification replaces and document  listener notification.  Since:  2.1    
1288,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IDocumentExtension3.html,Extension interface for IDocument.    Adds the concept of multiple partitionings and the concept of zero-length  partitions in conjunction with open and delimited partitions. A delimited  partition has a well defined start delimiter and a well defined end  delimiter. Between two delimited partitions there may be an open partition of  length zero.    In order to fulfill the contract of this interface_ the document must be  configured with a document partitioner implementing  IDocumentPartitionerExtension2.  Since:  3.0  See Also:  IDocumentPartitionerExtension2    
1289,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IDocumentExtension4.html,Extension interface for IDocument. It adds the  following concepts:  Rewrite sessions. A rewrite session is a sequence of replace operations  that form a semantic unit.  A modification stamp on the document  The ability to set the initial line delimiter and to query the default  line delimiter  Since:  3.1    
1290,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IRepairableDocument.html,Tagging interface to be implemented by  IDocument implementers that offer a line  repair method on the documents.    In order to provide backward compatibility for clients of  IRepairableDocument_ extension interfaces are used to provide  a means of evolution. The following extension interfaces exist:    IRepairableDocumentExtension since version 3.4  adds the ability to query whether the repairable document needs to be repaired.  Since:  3.0  See Also:  IDocument_  IRepairableDocumentExtension    
1291,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IRepairableDocumentExtension.html,Extension interface for IRepairableDocument.    Adds the ability to query whether the repairable document would have to be repaired after  replacing some text.  Since:  3.4  See Also:  IRepairableDocument    
1292,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/Document.html,"An IDocument represents text providing support for  text manipulation    positions    partitions    line information    document change listeners    document partition change listeners    A document allows to set its content and to manipulate it. For manipulation  a document provides the replace method which substitutes a given  string for a specified text range in the document. On each document change_ all  registered document listeners are informed exactly once.    Positions are stickers to the document's text that are updated when the  document is changed. Positions are updated by IPositionUpdaters. Position  updaters are managed as a list. The list defines the sequence in which position  updaters are invoked. This way_ position updaters may rely on each other.  Positions are grouped into categories. A category is a ordered list of positions.  the document defines the order of position in a category based on the position's offset  based on the implementation of the method computeIndexInCategory.  Each document must support a default position category whose name is specified by this  interface.    A document can be considered consisting of a sequence of not overlapping partitions.  A partition is defined by its offset_ its length_ and its type. Partitions are  updated on every document manipulation and ensured to be up-to-date when the document  listeners are informed. A document uses an IDocumentPartitioner to  manage its partitions. A document may be unpartitioned which happens when there is no  partitioner. In this case_ the document is considered as one single partition of a  default type. The default type is specified by this interface. If a document change  changes the document's partitioning all registered partitioning listeners are  informed exactly once. The extension interface IDocumentExtension3  introduced in version 3.0 extends the concept of partitions and allows a document to  not only manage one but multiple partitioning. Each partitioning has an id which must  be used to refer to a particular partitioning.    An IDocument provides methods to map line numbers and character  positions onto each other based on the document's line delimiters. When moving text  between documents using different line delimiters_ the text must be converted to  use the target document's line delimiters.    An IDocument does not care about mixed line delimiters. Clients who  want to ensure a single line delimiter in their document should use the line  delimiter returned by TextUtilities.getDefaultLineDelimiter(IDocument).    IDocument throws BadLocationException if the parameters of  queries or manipulation requests are not inside the bounds of the document. The purpose  of this style of exception handling is    prepare document for multi-thread access    allow clients to implement backtracking recovery methods    prevent clients from up-front contract checking when dealing with documents.      A document support for searching has deprecated since version 3.0. The recommended way  for searching is to use a FindReplaceDocumentAdapter.    In order to provide backward compatibility for clients of IDocument_ extension  interfaces are used to provide a means of evolution. The following extension interfaces  exist:    IDocumentExtension since version 2.0 introducing the concept  of post notification replaces in order to allow document listeners to manipulate the document  while receiving a document change notification   IDocumentExtension2 since version 2.1 introducing configuration  methods for post notification replaces and document change notification.   IDocumentExtension3 since version 3.0 replacing the original  partitioning concept by allowing multiple partitionings at the same time and introducing zero-  length partitions in conjunction with the distinction between open and closed partitions.   IDocumentExtension4 since version 3.1 introducing the  concept of rewrite sessions. A rewrite session is a sequence of document replace operations  that form a semantic unit. It also introduces a modification stamp and the ability to  set the initial line delimiter and to query the default line delimiter.    Clients may implement this interface and its extension interfaces or use the default  implementation provided by AbstractDocument and Document.  See Also:  IDocumentExtension_  IDocumentExtension2_  IDocumentExtension3_  IDocumentExtension4_  Position_  IPositionUpdater_  IDocumentPartitioner_  ILineTracker_  IDocumentListener_  IDocumentPartitioningListener    
Extension interface for IDocument.  It introduces the notion of sequentially rewriting a document. This is to tell a  document that a sequence of non-overlapping replace operation is about to be  performed. Implementers can use this knowledge for internal optimization.  Is also introduces the concept of post notification replaces. This is_ a document  listener who is informed about a document change can cause a derived document  change. As the listener is not allowed to directly modify the document_ it can  register a replace operation that is performed directly after all document listeners  have been notified.  Since:  2.0    
Extension interface for IDocument.  It adds configuration methods to post notification replaces and document  listener notification.  Since:  2.1    
Extension interface for IDocument.    Adds the concept of multiple partitionings and the concept of zero-length  partitions in conjunction with open and delimited partitions. A delimited  partition has a well defined start delimiter and a well defined end  delimiter. Between two delimited partitions there may be an open partition of  length zero.    In order to fulfill the contract of this interface_ the document must be  configured with a document partitioner implementing  IDocumentPartitionerExtension2.  Since:  3.0  See Also:  IDocumentPartitionerExtension2    
Extension interface for IDocument. It adds the  following concepts:  Rewrite sessions. A rewrite session is a sequence of replace operations  that form a semantic unit.  A modification stamp on the document  The ability to set the initial line delimiter and to query the default  line delimiter  Since:  3.1    
Tagging interface to be implemented by  IDocument implementers that offer a line  repair method on the documents.    In order to provide backward compatibility for clients of  IRepairableDocument_ extension interfaces are used to provide  a means of evolution. The following extension interfaces exist:    IRepairableDocumentExtension since version 3.4  adds the ability to query whether the repairable document needs to be repaired.  Since:  3.0  See Also:  IDocument_  IRepairableDocumentExtension    
Extension interface for IRepairableDocument.    Adds the ability to query whether the repairable document would have to be repaired after  replacing some text.  Since:  3.4  See Also:  IRepairableDocument    
extends AbstractDocument Default document implementation. Uses a GapTextStore wrapped  inside a CopyOnWriteTextStore as text store.    The used line tracker considers the following strings as line delimiters: ""\n""_ ""\r""_ ""\r\n"". In  case of a text replacement across line delimiter boundaries and with different line delimiters_  the line tracker might have to be repaired. Use  isLineInformationRepairNeeded(int_ int_ String) before doing the text replace if you  have the need to discover such a situation.      The document is ready to use. It has a default position category for which a default position  updater is installed.      Performance: The implementation should perform reasonably well for typical  source code documents. It is not designed for very large documents of a size of several  megabytes. Space-saving implementations are initially used for both the text store and the line  tracker; the first modification after a set incurs the cost to transform the  document structures to efficiently handle updates.      See GapTextStore and TreeLineTracker for algorithmic behavior of the used  document structures.    See Also:  GapTextStore_  CopyOnWriteTextStore    "
1293,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/source/IAnnotationModel.html,This interface defines the model for managing annotations attached to a document.  The model maintains a set of annotations for a given document and notifies registered annotation  model listeners about annotation model changes. It also provides methods  for querying the current position of an annotation managed  by this model.    In order to provide backward compatibility for clients of IAnnotationModel_ extension  interfaces are used to provide a means of evolution. The following extension interfaces  exist:    IAnnotationModelExtension since version 3.0 introducing the concept  of model piggybacking annotation models_ modification time stamps_ and enhanced manipulation methods.    IAnnotationModelExtension2 since version 3.4 allows to retrieve  annotations within a given region.      Clients may implement this interface or use the default implementation provided  by AnnotationModel.  See Also:  IAnnotationModelExtension_  IAnnotationModelExtension2_  Annotation_  IAnnotationModelListener    
1294,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/filebuffers/IPersistableAnnotationModel.html,Tagging interface for IAnnotationModel implementers that offer  state persistence.  Since:  3.0    
1295,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ISynchronizable.html,Interface for text related objects which may be used in the multi-threaded  context and thus must provide a way to prevent concurrent access and  manipulation.    In order to reduce the probability of dead locks clients should synchronize  their access to these objects by using the provided lock object rather than  the object itself.    Managing objects can use the setLockObject method in order to  synchronize whole sets of objects.  Since:  3.0    
1296,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/source/IAnnotationModelExtension.html,Extends IAnnotationModelwith the  ability piggyback other annotation models. It also introduces the concept of  modification time stamps and adds methods for richer manipulation methods.  Since:  3.0    
1297,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/source/IAnnotationModelExtension2.html,Extends IAnnotationModel with the  ability to retrieve a set of annotations within a given region.  Since:  3.4    
1298,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/ResourceMarkerAnnotationModel.html,"Tagging interface for IAnnotationModel implementers that offer  state persistence.  Since:  3.0    
Interface for text related objects which may be used in the multi-threaded  context and thus must provide a way to prevent concurrent access and  manipulation.    In order to reduce the probability of dead locks clients should synchronize  their access to these objects by using the provided lock object rather than  the object itself.    Managing objects can use the setLockObject method in order to  synchronize whole sets of objects.  Since:  3.0    
This interface defines the model for managing annotations attached to a document.  The model maintains a set of annotations for a given document and notifies registered annotation  model listeners about annotation model changes. It also provides methods  for querying the current position of an annotation managed  by this model.    In order to provide backward compatibility for clients of IAnnotationModel_ extension  interfaces are used to provide a means of evolution. The following extension interfaces  exist:    IAnnotationModelExtension since version 3.0 introducing the concept  of model piggybacking annotation models_ modification time stamps_ and enhanced manipulation methods.    IAnnotationModelExtension2 since version 3.4 allows to retrieve  annotations within a given region.      Clients may implement this interface or use the default implementation provided  by AnnotationModel.  See Also:  IAnnotationModelExtension_  IAnnotationModelExtension2_  Annotation_  IAnnotationModelListener    
Extends IAnnotationModelwith the  ability piggyback other annotation models. It also introduces the concept of  modification time stamps and adds methods for richer manipulation methods.  Since:  3.0    
Extends IAnnotationModel with the  ability to retrieve a set of annotations within a given region.  Since:  3.4    
extends AbstractMarkerAnnotationModel A marker annotation model whose underlying source of markers is  a resource in the workspace.    This class may be instantiated; it is not intended to be subclassed.  Restriction:  This class is not intended to be subclassed by clients.    "
1299,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/RetargetTextEditorAction.html,"An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
extends ResourceAction Action used by an editor action bar contributor to establish placeholders in  menus or action bars which can be retargeted to dynamically changing actions_  for example_ those which come from the active editor. This action assumes that  the ""wrapped"" action sends out property change events in response to state  changes. It uses these change notifications to adapt its enabling state and  its visual presentation.    "
1300,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/ResourceAction.html,"An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
extends Action An action which configures its label_ image_ tooltip_ and description from  a resource bundle using known keys.    Clients may subclass this abstract class to define new kinds of actions. As  with Action_ subclasses must implement the  IAction.run method to carry out the action's semantics.      "
1301,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/StatusTextEditor.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Interface for executable extension classes that require access to   their configuration element_ or implement an extension adapter.    Extension adapters are typically required in cases where the extension  implementation does not follow the interface rules specified  by the provider of the extension point. In these  cases_ the role of the adapter is to map between the extension point  interface_ and the actual extension implementation. In general_ adapters  are used when attempting to plug-in existing Java implementations_ or  non-Java implementations (e.g._ external executables).    This interface can be used without OSGi running.    Clients may implement this interface.    See Also:  IConfigurationElement.createExecutableExtension(String)    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Should be implemented by editors that wish to contribute to the  navigation history. The message createNavigationLocation  will be sent when a new location is marked in the history.  Since:  2.1    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
Objects implementing this interface are capable of saving their  state in an IMemento.  Since:  3.1    
extends IPersistable An editor can implement this interface and participate in the workbench  session save/restore cycle using IMemento_ similar to how  IViewPart currently works.    Refer to IWorkbenchPart for the part lifecycle.      If a memento is available_ restoreState(*) will be inserted into the editor  startup.    editor.init(site_ input)  editor.restoreState(memento)  editor.createPartControl(parent)  ...      On workbench shutdown_ the editor state will be persisted when the editor  references are saved.    Since:  3.3    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IEditorPart Interface for reusable editors.     An editors may support changing its input so that   the workbench may change its contents instead of   opening a new editor.    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
Represents a source of Saveable objects (units of saveability). Workbench  parts that show more than one unit of saveability_ or whose units of  saveability change over time_ should implement this interface in order to  provide better integration with workbench facilities like the Save command_  prompts to save on part close or shutdown_ etc.    IMPORTANT: As of 3.2_ implementers of ISaveablesSource must  satisfy the following conditions:    If ISaveablesSource is implemented by an IWorkbenchPart:  the part must implement ISaveablePart  if any of its Saveable objects are dirty_ the part must return  true from ISaveablePart.isDirty()  the part must return true from  ISaveablePart.isSaveOnCloseNeeded() if it is dirty (the default  behaviour implemented by EditorPart)  the part must not implement ISaveablePart2    If ISaveablesSource is implemented by a non-part (possible as of 3.2.1 and 3.3):  the Workbench's ISaveablesLifecycleListener (obtained from the  Workbench by calling  workbench.getService(ISaveablesLifecycleListener.class)) must  be notified of any change to the result of getSaveables()   getActiveSaveables() should be implemented to return an empty array      If any of these conditions are not met_ it is undefined whether the Workbench  will prompt to save dirty Saveables when closing parts or the Workbench.      These conditions may be relaxed in future releases.    Since:  3.2    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart Extends IWorkbenchPart_ adding the name and status text properties.  Prior to 3.0_ a view's title was often modified to show both the part  name and extra status text. With this interface_ the distinction is  made more explicit.  Since:  3.0    
extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted  between sessions by the part reference_ and will be available from the part  reference as well as the part. The properties can only be set on a part_ not  on the reference. The properties will be available to the IPresentablePart.    Setting a property must fire a PropertyChangeEvent.    Since:  3.3    
The IWorkbenchPartOrientation is the interface that defines the orientation  of the part. If a type does not implement this interface an orientation of  SWT.NONE will be assumed.  Since:  3.1  See Also:  SWT.RIGHT_TO_LEFT_  SWT.LEFT_TO_RIGHT_  SWT.NONE_  Window.getDefaultOrientation()    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IWorkbenchPart_ ISaveablePart An editor is a visual component within a workbench page. It is  typically used to edit or browse a document or input object. The input   is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model (in contrast   to a view part_ where modifications are saved to the workbench   immediately).    An editor is document or input-centric. Each editor has an input_ and only  one editor can exist for each editor input within a page. This policy has   been designed to simplify part management.     An editor should be used in place of a view whenever more than one instance  of a document type can exist.    This interface may be implemented directly. For convenience_ a base  implementation is defined in EditorPart.      An editor part is added to the workbench in two stages:    An editor extension is contributed to the workbench registry. This  extension defines the extension id_ extension class_ and the file   extensions which are supported by the editor.  An editor part based upon the extension is created and added to the  workbench when the user opens a file with one of the supported file  extensions (or some other suitable form of editor input).      All editor parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IWorkbenchPage.openEditor(IEditorInput_ String)_  EditorPart    
Workbench parts implement or adapt to this interface to participate  in the enablement and execution of the Save and  Save As actions.  Since:  2.1  See Also:  IEditorPart    
extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    
extends IEditorPart Interface to a text editor. This interface defines functional extensions to  IEditorPart as well as the configuration capabilities of a text editor.    Text editors are configured with an IDocumentProvider which delivers a textual  presentation (IDocument) of the editor's input. The editor works on the document and  forwards all input element related calls_ such as save_ to the document provider.  The provider also delivers the input's annotation model which is used by the editor's vertical  ruler.      Clients may implement this interface from scratch_ but the recommended way is to subclass the  abstract base class AbstractTextEditor.      In order to provided backward compatibility for clients of ITextEditor_ extension  interfaces are used to provide a means of evolution. The following extension interfaces exist:    ITextEditorExtension since version 2.0 introducing status  fields_ read-only state and ruler context menu listeners.  ITextEditorExtension2 since version 2.1 introducing  modifiable state for the editor input and validate state handling.  ITextEditorExtension3 since version 3.0 adding input state  and change information control.  ITextEditorExtension4 since version 3.2 adding annotation  navigation and revision information display.  ITextEditorExtension5 since version 3.5 adding block  selection mode.    See Also:  IDocumentProvider_  IAnnotationModel_  ITextEditorExtension_  ITextEditorExtension2_  ITextEditorExtension3_  ITextEditorExtension4_  ITextEditorExtension5    
Extension interface for ITextEditor. Adds  the following functions:  status fields    read-only state of the editor's input    ruler context menu listeners.    Since:  2.0    
Extension interface for ITextEditor. Adds  the following functions:  modifiable state of the editor's input  validate state of editor input  Since:  2.1    
Extension interface for ITextEditor. Adds  the following functions:  insert mode management  Since:  3.0    
Extension interface for ITextEditor. Adds  the following functions:  annotation navigation  revision information display    This interface may be implemented by clients.    Since:  3.2    
Extension interface for ITextEditor. Adds the following  functions:  block selection mode    This interface may be implemented by clients.    Since:  3.5    
extends AbstractTextEditor Capable of handling input elements that have an associated status with them.  Since:  2.0    "
1302,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/source/Annotation.html,"extends Object Annotation managed by an  IAnnotationModel.    Annotations are typed_ can have an associated text and can be marked as persistent and  deleted. Annotations which are not explicitly initialized with an annotation  type are of type ""org.eclipse.text.annotation.unknown"".    "
1303,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IMarkRegionTarget.html,A mark region target to support marked regions as found in emacs.  Since:  2.0    
1304,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/source/SourceViewerConfiguration.html,extends Object This class bundles the configuration space of a source viewer. Instances of  this class are passed to the configure method of  ISourceViewer.    Each method in this class get as argument the source viewer for which it  should provide a particular configuration setting such as a presentation  reconciler. Based on its specific knowledge about the returned object_ the  configuration might share such objects or compute them according to some  rules.    Clients should subclass and override just those methods which must be  specific to their needs.  See Also:  ISourceViewer    
1305,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/source/IVerticalRulerExtension.html,Extension interface for IVerticalRuler.    Allows to set the font of the vertical ruler and to set the location of the  last mouse button activity.  Since:  2.0    
1306,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IFindReplaceTarget.html,Defines the target for finding and replacing strings.    The two main methods are findAndSelect and  replaceSelection. The target does not provide any way to  modify the content other than replacing the selection.    In order to provide backward compatibility for clients of  IFindReplaceTarget_ extension interfaces are used as a means  of evolution. The following extension interfaces exist:    IFindReplaceTargetExtension since version  2.0 introducing the notion of find/replace session and of a find/replace  scope. In additions_ in allows clients to replace all occurrences of a given  find query.  IFindReplaceTargetExtension3 since  version 3.0 allowing clients to specify search queries as regular  expressions.    Clients of a IFindReplaceTarget that also implements the  IFindReplaceTargetExtension have to indicate the start of a find/replace  session before using the target and to indicate the end of the session when the  target is no longer used.  See Also:  IFindReplaceTargetExtension_  IFindReplaceTargetExtension3    
1307,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/NullProgressMonitor.html,"The IProgressMonitor interface is implemented  by objects that monitor the progress of an activity; the methods  in this interface are invoked by code that performs the activity.    All activity is broken down into a linear sequence of tasks against  which progress is reported. When a task begins_ a beginTask(String_ int)  notification is reported_ followed by any number and mixture of   progress reports (worked()) and subtask notifications   (subTask(String)). When the task is eventually completed_ a   done() notification is reported. After the done()  notification_ the progress monitor cannot be reused; i.e._   beginTask(String_ int) cannot be called again after the call to   done().      A request to cancel an operation can be signaled using the   setCanceled method. Operations taking a progress  monitor are expected to poll the monitor (using isCanceled)  periodically and abort at their earliest convenience. Operation can however   choose to ignore cancelation requests.      Since notification is synchronous with the activity itself_ the listener should   provide a fast and robust implementation. If the handling of notifications would   involve blocking operations_ or operations which might throw uncaught exceptions_   the notifications should be queued_ and the actual processing deferred (or perhaps  delegated to a separate thread).    This interface can be used without OSGi running.    Clients may implement this interface.      
extends Object implements IProgressMonitor A default progress monitor implementation suitable for  subclassing.    This implementation supports cancelation. The default  implementations of the other methods do nothing.    This class can be used without OSGi running.      "
1308,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/TextEvent.html,extends Object This event is sent to implementers of  ITextListener. It represents a change applied  to text viewer. The change is specified as a replace command using offset_  length_ inserted text_ and replaced text. The text viewer issues a text event  after the viewer has been changed either in response to a change of the  viewer's document or when the viewer's visual content has been changed. In  the first case_ the text event also carries the original document event.  Depending on the viewer's presentation mode_ the text event coordinates are  different from the document event's coordinates.    An empty text event usually indicates a change of the viewer's redraw state.    Clients other than text viewer's don't create instances of this class.  See Also:  ITextListener_  ITextViewer_  DocumentEvent    
1309,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IFindReplaceTargetExtension.html,Extension interface for IFindReplaceTarget.    Introduces the concepts of find/replace sessions_ searching in a limiting  scope and a replace-all mode.    If a scope is set_ findAndSelect is limited to the scope.  Occurrences outside of the scope are not considered.  Since:  2.0    
1310,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IRewriteTarget.html,A target publishing the required functions to modify a document that is displayed  in a text viewer. It provides access to the document and control  over the redraw behavior and the grouping of document changes into undo commands.  Since:  2.0  See Also:  ITextViewer_  IDocument_  IUndoManager    
1311,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/equinox/app/IApplication.html,Bootstrap type for an application. An IApplication represent executable   entry points into an application. An IApplication can be configured into   the Platform's org.eclipse.core.runtime.applications extension-point.    Clients may implement this interface.    Since:  1.0    
1312,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ant/core/AntRunner.html,"Bootstrap type for an application. An IApplication represent executable   entry points into an application. An IApplication can be configured into   the Platform's org.eclipse.core.runtime.applications extension-point.    Clients may implement this interface.    Since:  1.0    
extends Object implements IApplication Entry point for running Ant builds inside Eclipse (within the same JRE).  Clients may instantiate this class; it is not intended to be subclassed.      Usage note:  Clients may use the addBuildListener_  addBuildLogger and setInputHandler  methods to configure classes that will be invoked during the  build. When using these methods_ it is necessary to package  the classes in a jar that is not on the client plugin's classpath.  The jar must be added to the Ant classpath. One way to add   the jar to the Ant classpath is to use the  org.eclipse.ant.core.extraClasspathEntries extension.  Refer to the ""Platform Ant Support"" chapter of the Programmer's Guide  section in the Platform Plug-in Developer Guide for complete details.    Restriction:  This class is not intended to be subclassed by clients.    "
1313,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/OpenPerspectiveMenu.html,extends PerspectiveMenu A menu for window creation in the workbench.     An OpenPerspectiveMenu is used to populate a menu with  actions that will open a new perspective. If the user selects one of   these items either a new page is added to the workbench_ a new   workbench window is created with the chosen perspective or the current  perspective will be replaced with the new onw.    The visible perspectives within the menu may also be updated dynamically to  reflect user preference.    The input for the page is determined by the value of pageInput.  The input should be passed into the constructor of this class or set using  the setPageInput method.    This class may be instantiated; it is not intended to be subclassed.    Restriction:  This class is not intended to be subclassed by clients.    
1314,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TreeEditor.html,"extends ControlEditor A TreeEditor is a manager for a Control that appears above a cell in a Tree and tracks with the  moving and resizing of that cell. It can be used to display a text widget above a cell  in a Tree so that the user can edit the contents of that cell. It can also be used to display  a button that can launch a dialog for modifying the contents of the associated cell.  Here is an example of using a TreeEditor:    final Tree tree = new Tree(shell_ SWT.BORDER);  for (int i = 0; i < 3; i++) {  TreeItem item = new TreeItem(tree_ SWT.NONE);  item.setText(""item "" + i);  for (int j = 0; j < 3; j++) {  TreeItem subItem = new TreeItem(item_ SWT.NONE);  subItem.setText(""item "" + i + "" "" + j);  }  }    final TreeEditor editor = new TreeEditor(tree);  //The editor must have the same size as the cell and must  //not be any smaller than 50 pixels.  editor.horizontalAlignment = SWT.LEFT;  editor.grabHorizontal = true;  editor.minimumWidth = 50;    tree.addSelectionListener(new SelectionAdapter() {  public void widgetSelected(SelectionEvent e) {  // Clean up any previous editor control  Control oldEditor = editor.getEditor();  if (oldEditor != null) oldEditor.dispose();    // Identify the selected row  TreeItem item = (TreeItem)e.item;  if (item == null) return;    // The control that will be the editor must be a child of the Tree  Text newEditor = new Text(tree_ SWT.NONE);  newEditor.setText(item.getText());  newEditor.addModifyListener(new ModifyListener() {  public void modifyText(ModifyEvent e) {  Text text = (Text)editor.getEditor();  editor.getItem().setText(text.getText());  }  });  newEditor.selectAll();  newEditor.setFocus();  editor.setEditor(newEditor_ item);  }  });    See Also:  TreeEditor snippets_  Sample code and further information    "
