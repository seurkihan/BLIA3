id,class_url,description
1,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Point.html,extends Object implements org.eclipse.swt.internal.SerializableCompatibility Instances of this class represent places on the (x_ y)  coordinate plane.    The coordinate space for rectangles and points is considered  to have increasing values downward and to the right from its  origin making this the normal_ computer graphics oriented notion  of (x_ y) coordinates rather than the strict mathematical one.      The hashCode() method in this class uses the values of the public  fields to compute the hash value. When storing instances of the  class in hashed collections_ do not modify these fields after the  object has been inserted.       Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.    See Also:  Rectangle_  Sample code and further information_  Serialized Form    
2,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/RGB.html,extends Object implements org.eclipse.swt.internal.SerializableCompatibility Instances of this class are descriptions of colors in  terms of the primary additive color model (red_ green and  blue). A color may be described in terms of the relative  intensities of these three primary colors. The brightness  of each color is specified by a value in the range 0 to 255_  where 0 indicates no color (blackness) and 255 indicates  maximum intensity.    The hashCode() method in this class uses the values of the public  fields to compute the hash value. When storing instances of the  class in hashed collections_ do not modify these fields after the  object has been inserted.       Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.    See Also:  Color_  Color and RGB snippets_  Sample code and further information_  Serialized Form    
3,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/Accessible.html,extends Object Instances of this class provide a bridge between application  code and assistive technology clients. Many platforms provide  default accessible behavior for most widgets_ and this class  allows that default behavior to be overridden. Applications  can get the default Accessible object for a control by sending  it getAccessible_ and then add an accessible listener  to override simple items like the name and help string_ or they  can add an accessible control listener to override complex items.  As a rule of thumb_ an application would only want to use the  accessible control listener to implement accessibility for a  custom control.  Since:  2.0  See Also:  Control.getAccessible()_  AccessibleListener_  AccessibleEvent_  AccessibleControlListener_  AccessibleControlEvent_  Accessibility snippets_  Sample code and further information    
4,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Event.html,extends Object Instances of this class provide a description of a particular  event which occurred within SWT. The SWT untyped listener  API uses these instances for all event dispatching.    Note: For a given event_ only the fields which are appropriate  will be filled in. The contents of the fields which are not used  by the event are unspecified.    See Also:  Listener_  TypedEvent_  SWT Example: ControlExample_ Listeners_  Sample code and further information    
5,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/ImageLoader.html,extends Object Instances of this class are used to load images from_  and save images to_ a file or stream.    Currently supported image formats are:    BMP (Windows or OS/2 Bitmap)  ICO (Windows Icon)  JPEG  GIF  PNG  TIFF  ImageLoaders can be used to:  load/save single images in all formats  load/save multiple images (GIF/ICO/TIFF)  load/save animated GIF images  load interlaced GIF/PNG images  load progressive JPEG images  See Also:  SWT Example: ImageAnalyzer_  Sample code and further information    
6,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Drawable.html,Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC    
7,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Control.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Widget implements Drawable Control is the abstract superclass of all windowed user interface classes.      Styles:    BORDER  LEFT_TO_RIGHT_ RIGHT_TO_LEFT_ FLIP_TEXT_DIRECTION  Events:    DragDetect_ FocusIn_ FocusOut_ Help_ KeyDown_ KeyUp_ MenuDetect_ MouseDoubleClick_ MouseDown_ MouseEnter_  MouseExit_ MouseHover_ MouseUp_ MouseMove_ MouseWheel_ MouseHorizontalWheel_ MouseVerticalWheel_ Move_  Paint_ Resize_ Traverse    Only one of LEFT_TO_RIGHT or RIGHT_TO_LEFT may be specified.    IMPORTANT: This class is intended to be subclassed only  within the SWT implementation.    See Also:  Control snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
8,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/GC.html,extends Resource Class GC is where all of the drawing capabilities that are   supported by SWT are located. Instances are used to draw on either an   Image_ a Control_ or directly on a Display.  Styles:  LEFT_TO_RIGHT_ RIGHT_TO_LEFT      The SWT drawing coordinate system is the two-dimensional space with the origin  (0_0) at the top left corner of the drawing area and with (x_y) values increasing  to the right and downward respectively.        The result of drawing on an image that was created with an indexed  palette using a color that is not in the palette is platform specific.  Some platforms will match to the nearest color while other will draw  the color itself. This happens because the allocated image might use  a direct palette on platforms that do not support indexed palette.        Application code must explicitly invoke the GC.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required. This is particularly  important on Windows95 and Windows98 where the operating system has a limited  number of device contexts available.        Note: Only one of LEFT_TO_RIGHT and RIGHT_TO_LEFT may be specified.    See Also:  PaintEvent_  GC snippets_  SWT Examples: GraphicsExample_ PaintExample_  Sample code and further information    
9,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/SelectionListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated when selection  occurs in a control.    After creating an instance of a class that implements  this interface it can be added to a control using the  addSelectionListener method and removed using  the removeSelectionListener method. When  selection occurs in a control the appropriate method  will be invoked.    See Also:  SelectionAdapter_  SelectionEvent    
10,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Rectangle.html,extends Object implements org.eclipse.swt.internal.SerializableCompatibility Instances of this class represent rectangular areas in an  (x_ y) coordinate system. The top left corner of the rectangle  is specified by its x and y values_ and the extent of the  rectangle is specified by its width and height.    The coordinate space for rectangles and points is considered  to have increasing values downward and to the right from its  origin making this the normal_ computer graphics oriented notion  of (x_ y) coordinates rather than the strict mathematical one.      The hashCode() method in this class uses the values of the public  fields to compute the hash value. When storing instances of the  class in hashed collections_ do not modify these fields after the  object has been inserted.       Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.    See Also:  Point_  Sample code and further information_  Serialized Form    
11,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TabItem.html,extends Item Instances of this class represent a selectable user interface object  corresponding to a tab for a page in a tab folder.  Styles:  (none)  Events:  (none)    IMPORTANT: This class is not intended to be subclassed.    See Also:  TabFolder_ TabItem snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
12,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Composite.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Scrollable Instances of this class are controls which are capable  of containing other controls.  Styles:  NO_BACKGROUND_ NO_FOCUS_ NO_MERGE_PAINTS_ NO_REDRAW_RESIZE_ NO_RADIO_GROUP_ EMBEDDED_ DOUBLE_BUFFERED  Events:  (none)    Note: The NO_BACKGROUND_ NO_FOCUS_ NO_MERGE_PAINTS_  and NO_REDRAW_RESIZE styles are intended for use with Canvas.  They can be used with Composite if you are drawing your own_ but their  behavior is undefined if they are used with subclasses of Composite other  than Canvas.    Note: The CENTER style_ although undefined for composites_ has the  same value as EMBEDDED which is used to embed widgets from other  widget toolkits into SWT. On some operating systems (GTK_ Motif)_ this may cause  the children of this composite to be obscured.    This class may be subclassed by custom control implementors  who are building controls that are constructed from aggregates  of other controls.    See Also:  Canvas_  Composite snippets_  Sample code and further information    "
13,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Listener.html,Implementers of Listener provide a simple   handleEvent() method that is used internally   by SWT to dispatch events.    After creating an instance of a class that implements this interface  it can be added to a widget using the   addListener(int eventType_ Listener handler) method and  removed using the   removeListener (int eventType_ Listener handler) method.   When the specified event occurs_ handleEvent(...) will  be sent to the instance.      Classes which implement this interface are described within SWT as  providing the untyped listener API. Typically_ widgets will  also provide a higher-level typed listener API_ that is based  on the standard java.util.EventListener pattern.        Note that_ since all internal SWT event dispatching is based on untyped  listeners_ it is simple to build subsets of SWT for use on memory   constrained_ small footprint devices_ by removing the classes and  methods which implement the typed listener API.    See Also:  Widget.addListener(int_ org.eclipse.swt.widgets.Listener)_  EventListener_  org.eclipse.swt.events    
14,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Shell.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Decorations Instances of this class represent the ""windows""  which the desktop or ""window manager"" is managing.  Instances that do not have a parent (that is_ they  are built using the constructor_ which takes a   Display as the argument) are described  as top level shells. Instances that do have  a parent are described as secondary or  dialog shells.    Instances are always displayed in one of the maximized_   minimized or normal states:      When an instance is marked as maximized_ the  window manager will typically resize it to fill the  entire visible area of the display_ and the instance  is usually put in a state where it can not be resized   (even if it has style RESIZE) until it is  no longer maximized.      When an instance is in the normal state (neither  maximized or minimized)_ its appearance is controlled by  the style constants which were specified when it was created  and the restrictions of the window manager (see below).      When an instance has been marked as minimized_  its contents (client area) will usually not be visible_  and depending on the window manager_ it may be  ""iconified"" (that is_ replaced on the desktop by a small  simplified representation of itself)_ relocated to a  distinguished area of the screen_ or hidden. Combinations  of these changes are also possible.      The modality of an instance may be specified using  style bits. The modality style bits are used to determine  whether input is blocked for other shells on the display.  The PRIMARY_MODAL style allows an instance to block  input to its parent. The APPLICATION_MODAL style  allows an instance to block input to every other shell in the  display. The SYSTEM_MODAL style allows an instance  to block input to all shells_ including shells belonging to  different applications.    Note: The styles supported by this class are treated  as HINTs_ since the window manager for the  desktop on which the instance is visible has ultimate  control over the appearance and behavior of decorations  and modality. For example_ some window managers only  support resizable windows and will always assume the  RESIZE style_ even if it is not set. In addition_ if a  modality style is not supported_ it is ""upgraded"" to a  more restrictive modality style that is supported. For  example_ if PRIMARY_MODAL is not supported_  it would be upgraded to APPLICATION_MODAL.  A modality style may also be ""downgraded"" to a less  restrictive style. For example_ most operating systems  no longer support SYSTEM_MODAL because  it can freeze up the desktop_ so this is typically  downgraded to APPLICATION_MODAL.    Styles:  BORDER_ CLOSE_ MIN_ MAX_ NO_TRIM_ RESIZE_ TITLE_ ON_TOP_ TOOL_ SHEET  APPLICATION_MODAL_ MODELESS_ PRIMARY_MODAL_ SYSTEM_MODAL  Events:  Activate_ Close_ Deactivate_ Deiconify_ Iconify  Class SWT provides two ""convenience constants""  for the most commonly required style combinations:  SHELL_TRIM    the result of combining the constants which are required  to produce a typical application top level shell: (that   is_ CLOSE | TITLE | MIN | MAX | RESIZE)    DIALOG_TRIM    the result of combining the constants which are required  to produce a typical application dialog shell: (that   is_ TITLE | CLOSE | BORDER)        Note: Only one of the styles APPLICATION_MODAL_ MODELESS_   PRIMARY_MODAL and SYSTEM_MODAL may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Decorations_  SWT_  Shell snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
15,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Display.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     provides inter-thread  communication methods which allow threads other than the   user-interface thread to request that it perform operations  on their behalf.)      The thread is not allowed to construct other   Displays until that display has been disposed.  (Note that_ this is in addition to the restriction mentioned  above concerning platform support for multiple displays. Thus_  the only way to have multiple simultaneously active displays_  even on platforms which support it_ is to have multiple threads.)    Enforcing these attributes allows SWT to be implemented directly  on the underlying operating system's event model. This has   numerous benefits including smaller footprint_ better use of   resources_ safer memory management_ clearer program logic_  better performance_ and fewer overall operating system threads  required. The down side however_ is that care must be taken  (only) when constructing multi-threaded applications to use the  inter-thread communication mechanisms which this class provides  when required.    All SWT API methods which may only be called from the user-interface  thread are distinguished in their documentation by indicating that  they throw the ""ERROR_THREAD_INVALID_ACCESS""  SWT exception.    Styles:  (none)  Events:  Close_ Dispose_ OpenDocument_ Settings_ Skin    IMPORTANT: This class is not intended to be subclassed.    See Also:  syncExec(java.lang.Runnable)_  asyncExec(java.lang.Runnable)_  wake()_  readAndDispatch()_  sleep()_  Device.dispose()_  Display snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
16,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/Browser.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Composite Instances of this class implement the browser user interface  metaphor. It allows the user to visualize and navigate through  HTML documents.    Note that although this class is a subclass of Composite_  it does not make sense to set a layout on it.    Styles:  MOZILLA_ WEBKIT  Events:  CloseWindowListener_ LocationListener_ OpenWindowListener_ ProgressListener_ StatusTextListener_ TitleListener_ VisibilityWindowListener    Note: At most one of the styles MOZILLA and WEBKIT may be specified.      IMPORTANT: This class is not intended to be subclassed.    Since:  3.0  See Also:  Browser snippets_  SWT Examples: ControlExample_ BrowserExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
17,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/opengl/GLData.html,extends Object The GLData class is a device-independent description  of the pixel format attributes of a GL drawable.  Since:  3.2  See Also:  GLCanvas_  OpenGL snippets_  Sample code and further information    
18,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/printing/PrinterData.html,extends DeviceData Instances of this class are descriptions of a print job  in terms of the printer_ and the scope and type of printing  that is desired. For example_ the number of pages and copies  can be specified_ as well as whether or not the print job  should go to a file.    Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.    See Also:  Printer_  Printer.getPrinterList()_  PrintDialog.open()_  Printing snippets_  Sample code and further information    
19,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/ImageData.html,extends Object implements org.eclipse.swt.internal.CloneableCompatibility Instances of this class are device-independent descriptions  of images. They are typically used as an intermediate format  between loading from or writing to streams and creating an   Image.    Note that the public fields x_ y_   disposalMethod and delayTime are  typically only used when the image is in a set of images used  for animation.    See Also:  Image_  ImageLoader_  ImageData snippets_  SWT Example: ImageAnalyzer_  Sample code and further information    
20,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/PaletteData.html,extends Object Instances of this class describe the color data used by an image.    Depending on the depth of the image_ the PaletteData can take one  of two forms_ indicated by the isDirect field:      isDirect is false      If isDirect is false_ this palette is an indexed  palette which maps pixel values to RGBs. The actual RGB values  may be retrieved by using the getRGBs() method.      isDirect is true      If isDirect is true_ this palette is a direct color  palette. Instead of containing RGB values_ it contains red_  green and blue mask and shift information which indicates how  the color components may be extracted from a given pixel.  This means that the RGB value is actually encoded in the pixel value.    In this case_ the shift data is the number of bits required to shift  the RGB value to the left in order to align the high bit of the  corresponding mask with the high bit of the first byte. This number  may be negative_ so care must be taken when shifting. For example_  with a red mask of 0xFF0000_ the red shift would be -16. With a red  mask of 0x1F_ the red shift would be 3.      See Also:  Image_  RGB_  Sample code and further information    
21,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/ASTParser.html,extends Object A Java language parser for creating abstract syntax trees (ASTs).    Example: Create basic AST from source string    char[] source = ...;  ASTParser parser = ASTParser.newParser(AST.JLS3); // handles JDK 1.0_ 1.1_ 1.2_ 1.3_ 1.4_ 1.5_ 1.6  parser.setSource(source);  // In order to parse 1.5 code_ some compiler options need to be set to 1.5  Map options = JavaCore.getOptions();  JavaCore.setComplianceOptions(JavaCore.VERSION_1_5_ options);  parser.setCompilerOptions(options);  CompilationUnit result = (CompilationUnit) parser.createAST(null);    Once a configured parser instance has been used to create an AST_  the settings are automatically reset to their defaults_  ready for the parser instance to be reused.      There are a number of configurable features:    Source string from char[]_  ICompilationUnit_  or IClassFile_ and limited  to a specified subrange.  Whether bindings will be created.  Which working copy owner to use when resolving bindings.  A hypothetical compilation unit file name  and Java project  for locating a raw source string in the Java model (when  resolving bindings)  Which compiler options  to use. This is especially important to use if the parsing/scanning of the source code requires a  different version than the default of the workspace. For example_ the workspace defaults are 1.4 and  you want to create an AST for a source code that is using 1.5 constructs.  Whether to parse just an expression_ statements_  or body declarations rather than an entire compilation unit.  Whether to return a abridged AST  focused on the declaration containing a given source position.    Since:  3.0  Restriction:  This class is not intended to be instantiated by clients.    
22,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/CompilationUnit.html,extends ASTNode Java compilation unit AST node type. This is the type of the root of an AST.    The source range for this type of node is ordinarily the entire source file_  including leading and trailing whitespace and comments.    For JLS2:    CompilationUnit:  [ PackageDeclaration ]  { ImportDeclaration }  { TypeDeclaration | ; }    For JLS3_ the kinds of type declarations  grew to include enum and annotation type declarations:    CompilationUnit:  [ PackageDeclaration ]  { ImportDeclaration }  { TypeDeclaration | EnumDeclaration | AnnotationTypeDeclaration | ; }    Since:  2.0  Restriction:  This class is not intended to be instantiated by clients.    
23,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/TypeDeclaration.html,"extends AbstractTypeDeclaration Type declaration AST node type. A type declaration  is the union of a class declaration and an interface declaration.  For JLS2:    TypeDeclaration:  ClassDeclaration  InterfaceDeclaration  ClassDeclaration:  [ Javadoc ] { Modifier } class Identifier  [ extends Type]  [ implements Type { _ Type } ]  { { ClassBodyDeclaration | ; } }  InterfaceDeclaration:  [ Javadoc ] { Modifier } interface Identifier  [ extends Type { _ Type } ]  { { InterfaceBodyDeclaration | ; } }    For JLS3_ type parameters and reified modifiers  (and annotations) were added_ and the superclass type name and superinterface  types names are generalized to type so that parameterized types can be  referenced:    TypeDeclaration:  ClassDeclaration  InterfaceDeclaration  ClassDeclaration:  [ Javadoc ] { ExtendedModifier } class Identifier  [ < TypeParameter { _ TypeParameter } > ]  [ extends Type ]  [ implements Type { _ Type } ]  { { ClassBodyDeclaration | ; } }  InterfaceDeclaration:  [ Javadoc ] { ExtendedModifier } interface Identifier  [ < TypeParameter { _ TypeParameter } > ]  [ extends Type { _ Type } ]  { { InterfaceBodyDeclaration | ; } }      When a Javadoc comment is present_ the source  range begins with the first character of the ""/**"" comment delimiter.  When there is no Javadoc comment_ the source range begins with the first  character of the first modifier or annotation (if any)_ or the  first character of the ""class"" or ""interface"" keyword (if no  modifiers or annotations). The source range extends through the last character of the ""}""  token following the body declarations.    Since:  2.0  Restriction:  This class is not intended to be instantiated by clients.    "
24,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/ImportDeclaration.html,extends ASTNode Import declaration AST node type.  For JLS2:    ImportDeclaration:  import Name [ . * ] ;    For JLS3_ static was added:    ImportDeclaration:  import [ static ] Name [ . * ] ;    Since:  2.0  Restriction:  This class is not intended to be instantiated by clients.    
25,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/Javadoc.html,extends Comment AST node for a Javadoc-style doc comment.    Javadoc:  /** { TagElement } */    Since:  2.0  Restriction:  This class is not intended to be instantiated by clients.    
26,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/TagElement.html,extends ASTNode AST node for a tag within a doc comment.  Tag elements nested within another tag element are called  inline doc tags.    TagElement:  [ @ Identifier ] { DocElement }  DocElement:  TextElement  Name  MethodRef  MemberRef  { TagElement }    Since:  3.0  See Also:  Javadoc  Restriction:  This class is not intended to be instantiated by clients.    
27,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/FieldDeclaration.html,"extends BodyDeclaration Field declaration node type.    This kind of node collects several variable declaration fragments  (VariableDeclarationFragment) into a single body declaration  (BodyDeclaration)_ all sharing the same modifiers and base type.      FieldDeclaration:  [Javadoc] { ExtendedModifier } Type VariableDeclarationFragment  { _ VariableDeclarationFragment } ;      When a Javadoc comment is present_ the source range begins with the first  character of the ""/**"" comment delimiter. When there is no Javadoc comment_  the source range begins with the first character of the initial modifier or  type. The source range extends through the last character of the final "";"".    Since:  2.0  Restriction:  This class is not intended to be instantiated by clients.    "
28,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/VariableDeclarationFragment.html,extends VariableDeclaration Variable declaration fragment AST node type_ used in field declarations_  local variable declarations_ and ForStatement initializers.  It contrast to SingleVariableDeclaration_ fragments are  missing the modifiers and the type; these are located in the fragment's  parent node.    VariableDeclarationFragment:  Identifier { [] } [ = Expression ]    Since:  2.0  Restriction:  This class is not intended to be instantiated by clients.    
29,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/MethodDeclaration.html,"extends BodyDeclaration Method declaration AST node type. A method declaration  is the union of a method declaration and a constructor declaration.    For JLS2:    MethodDeclaration:  [ Javadoc ] { Modifier } ( Type | void ) Identifier (  [ FormalParameter  { _ FormalParameter } ] ) {[ ] }  [ throws TypeName { _ TypeName } ] ( Block | ; )  ConstructorDeclaration:  [ Javadoc ] { Modifier } Identifier (  [ FormalParameter  { _ FormalParameter } ] )  [throws TypeName { _ TypeName } ] Block    For JLS3_ type parameters and reified modifiers  (and annotations) were added:    MethodDeclaration:  [ Javadoc ] { ExtendedModifier }  [ < TypeParameter { _ TypeParameter } > ]  ( Type | void ) Identifier (  [ FormalParameter  { _ FormalParameter } ] ) {[ ] }  [ throws TypeName { _ TypeName } ] ( Block | ; )  ConstructorDeclaration:  [ Javadoc ] { ExtendedModifier }  [ < TypeParameter { _ TypeParameter } > ]  Identifier (  [ FormalParameter  { _ FormalParameter } ] )  [throws TypeName { _ TypeName } ] Block      When a Javadoc comment is present_ the source  range begins with the first character of the ""/**"" comment delimiter.  When there is no Javadoc comment_ the source range begins with the first  character of the first modifier keyword (if modifiers)_ or the  first character of the ""<"" token (method_ no modifiers_ type parameters)_  or the first character of the return type (method_ no modifiers_ no type  parameters)_ or the first character of the identifier (constructor_  no modifiers). The source range extends through the last character of the  "";"" token (if no body)_ or the last character of the block (if body).    The FormalParameter is represented by a SingleVariableDeclaration.  Since:  2.0  Restriction:  This class is not intended to be instantiated by clients.    "
30,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/SingleVariableDeclaration.html,extends VariableDeclaration Single variable declaration AST node type. Single variable  declaration nodes are used in a limited number of places_ including formal  parameter lists and catch clauses. They are not used for field declarations  and regular variable declaration statements.  For JLS2:    SingleVariableDeclaration:  { Modifier } Type Identifier { [] } [ = Expression ]    For JLS3_ the modifier flags were replaced by  a list of modifier nodes (intermixed with annotations)_ and the variable arity  indicator was added:    SingleVariableDeclaration:  { ExtendedModifier } Type [ ... ] Identifier { [] } [ = Expression ]    Since:  2.0  Restriction:  This class is not intended to be instantiated by clients.    
31,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/Type.html,extends ASTNode Abstract base class of all type AST node types. A type node represents a  reference to a primitive type (including void)_ to an array type_ or to a  simple named type (or type variable)_ to a qualified type_ to a  parameterized type_ or to a wildcard type. Note that not all of these  are meaningful in all contexts; for example_ a wildcard type is only  meaningful in the type argument position of a parameterized type.      Type:  PrimitiveType  ArrayType  SimpleType  QualifiedType  ParameterizedType  WildcardType  PrimitiveType:  byte  short  char  int  long  float  double  boolean  void  ArrayType:  Type [ ]  SimpleType:  TypeName  ParameterizedType:  Type < Type { _ Type } >  QualifiedType:  Type . SimpleName  WildcardType:  ? [ ( extends | super) Type ]      Since:  2.0    
32,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/ArrayType.html,extends Type Type node for an array type.    Array types are expressed in a recursive manner_ one dimension at a time.      ArrayType:  Type [ ]    Since:  2.0  Restriction:  This class is not intended to be instantiated by clients.    
33,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/ASTNode.html,"extends Object Abstract superclass of all Abstract Syntax Tree (AST) node types.    An AST node represents a Java source code construct_ such  as a name_ type_ expression_ statement_ or declaration.      Each AST node belongs to a unique AST instance_ called the owning AST.  The children of an AST node always have the same owner as their parent node.  If a node from one AST is to be added to a different AST_ the subtree must  be cloned first to ensure that the added nodes have the correct owning AST.      When an AST node is part of an AST_ it has a unique parent node.  Clients can navigate upwards_ from child to parent_ as well as downwards_  from parent to child. Newly created nodes are unparented. When an  unparented node is set as a child of a node (using a  setCHILD method)_ its parent link is set automatically  and the parent link of the former child is set to null.  For nodes with properties that include a list of children (for example_  Block whose statements property is a list  of statements)_ adding or removing an element to/for the list property  automatically updates the parent links. These lists support the  List.set method; however_ the constraint that the same  node cannot appear more than once means that this method cannot be used  to swap elements without first removing the node.      ASTs must not contain cycles. All operations that could create a cycle  detect this possibility and fail.      ASTs do not contain ""holes"" (missing subtrees). If a node is required to  have a certain property_ a syntactically plausible initial value is  always supplied.      The hierarchy of AST node types has some convenient groupings marked  by abstract superclasses:    expressions - Expression  names - Name (a sub-kind of expression)  statements - Statement  types - Type  type body declarations - BodyDeclaration      Abstract syntax trees may be hand constructed by clients_ using the  newTYPE factory methods (see AST) to  create new nodes_ and the various setCHILD methods  to connect them together.      The class ASTParser parses a string  containing a Java source code and returns an abstract syntax tree  for it. The resulting nodes carry source ranges relating the node back to  the original source characters. The source range covers the construct  as a whole.      Each AST node carries bit flags_ which may convey additional information about  the node. For instance_ the parser uses a flag to indicate a syntax error.  Newly created nodes have no flags set.      Each AST node is capable of carrying an open-ended collection of  client-defined properties. Newly created nodes have none.  getProperty and setProperty are used to access  these properties.      AST nodes are thread-safe for readers provided there are no active writers.  If one thread is modifying an AST_ including creating new nodes or cloning  existing ones_ it is not safe for another thread to read_ visit_  write_ create_ or clone any of the nodes on the same AST.  When synchronization is required_ consider using the common AST  object that owns the node; that is_ use  synchronize (node.getAST()) {...}.      ASTs also support the visitor pattern; see the class ASTVisitor  for details. The NodeFinder class can be used to find a specific  node inside a tree.      Compilation units created by ASTParser from a  source document can be serialized after arbitrary modifications  with minimal loss of original formatting. See  CompilationUnit.recordModifications() for details.  See also ASTRewrite for  an alternative way to describe and serialize changes to a  read-only AST.    Since:  2.0  See Also:  ASTParser_  ASTVisitor_  NodeFinder  Restriction:  This class is not intended to be subclassed by clients.    "
34,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ImageDescriptor.html,extends DeviceResourceDescriptor An image descriptor is an object that knows how to create  an SWT image. It does not hold onto images or cache them_  but rather just creates them on demand. An image descriptor  is intended to be a lightweight representation of an image  that can be manipulated even when no SWT display exists.    This package defines a concrete image descriptor implementation  which reads an image from a file (FileImageDescriptor).  It also provides abstract framework classes (this one and  CompositeImageDescriptor) which may be subclassed to define  news kinds of image descriptors.      Using this abstract class involves defining a concrete subclass  and providing an implementation for the getImageData  method.      There are two ways to get an Image from an ImageDescriptor. The method  createImage will always return a new Image which must be disposed by  the caller. Alternatively_ createResource() returns a shared  Image. When the caller is done with an image obtained from createResource_  they must call destroyResource() rather than disposing the Image directly.  The result of createResource() can be safely cast to an Image.     See Also:  Image    
35,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/IJavaElement.html,"extends IAdaptable Common protocol for all elements provided by the Java model.  Java model elements are exposed to clients as handles to the actual underlying element.  The Java model may hand out any number of handles for each element. Handles  that refer to the same element are guaranteed to be equal_ but not necessarily identical.    Methods annotated as ""handle-only"" do not require underlying elements to exist.  Methods that require underlying elements to exist throw  a JavaModelException when an underlying element is missing.  JavaModelException.isDoesNotExist can be used to recognize  this common special case.    Restriction:  This interface is not intended to be implemented by clients.    "
36,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/IOpenable.html,Common protocol for Java elements that must be opened before they can be  navigated or modified. Opening a textual element (such as a compilation unit)  involves opening a buffer on its contents. While open_ any changes to the buffer  can be reflected in the element's structure;  see isConsistent() and makeConsistent(IProgressMonitor).    To reduce complexity in clients_ elements are automatically opened  by the Java model as element properties are accessed. The Java model maintains  an LRU cache of open elements_ and automatically closes elements as they  are swapped out of the cache to make room for other elements. Elements with  unsaved changes are never removed from the cache_ and thus_ if the client  maintains many open elements with unsaved  changes_ the LRU cache can grow in size (in this case the cache is not  bounded). However_ as elements are saved_ the cache will shrink back to its  original bounded size.      To open an element_ all openable parent elements must be open.  The Java model automatically opens parent elements_ as it automatically opens elements.  Opening an element may provide access to direct children and other descendants_  but does not automatically open any descendents which are themselves IOpenable.  For example_ opening a compilation unit provides access to all its constituent elements_  but opening a package fragment does not open all compilation units in the package fragment.    Restriction:  This interface is not intended to be implemented by clients.    
37,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/IParent.html,Common protocol for Java elements that contain other Java elements.  Restriction:  This interface is not intended to be implemented by clients.    
38,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/IJavaProject.html,"extends IAdaptable Common protocol for all elements provided by the Java model.  Java model elements are exposed to clients as handles to the actual underlying element.  The Java model may hand out any number of handles for each element. Handles  that refer to the same element are guaranteed to be equal_ but not necessarily identical.    Methods annotated as ""handle-only"" do not require underlying elements to exist.  Methods that require underlying elements to exist throw  a JavaModelException when an underlying element is missing.  JavaModelException.isDoesNotExist can be used to recognize  this common special case.    Restriction:  This interface is not intended to be implemented by clients.     Common protocol for Java elements that must be opened before they can be  navigated or modified. Opening a textual element (such as a compilation unit)  involves opening a buffer on its contents. While open_ any changes to the buffer  can be reflected in the element's structure;  see isConsistent() and makeConsistent(IProgressMonitor).    To reduce complexity in clients_ elements are automatically opened  by the Java model as element properties are accessed. The Java model maintains  an LRU cache of open elements_ and automatically closes elements as they  are swapped out of the cache to make room for other elements. Elements with  unsaved changes are never removed from the cache_ and thus_ if the client  maintains many open elements with unsaved  changes_ the LRU cache can grow in size (in this case the cache is not  bounded). However_ as elements are saved_ the cache will shrink back to its  original bounded size.      To open an element_ all openable parent elements must be open.  The Java model automatically opens parent elements_ as it automatically opens elements.  Opening an element may provide access to direct children and other descendants_  but does not automatically open any descendents which are themselves IOpenable.  For example_ opening a compilation unit provides access to all its constituent elements_  but opening a package fragment does not open all compilation units in the package fragment.    Restriction:  This interface is not intended to be implemented by clients.    Common protocol for Java elements that contain other Java elements.  Restriction:  This interface is not intended to be implemented by clients.    extends IParent_ IJavaElement_ IOpenable A Java project represents a view of a project resource in terms of Java  elements such as package fragments_ types_ methods and fields.  A project may contain several package roots_ which contain package fragments.  A package root corresponds to an underlying folder or JAR.    Each Java project has a classpath_ defining which folders contain source code and  where required libraries are located. Each Java project also has an output location_  defining where the builder writes .class files. A project that  references packages in another project can access the packages by including  the required project in a classpath entry. The Java model will present the  source elements in the required project; when building_ the compiler will use  the corresponding generated class files from the required project's output  location(s)). The classpath format is a sequence of classpath entries  describing the location and contents of package fragment roots.    Java project elements need to be opened before they can be navigated or manipulated.  The children of a Java project are the package fragment roots that are  defined by the classpath and contained in this project (in other words_ it  does not include package fragment roots for other projects). The children  (i.e. the package fragment roots) appear in the order they are defined by   the classpath.      An instance of one of these handles can be created via  JavaCore.create(project).    See Also:  JavaCore.create(org.eclipse.core.resources.IProject)_  IClasspathEntry  Restriction:  This interface is not intended to be implemented by clients.    "
39,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/IClasspathEntry.html,"An entry on a Java project classpath identifying one or more package fragment  roots. A classpath entry has a content kind (either source_  IPackageFragmentRoot.K_SOURCE_ or binary_ IPackageFragmentRoot.K_BINARY)_ which is inherited  by each package fragment root and package fragment associated with the entry.    A classpath entry can refer to any of the following:  Source code in the current project. In this case_ the entry identifies a  root folder in the current project containing package fragments and  source files with one of the Java-like extensions. The root folder itself represents a default  package_ subfolders represent package fragments_ and files with a  Java-like extension (e.g. .java files)  represent compilation units. All compilation units will be compiled when  the project is built. The classpath entry must specify the  absolute path to the root folder. Entries of this kind are  associated with the CPE_SOURCE constant.  Source classpath entries can carry inclusion and exclusion patterns for  selecting which source files appear as compilation  units and get compiled when the project is built.    A binary library in the current project_ in another project_ or in the external  file system. In this case the entry identifies a JAR (or root folder) containing  package fragments and .class files. The classpath entry  must specify the absolute path to the JAR (or root folder)_ and in case it refers  to an external JAR_ then there is no associated resource in the workbench. Entries  of this kind are associated with the CPE_LIBRARY constant.  A required project. In this case the entry identifies another project in  the workspace. The required project is used as a binary library when compiling  (that is_ the builder looks in the output location of the required project  for required .class files when building). When performing other  ""development"" operations - such as code assist_ code resolve_ type hierarchy  creation_ etc. - the source code of the project is referred to. Thus_ development  is performed against a required project's source code_ and compilation is  performed against a required project's last built state. The  classpath entry must specify the absolute path to the  project. Entries of this kind are associated with the CPE_PROJECT  constant.  Note: referencing a required project with a classpath entry refers to the source  code or associated .class files located in its output location.  It will also automatically include any other libraries or projects that the required project's classpath  refers to_ iff the corresponding classpath entries are tagged as being exported  (isExported()).  Unless exporting some classpath entries_ classpaths are not chained by default -  each project must specify its own classpath in its entirety.  A path beginning in a classpath variable defined globally to the workspace.  Entries of this kind are associated with the CPE_VARIABLE constant.  Classpath variables are created using JavaCore.setClasspathVariable(String_ IPath_ org.eclipse.core.runtime.IProgressMonitor)_  and gets resolved_ to either a project or library entry_ using  JavaCore.getResolvedClasspathEntry(IClasspathEntry).  It is also possible to register an automatic initializer (ClasspathVariableInitializer)_  which will be invoked through the extension point ""org.eclipse.jdt.core.classpathVariableInitializer"".  After resolution_ a classpath variable entry may either correspond to a project or a library entry.   A named classpath container identified by its container path.  A classpath container provides a way to indirectly reference a set of classpath entries through  a classpath entry of kind CPE_CONTAINER. Typically_ a classpath container can  be used to describe a complex library composed of multiple JARs_ projects or classpath variables_  considering also that containers can be mapped differently on each project. Several projects can  reference the same generic container path_ but have each of them actually bound to a different  container object.  The container path is a formed by a first ID segment followed with extra segments_  which can be used as additional hints for resolving this container reference. If no container was ever  recorded for this container path onto this project (using JavaCore.setClasspathContainer(org.eclipse.core.runtime.IPath_ org.eclipse.jdt.core.IJavaProject[]_ org.eclipse.jdt.core.IClasspathContainer[]_ org.eclipse.core.runtime.IProgressMonitor)_  then a ClasspathContainerInitializer will be activated if any was registered for this  container ID onto the extension point ""org.eclipse.jdt.core.classpathContainerInitializer"".  A classpath container entry can be resolved explicitly using JavaCore.getClasspathContainer(org.eclipse.core.runtime.IPath_ org.eclipse.jdt.core.IJavaProject)  and the resulting container entries can contain any non-container entry. In particular_ it may contain variable  entries_ which in turn needs to be resolved before being directly used.    Also note that the container resolution APIs include an IJavaProject argument_ so as to allow the same  container path to be interpreted in different ways for different projects.     The result of IJavaProject.getResolvedClasspath(boolean) will have all entries of type  CPE_VARIABLE and CPE_CONTAINER resolved to a set of  CPE_SOURCE_ CPE_LIBRARY or CPE_PROJECT  classpath entries.    Any classpath entry other than a source folder (kind CPE_SOURCE) can  be marked as being exported. Exported entries are automatically contributed to  dependent projects_ along with the project's default output folder_ which is  implicitly exported_ and any auxiliary output folders specified on source  classpath entries. The project's output folder(s) are always listed first_  followed by the any exported entries.    Classpath entries can be created via methods on JavaCore.    See Also:  JavaCore.newLibraryEntry(org.eclipse.core.runtime.IPath_ org.eclipse.core.runtime.IPath_ org.eclipse.core.runtime.IPath)_  JavaCore.newProjectEntry(org.eclipse.core.runtime.IPath)_  JavaCore.newSourceEntry(org.eclipse.core.runtime.IPath)_  JavaCore.newVariableEntry(org.eclipse.core.runtime.IPath_ org.eclipse.core.runtime.IPath_ org.eclipse.core.runtime.IPath)_  JavaCore.newContainerEntry(org.eclipse.core.runtime.IPath)_  ClasspathVariableInitializer_  ClasspathContainerInitializer  Restriction:  This interface is not intended to be implemented by clients.    "
40,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdaptable.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject    "
41,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResource.html,extends IAdaptable_ ISchedulingRule The workspace analog of file system files  and directories. There are exactly four types of resource:  files_ folders_ projects and the workspace root.    File resources are similar to files in that they  hold data directly. Folder resources are analogous to directories in that they  hold other resources but cannot directly hold data. Project resources  group files and folders into reusable clusters. The workspace root is the  top level resource under which all others reside.      Features of resources:    IResource objects are handles to state maintained  by a workspace. That is_ resource objects do not actually contain data  themselves but rather represent resource state and give it behavior. Programmers  are free to manipulate handles for resources that do not exist in a workspace   but must keep in mind that some methods and operations require that an actual   resource be available.  Resources have two different kinds of properties as detailed below. All   properties are keyed by qualified names.  Session properties: Session properties live for the lifetime of one execution of  the workspace. They are not stored on disk. They can carry arbitrary  object values. Clients should be aware that these values are kept in memory  at all times and_ as such_ the values should not be large.  Persistent properties: Persistent properties have string values which are stored  on disk across platform sessions. The value of a persistent property is a   string which should be short (i.e._ under 2KB).     Resources are identified by type and by their path_ which is similar to a file system   path. The name of a resource is the last segment of its path. A resource's parent   is located by removing the last segment (the resource's name) from the resource's full path.  Resources can be local or non-local. A non-local resource is one whose  contents and properties have not been fetched from a repository.  Phantom resources represent incoming additions or outgoing deletions  which have yet to be reconciled with a synchronization partner.       Resources implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IWorkspace_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    
42,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/ISchedulingRule.html,Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)    
43,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IContainer.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject     extends IAdaptable_ ISchedulingRule The workspace analog of file system files  and directories. There are exactly four types of resource:  files_ folders_ projects and the workspace root.    File resources are similar to files in that they  hold data directly. Folder resources are analogous to directories in that they  hold other resources but cannot directly hold data. Project resources  group files and folders into reusable clusters. The workspace root is the  top level resource under which all others reside.      Features of resources:    IResource objects are handles to state maintained  by a workspace. That is_ resource objects do not actually contain data  themselves but rather represent resource state and give it behavior. Programmers  are free to manipulate handles for resources that do not exist in a workspace   but must keep in mind that some methods and operations require that an actual   resource be available.  Resources have two different kinds of properties as detailed below. All   properties are keyed by qualified names.  Session properties: Session properties live for the lifetime of one execution of  the workspace. They are not stored on disk. They can carry arbitrary  object values. Clients should be aware that these values are kept in memory  at all times and_ as such_ the values should not be large.  Persistent properties: Persistent properties have string values which are stored  on disk across platform sessions. The value of a persistent property is a   string which should be short (i.e._ under 2KB).     Resources are identified by type and by their path_ which is similar to a file system   path. The name of a resource is the last segment of its path. A resource's parent   is located by removing the last segment (the resource's name) from the resource's full path.  Resources can be local or non-local. A non-local resource is one whose  contents and properties have not been fetched from a repository.  Phantom resources represent incoming additions or outgoing deletions  which have yet to be reconciled with a synchronization partner.       Resources implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IWorkspace_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.     Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)     extends IResource_ IAdaptable Interface for resources which may contain  other resources (termed its members). While the   workspace itself is not considered a container in this sense_ the  workspace root resource is a container.    Containers implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()_  IProject_  IFolder_  IWorkspaceRoot  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
44,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IProject.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject     An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject     extends IAdaptable_ ISchedulingRule The workspace analog of file system files  and directories. There are exactly four types of resource:  files_ folders_ projects and the workspace root.    File resources are similar to files in that they  hold data directly. Folder resources are analogous to directories in that they  hold other resources but cannot directly hold data. Project resources  group files and folders into reusable clusters. The workspace root is the  top level resource under which all others reside.      Features of resources:    IResource objects are handles to state maintained  by a workspace. That is_ resource objects do not actually contain data  themselves but rather represent resource state and give it behavior. Programmers  are free to manipulate handles for resources that do not exist in a workspace   but must keep in mind that some methods and operations require that an actual   resource be available.  Resources have two different kinds of properties as detailed below. All   properties are keyed by qualified names.  Session properties: Session properties live for the lifetime of one execution of  the workspace. They are not stored on disk. They can carry arbitrary  object values. Clients should be aware that these values are kept in memory  at all times and_ as such_ the values should not be large.  Persistent properties: Persistent properties have string values which are stored  on disk across platform sessions. The value of a persistent property is a   string which should be short (i.e._ under 2KB).     Resources are identified by type and by their path_ which is similar to a file system   path. The name of a resource is the last segment of its path. A resource's parent   is located by removing the last segment (the resource's name) from the resource's full path.  Resources can be local or non-local. A non-local resource is one whose  contents and properties have not been fetched from a repository.  Phantom resources represent incoming additions or outgoing deletions  which have yet to be reconciled with a synchronization partner.       Resources implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IWorkspace_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.     Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)     extends IResource_ IAdaptable Interface for resources which may contain  other resources (termed its members). While the   workspace itself is not considered a container in this sense_ the  workspace root resource is a container.    Containers implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()_  IProject_  IFolder_  IWorkspaceRoot  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.     extends IAdaptable_ ISchedulingRule The workspace analog of file system files  and directories. There are exactly four types of resource:  files_ folders_ projects and the workspace root.    File resources are similar to files in that they  hold data directly. Folder resources are analogous to directories in that they  hold other resources but cannot directly hold data. Project resources  group files and folders into reusable clusters. The workspace root is the  top level resource under which all others reside.      Features of resources:    IResource objects are handles to state maintained  by a workspace. That is_ resource objects do not actually contain data  themselves but rather represent resource state and give it behavior. Programmers  are free to manipulate handles for resources that do not exist in a workspace   but must keep in mind that some methods and operations require that an actual   resource be available.  Resources have two different kinds of properties as detailed below. All   properties are keyed by qualified names.  Session properties: Session properties live for the lifetime of one execution of  the workspace. They are not stored on disk. They can carry arbitrary  object values. Clients should be aware that these values are kept in memory  at all times and_ as such_ the values should not be large.  Persistent properties: Persistent properties have string values which are stored  on disk across platform sessions. The value of a persistent property is a   string which should be short (i.e._ under 2KB).     Resources are identified by type and by their path_ which is similar to a file system   path. The name of a resource is the last segment of its path. A resource's parent   is located by removing the last segment (the resource's name) from the resource's full path.  Resources can be local or non-local. A non-local resource is one whose  contents and properties have not been fetched from a repository.  Phantom resources represent incoming additions or outgoing deletions  which have yet to be reconciled with a synchronization partner.       Resources implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IWorkspace_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.     Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)     extends IContainer_ IAdaptable A project is a type of resource which groups resources  into buildable_ reusable units.     Features of projects include:    A project collects together a set of files and folders.  A project's location controls where the project's resources are   stored in the local file system.  A project's build spec controls how building is done on the project.  A project can carry session and persistent properties.  A project can be open or closed; a closed project is  passive and has a minimal in-memory footprint.  A project can have one or more project build configurations.  A project can carry references to other project build configurations.  A project can have one or more project natures.      Projects implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
45,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IMarker.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject     extends IAdaptable Markers are a general mechanism for associating notes and meta-data with  resources.    Markers themselves are handles in the same way as IResources  are handles. Instances of IMarker do not hold the attributes  themselves but rather uniquely refer to the attribute container. As such_  their state may change underneath the handle with no warning to the holder  of the handle.    The Resources plug-in provides a general framework for   defining and manipulating markers and provides several standard marker types.      Each marker has:  a type string_ specifying its type (e.g.   ""org.eclipse.core.resources.taskmarker"")_   an identifier which is unique (relative to a particular resource)  Specific types of markers may carry additional information.      The resources plug-in defines five standard types:    org.eclipse.core.resources.marker  org.eclipse.core.resources.taskmarker  org.eclipse.core.resources.problemmarker  org.eclipse.core.resources.bookmark  org.eclipse.core.resources.textmarker  The plug-in also provides an extension point (  org.eclipse.core.resources.markers) into which other  plug-ins can install marker type declaration extensions.      Marker types are declared within a multiple inheritance type system.  New markers are defined in the plugin.xml file of the  declaring plug-in. A valid declaration contains elements as defined by  the extension point DTD:    type - the unique name of the marker type  super - the list of marker types of which this marker is to be considered a sub-type  attributes - the list of standard attributes which may be present on this type of marker  persistent - whether markers of this type should be persisted by the platform All markers declared as persistent are saved when the  workspace is saved_ except those explicitly set as transient (the  TRANSIENT attribute is set as true). A plug-in  which defines a persistent marker is not directly involved in saving and  restoring the marker. Markers are not under version and configuration  management_ and cannot be shared via VCM repositories.      Markers implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
46,http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/compiler/BuildContext.html,extends Object The context of a build event that is notified to interested compilation  participants when a build is starting_  or to annotations processors when a source file has annotations.  Since:  3.2  Restriction:  This class is not intended to be subclassed by clients.  Restriction:  This class is not intended to be instantiated by clients.    
47,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IEncodedStorage.html,extends IStorage A storage that knows how its contents are encoded.    The IEncodedStorage interface extends IStorage  in order to provide access to the charset to be used when decoding its   contents.     Clients may implement this interface.    Since:  3.0    
48,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IStorage.html,extends IAdaptable A storage object represents a set of bytes which can be accessed.  These may be in the form of an IFile or IFileState  or any other object supplied by user code. The main role of an IStorage  is to provide a uniform API for access to_ and presentation of_ its content.    Storage objects implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    Clients may implement this interface.        
49,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IFile.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject     extends IStorage A storage that knows how its contents are encoded.    The IEncodedStorage interface extends IStorage  in order to provide access to the charset to be used when decoding its   contents.     Clients may implement this interface.    Since:  3.0     extends IAdaptable_ ISchedulingRule The workspace analog of file system files  and directories. There are exactly four types of resource:  files_ folders_ projects and the workspace root.    File resources are similar to files in that they  hold data directly. Folder resources are analogous to directories in that they  hold other resources but cannot directly hold data. Project resources  group files and folders into reusable clusters. The workspace root is the  top level resource under which all others reside.      Features of resources:    IResource objects are handles to state maintained  by a workspace. That is_ resource objects do not actually contain data  themselves but rather represent resource state and give it behavior. Programmers  are free to manipulate handles for resources that do not exist in a workspace   but must keep in mind that some methods and operations require that an actual   resource be available.  Resources have two different kinds of properties as detailed below. All   properties are keyed by qualified names.  Session properties: Session properties live for the lifetime of one execution of  the workspace. They are not stored on disk. They can carry arbitrary  object values. Clients should be aware that these values are kept in memory  at all times and_ as such_ the values should not be large.  Persistent properties: Persistent properties have string values which are stored  on disk across platform sessions. The value of a persistent property is a   string which should be short (i.e._ under 2KB).     Resources are identified by type and by their path_ which is similar to a file system   path. The name of a resource is the last segment of its path. A resource's parent   is located by removing the last segment (the resource's name) from the resource's full path.  Resources can be local or non-local. A non-local resource is one whose  contents and properties have not been fetched from a repository.  Phantom resources represent incoming additions or outgoing deletions  which have yet to be reconciled with a synchronization partner.       Resources implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IWorkspace_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.     Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)     extends IAdaptable A storage object represents a set of bytes which can be accessed.  These may be in the form of an IFile or IFileState  or any other object supplied by user code. The main role of an IStorage  is to provide a uniform API for access to_ and presentation of_ its content.    Storage objects implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    Clients may implement this interface.         extends IResource_ IEncodedStorage_ IAdaptable Files are leaf resources which contain data.  The contents of a file resource is stored as a file in the local  file system.    Files_ like folders_ may exist in the workspace but  not be local; non-local file resources serve as place-holders for  files whose content and properties have not yet been fetched from  a repository.      Files implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
50,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/Path.html,"extends Object implements IPath_ Cloneable The standard implementation of the IPath interface.  Paths are always maintained in canonicalized form. That is_ parent  references (i.e._ ../../) and duplicate separators are   resolved. For example_  new Path(""/a/b"").append(""../foo/bar"")  will yield the path  /a/foo/bar    This class can be used without OSGi running.    This class is not intended to be subclassed by clients but  may be instantiated.    See Also:  IPath  Restriction:  This class is not intended to be subclassed by clients.    "
51,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IAction.html,An action represents the non-UI side of a command which can be triggered  by the end user. Actions are typically associated with buttons_ menu items_  and items in tool bars. The controls for a command are built by some container_  which furnished the context where these controls appear and configures   them with data from properties declared by the action. When the end user  triggers the command via its control_ the action's run  method is invoked to do the real work.    Actions support a predefined set of properties (and possibly others as well).  Clients of an action may register property change listeners so that they get   notified whenever the value of a property changes.      Clients should subclass the abstract base class Action to define   concrete actions rather than implementing IAction from scratch.      This interface exists only to define the API for actions.  It is not intended to be implemented by clients.    See Also:  Action  Restriction:  This interface is not intended to be implemented by clients.    
52,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPart.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject     extends IAdaptable A workbench part is a visual component within a workbench page. There  are two subtypes: view and editor_ as defined by IViewPart and  IEditorPart.     A view is typically used to navigate a hierarchy of information (like the   workspace)_ open an editor_ or display properties for the active editor.   Modifications made in a view are saved immediately.     An editor is typically used to edit or browse a document or input object.   The input is identified using an IEditorInput. Modifications made   in an editor part follow an open-save-close lifecycle model.    This interface may be implemented directly. For convenience_ a base  implementation is defined in WorkbenchPart.    The lifecycle of a workbench part is as follows:    When a part extension is created:  instantiate the part  create a part site  call part.init(site)    When a part becomes visible in the workbench:  add part to presentation by calling   part.createPartControl(parent) to create actual widgets  fire partOpened event to all listeners    When a part is activated or gets focus:  call part.setFocus()  fire partActivated event to all listeners    When a part is closed:  if save is needed_ do save; if it fails or is canceled return  if part is active_ deactivate part  fire partClosed event to all listeners  remove part from presentation; part controls are disposed as part  of the SWT widget tree    call part.dispose()        After createPartControl has been called_ the implementor may   safely reference the controls created. When the part is closed   these controls will be disposed as part of an SWT composite. This  occurs before the IWorkbenchPart.dispose method is called.  If there is a need to free SWT resources the part should define a dispose   listener for its own control and free those resources from the dispose  listener. If the part invokes any method on the disposed SWT controls   after this point an SWTError will be thrown.       The last method called on IWorkbenchPart is dispose.   This signals the end of the part lifecycle.      An important point to note about this lifecycle is that following   a call to init_ createPartControl may never be called. Thus in the dispose  method_ implementors must not assume controls were created.      Workbench parts implement the IAdaptable interface; extensions  are managed by the platform's adapter manager.    See Also:  IViewPart_  IEditorPart    "
53,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ISelection.html,Interface for a selection.  See Also:  ISelectionProvider_  ISelectionChangedListener_  SelectionChangedEvent    
54,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IProgressMonitor.html,The IProgressMonitor interface is implemented  by objects that monitor the progress of an activity; the methods  in this interface are invoked by code that performs the activity.    All activity is broken down into a linear sequence of tasks against  which progress is reported. When a task begins_ a beginTask(String_ int)  notification is reported_ followed by any number and mixture of   progress reports (worked()) and subtask notifications   (subTask(String)). When the task is eventually completed_ a   done() notification is reported. After the done()  notification_ the progress monitor cannot be reused; i.e._   beginTask(String_ int) cannot be called again after the call to   done().      A request to cancel an operation can be signaled using the   setCanceled method. Operations taking a progress  monitor are expected to poll the monitor (using isCanceled)  periodically and abort at their earliest convenience. Operation can however   choose to ignore cancelation requests.      Since notification is synchronous with the activity itself_ the listener should   provide a fast and robust implementation. If the handling of notifications would   involve blocking operations_ or operations which might throw uncaught exceptions_   the notifications should be queued_ and the actual processing deferred (or perhaps  delegated to a separate thread).    This interface can be used without OSGi running.    Clients may implement this interface.      
55,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceDelta.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject     extends IAdaptable A resource delta represents changes in the state of a resource tree  between two discrete points in time.    Resource deltas implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IResource_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
56,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IPath.html,"extends Cloneable A path is an ordered collection of string segments_  separated by a standard separator character_ ""/"".  A path may also have a leading and/or a trailing separator.  Paths may also be prefixed by an optional device id_ which includes  the character(s) which separate the device id from the rest   of the path. For example_ ""C:"" and ""Server/Volume:"" are typical  device ids.  A device independent path has null for a device id.    Note that paths are value objects; all operations on paths   return a new path; the path that is operated on is unscathed.      UNC paths are denoted by leading double-slashes such   as //Server/Volume/My/Path. When a new path  is constructed all double-slashes are removed except those  appearing at the beginning of the path.      This interface can be used without OSGi running.    This interface is not intended to be implemented by clients.    See Also:  Path  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
57,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspaceRoot.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject     An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject     extends IAdaptable_ ISchedulingRule The workspace analog of file system files  and directories. There are exactly four types of resource:  files_ folders_ projects and the workspace root.    File resources are similar to files in that they  hold data directly. Folder resources are analogous to directories in that they  hold other resources but cannot directly hold data. Project resources  group files and folders into reusable clusters. The workspace root is the  top level resource under which all others reside.      Features of resources:    IResource objects are handles to state maintained  by a workspace. That is_ resource objects do not actually contain data  themselves but rather represent resource state and give it behavior. Programmers  are free to manipulate handles for resources that do not exist in a workspace   but must keep in mind that some methods and operations require that an actual   resource be available.  Resources have two different kinds of properties as detailed below. All   properties are keyed by qualified names.  Session properties: Session properties live for the lifetime of one execution of  the workspace. They are not stored on disk. They can carry arbitrary  object values. Clients should be aware that these values are kept in memory  at all times and_ as such_ the values should not be large.  Persistent properties: Persistent properties have string values which are stored  on disk across platform sessions. The value of a persistent property is a   string which should be short (i.e._ under 2KB).     Resources are identified by type and by their path_ which is similar to a file system   path. The name of a resource is the last segment of its path. A resource's parent   is located by removing the last segment (the resource's name) from the resource's full path.  Resources can be local or non-local. A non-local resource is one whose  contents and properties have not been fetched from a repository.  Phantom resources represent incoming additions or outgoing deletions  which have yet to be reconciled with a synchronization partner.       Resources implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IWorkspace_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.     Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)     extends IResource_ IAdaptable Interface for resources which may contain  other resources (termed its members). While the   workspace itself is not considered a container in this sense_ the  workspace root resource is a container.    Containers implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()_  IProject_  IFolder_  IWorkspaceRoot  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.     extends IAdaptable_ ISchedulingRule The workspace analog of file system files  and directories. There are exactly four types of resource:  files_ folders_ projects and the workspace root.    File resources are similar to files in that they  hold data directly. Folder resources are analogous to directories in that they  hold other resources but cannot directly hold data. Project resources  group files and folders into reusable clusters. The workspace root is the  top level resource under which all others reside.      Features of resources:    IResource objects are handles to state maintained  by a workspace. That is_ resource objects do not actually contain data  themselves but rather represent resource state and give it behavior. Programmers  are free to manipulate handles for resources that do not exist in a workspace   but must keep in mind that some methods and operations require that an actual   resource be available.  Resources have two different kinds of properties as detailed below. All   properties are keyed by qualified names.  Session properties: Session properties live for the lifetime of one execution of  the workspace. They are not stored on disk. They can carry arbitrary  object values. Clients should be aware that these values are kept in memory  at all times and_ as such_ the values should not be large.  Persistent properties: Persistent properties have string values which are stored  on disk across platform sessions. The value of a persistent property is a   string which should be short (i.e._ under 2KB).     Resources are identified by type and by their path_ which is similar to a file system   path. The name of a resource is the last segment of its path. A resource's parent   is located by removing the last segment (the resource's name) from the resource's full path.  Resources can be local or non-local. A non-local resource is one whose  contents and properties have not been fetched from a repository.  Phantom resources represent incoming additions or outgoing deletions  which have yet to be reconciled with a synchronization partner.       Resources implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  IWorkspace_  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.     Scheduling rules are used by jobs to indicate when they need exclusive access  to a resource. Scheduling rules can also be applied synchronously to a thread  using IJobManager.beginRule(ISchedulingRule) and   IJobManager.endRule(ISchedulingRule). The job manager guarantees that   no two jobs with conflicting scheduling rules will run concurrently.   Multiple rules can be applied to a given thread only if the outer rule explicitly   allows the nesting as specified by the contains method.     Clients may implement this interface.  Since:  3.0  See Also:  Job.getRule()_  Job.setRule(ISchedulingRule)_  Job.schedule(long)_  IJobManager.beginRule(ISchedulingRule_ org.eclipse.core.runtime.IProgressMonitor)_  IJobManager.endRule(ISchedulingRule)     extends IContainer_ IAdaptable A root resource represents the top of the resource hierarchy in a workspace.  There is exactly one root in a workspace. The root resource has the following  behavior:   It cannot be moved or copied   It always exists.  Deleting the root deletes all of the children under the root but leaves the root itself  It is always local.  It is never a phantom.    Workspace roots implement the IAdaptable interface;  extensions are managed by the platform's adapter manager.    See Also:  Platform.getAdapterManager()  Restriction:  This interface is not intended to be implemented by clients.  Restriction:  This interface is not intended to be extended by clients.    "
58,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Device.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Object implements Drawable This class is the abstract superclass of all device objects_  such as the Display device and the Printer device. Devices  can have a graphics context (GC) created for them_ and they  can be drawn on by sending messages to the associated GC.  See Also:  Sample code and further information    "
59,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Transform.html,extends Resource Instances of this class represent transformation matrices for   points expressed as (x_ y) pairs of floating point numbers.    Application code must explicitly invoke the Transform.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.      This class requires the operating system's advanced graphics subsystem  which may not be available on some platforms.    Since:  3.1  See Also:  SWT Example: GraphicsExample_  Sample code and further information    
60,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Path.html,extends Resource Instances of this class represent paths through the two-dimensional  coordinate system. Paths do not have to be continuous_ and can be  described using lines_ rectangles_ arcs_ cubic or quadratic bezier curves_  glyphs_ or other paths.    Application code must explicitly invoke the Path.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.      This class requires the operating system's advanced graphics subsystem  which may not be available on some platforms.    Since:  3.1  See Also:  Path_ Pattern snippets_  SWT Example: GraphicsExample_  Sample code and further information    
61,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ToolItem.html,extends Item Instances of this class represent a selectable user interface object  that represents a button in a tool bar.  Styles:  PUSH_ CHECK_ RADIO_ SEPARATOR_ DROP_DOWN  Events:  Selection    Note: Only one of the styles CHECK_ PUSH_ RADIO_ SEPARATOR and DROP_DOWN   may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  ToolBar_ ToolItem snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
62,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ToolBar.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Composite Instances of this class support the layout of selectable  tool bar items.    The item children that may be added to instances of this class  must be of type ToolItem.    Note that although this class is a subclass of Composite_  it does not make sense to add Control children to it_  or set a layout on it.      Styles:  FLAT_ WRAP_ RIGHT_ HORIZONTAL_ VERTICAL_ SHADOW_OUT  Events:  (none)    Note: Only one of the styles HORIZONTAL and VERTICAL may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  ToolBar_ ToolItem snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
63,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Image.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Resource implements Drawable Instances of this class are graphics which have been prepared  for display on a specific device. That is_ they are ready  to paint using methods such as GC.drawImage()  and display on widgets with_ for example_ Button.setImage().    If loaded from a file format that supports it_ an  Image may have transparency_ meaning that certain  pixels are specified as being transparent when drawn. Examples  of file formats that support transparency are GIF and PNG.    There are two primary ways to use Images.   The first is to load a graphic file from disk and create an  Image from it. This is done using an Image  constructor_ for example:    Image i = new Image(device_ ""C:\\graphic.bmp"");    A graphic file may contain a color table specifying which  colors the image was intended to possess. In the above example_  these colors will be mapped to the closest available color in  SWT. It is possible to get more control over the mapping of  colors as the image is being created_ using code of the form:    ImageData data = new ImageData(""C:\\graphic.bmp"");   RGB[] rgbs = data.getRGBs();   // At this point_ rgbs contains specifications of all  // the colors contained within this image. You may  // allocate as many of these colors as you wish by  // using the Color constructor Color(RGB)_ then  // create the image:  Image i = new Image(device_ data);      Applications which require even greater control over the image  loading process should use the support provided in class  ImageLoader.    Application code must explicitly invoke the Image.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    See Also:  Color_  ImageData_  ImageLoader_  Image snippets_  SWT Examples: GraphicsExample_ ImageAnalyzer_  Sample code and further information    "
64,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Pattern.html,extends Resource Instances of this class represent patterns to use while drawing. Patterns  can be specified either as bitmaps or gradients.    Application code must explicitly invoke the Pattern.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.      This class requires the operating system's advanced graphics subsystem  which may not be available on some platforms.    Since:  3.1  See Also:  Path_ Pattern snippets_  SWT Example: GraphicsExample_  Sample code and further information    
65,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Color.html,extends Resource Instances of this class manage the operating system resources that  implement SWT's RGB color model. To create a color you can either  specify the individual color components as integers in the range   0 to 255 or provide an instance of an RGB.     Application code must explicitly invoke the Color.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    See Also:  RGB_  Device.getSystemColor(int)_  Color and RGB snippets_  SWT Example: PaintExample_  Sample code and further information    
66,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseEvent.html,extends TypedEvent Instances of this class are sent whenever mouse  related actions occur. This includes mouse buttons  being pressed and released_ the mouse pointer being   moved and the mouse pointer crossing widget boundaries.    Note: The button field is an integer that  represents the mouse button number. This is not the same  as the SWT mask constants BUTTONx.    See Also:  MouseListener_  MouseMoveListener_  MouseTrackListener_  Sample code and further information_  Serialized Form    
67,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/IServiceLocator.html, A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2    
68,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbench.html,"An interface for an adaptable object.    Adaptable objects can be dynamically extended to provide different   interfaces (or ""adapters""). Adapters are created by adapter   factories_ which are in turn managed by type by adapter managers.    For example_    IAdaptable a = [some adaptable];  IFoo x = (IFoo)a.getAdapter(IFoo.class);  if (x != null)  [do IFoo things with x]      This interface can be used without OSGi running.    Clients may implement this interface_ or obtain a default implementation  of this interface by subclassing PlatformObject.    See Also:  IAdapterFactory_  IAdapterManager_  PlatformObject      A component with which one or more services are registered. The services can  be retrieved from this locator using some key -- typically the class  representing the interface the service must implement. For example:        IHandlerService service = (IHandlerService) workbenchWindow  .getService(IHandlerService.class);        This interface is not to be implemented or extended by clients.    Since:  3.2     extends IAdaptable_ IServiceLocator A workbench is the root object for the Eclipse Platform user interface.    A workbench has one or more main windows which present to the end  user information based on some underlying model_ typically on resources in an  underlying workspace. A workbench usually starts with a single open window_  and automatically closes when its last window closes.      Each workbench window has a collection of pages; the active  page is the one that is being presented to the end user; at most one page is  active in a window at a time.      Each workbench page has a collection of workbench parts_ of which  there are two kinds: views and editors. A page's parts are arranged (tiled or  stacked) for presentation on the screen. The arrangement is not fixed; the  user can arrange the parts as they see fit. A perspective is a  template for a page_ capturing a collection of parts and their arrangement.      The platform creates a workbench when the workbench plug-in is activated;  since this happens at most once during the life of the running platform_  there is only one workbench instance. Due to its singular nature_ it is  commonly referred to as the workbench.      The workbench supports a few services by default. If  these services are used to allocate resources_ it is important to remember to  clean up those resources after you are done with them. Otherwise_ the  resources will exist until the workbench shuts down. The supported services  are:    IBindingService  ICommandService  IContextService  IHandlerService    This interface is not intended to be implemented by clients.    See Also:  PlatformUI.getWorkbench()  Restriction:  This interface is not intended to be implemented by clients.    "
69,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/opengl/GLCanvas.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Canvas GLCanvas is a widget capable of displaying OpenGL content.  Since:  3.2  See Also:  GLData_  OpenGL snippets_  Sample code and further information    "
70,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/SelectionEvent.html,extends TypedEvent Instances of this class are sent as a result of  widgets being selected.    Note: The fields that are filled in depend on the widget.    See Also:  SelectionListener_  Sample code and further information_  Serialized Form    
71,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Font.html,extends Resource Instances of this class manage operating system resources that  define how text looks when it is displayed. Fonts may be constructed  by providing a device and either name_ size and style information  or a FontData object which encapsulates this data.    Application code must explicitly invoke the Font.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    See Also:  FontData_  Font snippets_  SWT Examples: GraphicsExample_ PaintExample_  Sample code and further information    
72,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/SWTError.html,"extends Error This error is thrown whenever an unrecoverable error  occurs internally in SWT. The message text and error code   provide a further description of the problem. The exception  has a throwable field which holds the underlying  throwable that caused the problem (if this information is  available (i.e. it may be null)).    SWTErrors are thrown when something fails internally which  either leaves SWT in an unknown state (eg. the o/s call to  remove an item from a list returns an error code) or when SWT  is left in a known-to-be-unrecoverable state (eg. it runs out  of callback resources). SWTErrors should not occur in typical  programs_ although ""high reliability"" applications should  still catch them.    This class also provides support methods used by SWT to match  error codes to the appropriate exception class (SWTError_   SWTException_ or IllegalArgumentException) and to provide  human readable strings for SWT error codes.    See Also:  SWTException_  SWT.error(int)_  Sample code and further information_  Serialized Form    "
73,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Group.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Composite Instances of this class provide an etched border  with an optional title.    Shadow styles are hints and may not be honoured  by the platform. To create a group with the  default shadow style for the platform_ do not  specify a shadow style.    Styles:  SHADOW_ETCHED_IN_ SHADOW_ETCHED_OUT_ SHADOW_IN_ SHADOW_OUT_ SHADOW_NONE  Events:  (none)    Note: Only one of the above styles may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
74,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Button.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Control Instances of this class represent a selectable user interface object that  issues notification when pressed and released.   Styles:  ARROW_ CHECK_ PUSH_ RADIO_ TOGGLE_ FLAT_ WRAP  UP_ DOWN_ LEFT_ RIGHT_ CENTER  Events:  Selection    Note: Only one of the styles ARROW_ CHECK_ PUSH_ RADIO_ and TOGGLE   may be specified.    Note: Only one of the styles LEFT_ RIGHT_ and CENTER may be specified.    Note: Only one of the styles UP_ DOWN_ LEFT_ and RIGHT may be specified  when the ARROW style is specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Button snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
75,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Combo.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Composite Instances of this class are controls that allow the user  to choose an item from a list of items_ or optionally   enter a new value by typing it into an editable text  field. Often_ Combos are used in the same place  where a single selection List widget could  be used but space is limited. A Combo takes  less space than a List widget and shows  similar information.    Note: Since Combos can contain both a list  and an editable text field_ it is possible to confuse methods  which access one versus the other (compare for example_  clearSelection() and deselectAll()).  The API documentation is careful to indicate either ""the  receiver's list"" or the ""the receiver's text field"" to   distinguish between the two cases.    Note that although this class is a subclass of Composite_  it does not make sense to add children to it_ or set a layout on it.    Styles:  DROP_DOWN_ READ_ONLY_ SIMPLE  Events:  DefaultSelection_ Modify_ Selection_ Verify_ OrientationChange    Note: Only one of the styles DROP_DOWN and SIMPLE may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  List_  Combo snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
76,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/KeyEvent.html,extends TypedEvent Instances of this class are sent as a result of  keys being pressed and released on the keyboard.    When a key listener is added to a control_ the control  will take part in widget traversal. By default_ all  traversal keys (such as the tab key and so on) are  delivered to the control. In order for a control to take  part in traversal_ it should listen for traversal events.  Otherwise_ the user can traverse into a control but not  out. Note that native controls such as table and tree  implement key traversal in the operating system. It is  not necessary to add traversal listeners for these controls_  unless you want to override the default traversal.    See Also:  KeyListener_  TraverseListener_  Sample code and further information_  Serialized Form    
77,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleControlListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes that implement this interface provide methods  that deal with the events that are generated when an  accessibility client sends a message to a control.    After creating an instance of a class that implements  this interface it can be added to a control using the  addAccessibleControlListener method and removed  using the removeAccessibleControlListener method.  When a client requests information the appropriate method  will be invoked.    Note: Accessibility clients use child identifiers to specify  whether they want information about a control or one of its children.  Child identifiers are increasing integers beginning with 0.  The identifier CHILDID_SELF represents the control itself.    Note: This interface is typically used by implementors of  a custom control to provide very detailed information about  the control instance to accessibility clients.    Since:  2.0  See Also:  AccessibleControlAdapter_  AccessibleControlEvent    
78,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes that implement this interface provide methods  that deal with the events that are generated when an  accessibility client sends a message to a control.    After creating an instance of a class that implements  this interface it can be added to a control using the  addAccessibleListener method and removed  using the removeAccessibleListener method.  When a client requests information_ the appropriate method  will be invoked.    Note: Accessibility clients use child identifiers to specify  whether they want information about a control or one of its children.  Child identifiers are increasing integers beginning with 0.  The identifier CHILDID_SELF represents the control itself.    Since:  2.0  See Also:  AccessibleAdapter_  AccessibleEvent    
79,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleTextListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes that implement this interface provide methods  that deal with the events that are generated when an  accessibility client sends a message to a control.    After creating an instance of a class that implements  this interface it can be added to a control using the  addAccessibleTextListener method and removed  using the removeAccessibleTextListener method.  When a client requests information the appropriate method  will be invoked.    Note: Accessibility clients use child identifiers to specify  whether they want information about a control or one of its children.  Child identifiers are increasing integers beginning with 0.  The identifier CHILDID_SELF represents the control itself.    Note: This interface is typically used by implementors of  a custom control to provide very detailed information about  the control instance to accessibility clients.    Since:  3.0  See Also:  AccessibleTextAdapter_  AccessibleTextEvent    
80,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleControlEvent.html,extends org.eclipse.swt.internal.SWTEventObject Instances of this class are sent as a result of  accessibility clients sending messages to controls  asking for detailed information about the implementation  of the control instance. Typically_ only implementors  of custom controls need to listen for this event.    Note: The meaning of each field depends on the  message that was sent.    Since:  2.0  See Also:  AccessibleControlListener_  AccessibleControlAdapter_  Sample code and further information_  Serialized Form    
81,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleEvent.html,extends org.eclipse.swt.internal.SWTEventObject Instances of this class are sent as a result of  accessibility clients sending messages to controls  asking for information about the control instance.    Note: The meaning of the result field depends  on the message that was sent.    Since:  2.0  See Also:  AccessibleListener_  AccessibleAdapter_  Sample code and further information_  Serialized Form    
82,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleTextEvent.html,extends org.eclipse.swt.internal.SWTEventObject Instances of this class are sent as a result of  accessibility clients sending messages to controls  asking for detailed information about the implementation  of the control instance. Typically_ only implementors  of custom controls need to listen for this event.    Note: The meaning of each field depends on the  message that was sent.    Since:  3.0  See Also:  AccessibleTextListener_  AccessibleTextAdapter_  Sample code and further information_  Serialized Form    
83,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/WindowEvent.html,"extends TypedEvent A WindowEvent is sent by a Browser when  a new window needs to be created or when an existing window needs to be  closed. This notification occurs when a javascript command such as  window.open or window.close gets executed by  a Browser.    The following example shows how WindowEvent's are typically  handled.      public static void main(String[] args) {  Display display = new Display();  Shell shell = new Shell(display);  shell.setText(""Main Window"");  shell.setLayout(new FillLayout());  Browser browser = new Browser(shell_ SWT.NONE);  initialize(display_ browser);  shell.open();  browser.setUrl(""http://www.eclipse.org"");  while (!shell.isDisposed()) {  if (!display.readAndDispatch())  display.sleep();  }  display.dispose();  }  static void initialize(final Display display_ Browser browser) {  browser.addOpenWindowListener(new OpenWindowListener() {  public void open(WindowEvent event) {  // Certain platforms can provide a default full browser.  // simply return in that case if the application prefers  // the default full browser to the embedded one set below.  if (!event.required) return;  // Embed the new window  Shell shell = new Shell(display);  shell.setText(""New Window"");  shell.setLayout(new FillLayout());  Browser browser = new Browser(shell_ SWT.NONE);  initialize(display_ browser);  event.browser = browser;  }  });  browser.addVisibilityWindowListener(new VisibilityWindowListener() {  public void hide(WindowEvent event) {  Browser browser = (Browser)event.widget;  Shell shell = browser.getShell();  shell.setVisible(false);  }  public void show(WindowEvent event) {  Browser browser = (Browser)event.widget;  Shell shell = browser.getShell();  if (event.location != null) shell.setLocation(event.location);  if (event.size != null) {  Point size = event.size;  shell.setSize(shell.computeSize(size.x_ size.y));  }  if (event.addressBar || event.menuBar || event.statusBar || event.toolBar) {  // Create widgets for the address bar_ menu bar_ status bar and/or tool bar  // leave enough space in the Shell to accommodate a Browser of the size  // given by event.size  }  shell.open();  }  });  browser.addCloseWindowListener(new CloseWindowListener() {  public void close(WindowEvent event) {  Browser browser = (Browser)event.widget;  Shell shell = browser.getShell();  shell.close();  }  });  }      The following notifications are emitted when the user selects a hyperlink that targets a new window  or as the result of a javascript that executes window.open.     Main Browser    User selects a link that opens in a new window or javascript requests a new window  OpenWindowListener.open() notified  Application creates a new Shell and a second Browser inside that Shell  Application registers WindowListener's on that second Browser_ such as VisibilityWindowListener  Application returns the second Browser as the host for the new window content      Second Browser    VisibilityWindowListener.show() notified  Application sets navigation tool bar_ status bar_ menu bar and Shell size    Application makes the Shell hosting the second Browser visible    User now sees the new window        Since:  3.0  See Also:  CloseWindowListener_  OpenWindowListener_  VisibilityWindowListener_  Sample code and further information_  Serialized Form    "
84,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/LocationListener.html,extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive  a LocationEvent notification when a Browser  navigates to a different URL.  Since:  3.0  See Also:  Browser.addLocationListener(LocationListener)_  Browser.removeLocationListener(LocationListener)    
85,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/LocationAdapter.html,"extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive  a LocationEvent notification when a Browser  navigates to a different URL.  Since:  3.0  See Also:  Browser.addLocationListener(LocationListener)_  Browser.removeLocationListener(LocationListener)     extends Object implements LocationListener This adapter class provides default implementations for the  methods described by the LocationListener interface.    Classes that wish to deal with LocationEvent's can  extend this class and override only the methods which they are  interested in.    Since:  3.0  See Also:  Sample code and further information    "
86,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/LocationEvent.html,extends TypedEvent A LocationEvent is sent by a Browser to  LocationListener's when the Browser  navigates to a different URL. This notification typically   occurs when the application navigates to a new location with   Browser.setUrl(String) or when the user activates a  hyperlink.  Since:  3.0  See Also:  Sample code and further information_  Serialized Form    
87,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/ProgressEvent.html,extends TypedEvent A ProgressEvent is sent by a Browser to  ProgressListener's when a progress is made during the  loading of the current URL or when the loading of the current  URL has been completed.  Since:  3.0  See Also:  Sample code and further information_  Serialized Form    
88,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/StatusTextEvent.html,extends TypedEvent A StatusTextEvent is sent by a Browser to  StatusTextListener's when the status text is changed.  The status text is typically displayed in the status bar of  a browser application.  Since:  3.0  See Also:  Sample code and further information_  Serialized Form    
89,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/TitleEvent.html,extends TypedEvent A TitleEvent is sent by a Browser to  TitleListener's when the title of the current document  is available or when it is modified.  Since:  3.0  See Also:  Sample code and further information_  Serialized Form    
90,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/BidiSegmentListener.html,extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive  BidiSegmentEvents.  See Also:  BidiSegmentEvent    
91,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/StyleRange.html,extends TextStyle implements org.eclipse.swt.internal.CloneableCompatibility StyleRange defines a set of styles for a specified  range of text.    The hashCode() method in this class uses the values of the public  fields to compute the hash value. When storing instances of the  class in hashed collections_ do not modify these fields after the  object has been inserted.    See Also:  Sample code and further information    
92,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CTabItem.html,extends Item Instances of this class represent a selectable user interface object  that represent a page in a notebook widget.    Styles:  SWT.CLOSE  Events:  (none)    IMPORTANT: This class is not intended to be subclassed.    See Also:  CTabFolder_ CTabItem snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
93,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Text.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Scrollable Instances of this class are selectable user interface  objects that allow the user to enter and modify text.  Text controls can be either single or multi-line.  When a text control is created with a border_ the  operating system includes a platform specific inset  around the contents of the control. When created  without a border_ an effort is made to remove the  inset such that the preferred size of the control  is the same size as the contents.      Styles:  CENTER_ ICON_CANCEL_ ICON_SEARCH_ LEFT_ MULTI_ PASSWORD_ SEARCH_ SINGLE_ RIGHT_ READ_ONLY_ WRAP  Events:  DefaultSelection_ Modify_ Verify_ OrientationChange    Note: Only one of the styles MULTI and SINGLE may be specified_  and only one of the styles LEFT_ CENTER_ and RIGHT may be specified.      Note: The styles ICON_CANCEL and ICON_SEARCH are hints used in combination with SEARCH.  When the platform supports the hint_ the text control shows these icons. When an icon  is selected_ a default selection event is sent with the detail field set to one of  ICON_CANCEL or ICON_SEARCH. Normally_ application code does not need to check the  detail. In the case of ICON_CANCEL_ the text is cleared before the default selection  event is sent causing the application to search for an empty string.      IMPORTANT: This class is not intended to be subclassed.    See Also:  Text snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
94,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/ExtendedModifyListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the event that is generated when text  is modified.  See Also:  ExtendedModifyEvent_  Sample code and further information    
95,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/LineBackgroundListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that can provide the background color for a line that  is to be drawn.  See Also:  LineBackgroundEvent_  Sample code and further information    
96,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/LineStyleListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that can provide the style information for a line that  is to be drawn.  See Also:  LineStyleEvent_  Sample code and further information    
97,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/StyledText.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Canvas A StyledText is an editable user interface object that displays lines   of text. The following style attributes can be defined for the text:   foreground color     background color    font style (bold_ italic_ bold-italic_ regular)    underline    strikeout      In addition to text style attributes_ the background color of a line may   be specified.    There are two ways to use this widget when specifying text style information.   You may use the API that is defined for StyledText or you may define your own   LineStyleListener. If you define your own listener_ you will be responsible   for maintaining the text style information for the widget. IMPORTANT: You may   not define your own listener and use the StyledText API. The following  StyledText API is not supported if you have defined a LineStyleListener:    getStyleRangeAtOffset(int)    getStyleRanges()    replaceStyleRanges(int_int_StyleRange[])    setStyleRange(StyleRange)    setStyleRanges(StyleRange[])      There are two ways to use this widget when specifying line background colors.  You may use the API that is defined for StyledText or you may define your own   LineBackgroundListener. If you define your own listener_ you will be responsible   for maintaining the line background color information for the widget.   IMPORTANT: You may not define your own listener and use the StyledText API.   The following StyledText API is not supported if you have defined a   LineBackgroundListener:    getLineBackground(int)    setLineBackground(int_int_Color)      The content implementation for this widget may also be user-defined. To do so_  you must implement the StyledTextContent interface and use the StyledText API  setContent(StyledTextContent) to initialize the widget.       Styles:  FULL_SELECTION_ MULTI_ READ_ONLY_ SINGLE_ WRAP    Events:  ExtendedModify_ LineGetBackground_ LineGetSegments_ LineGetStyle_ Modify_ Selection_ Verify_ VerifyKey_ OrientationChange      IMPORTANT: This class is not intended to be subclassed.    See Also:  StyledText snippets_  SWT Examples: CustomControlExample_ TextEditor_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
98,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/ExtendedModifyEvent.html,extends TypedEvent This event is sent after a text change occurs.  See Also:  Sample code and further information_  Serialized Form    
99,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ModifyListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the events that are generated when text  is modified.    After creating an instance of a class that implements  this interface it can be added to a text widget using the  addModifyListener method and removed using  the removeModifyListener method. When the  text is modified_ the modifyText method will be invoked.    See Also:  ModifyEvent    
100,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/VerifyKeyListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the event that is generated when a  key is pressed.  See Also:  VerifyEvent_  Sample code and further information    
101,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/VerifyListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the events that are generated when text  is about to be modified.    After creating an instance of a class that implements  this interface it can be added to a text control using the  addVerifyListener method and removed using  the removeVerifyListener method. When the  text is about to be modified_ the verifyText method  will be invoked.    See Also:  VerifyEvent    
102,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/VerifyEvent.html,extends KeyEvent Instances of this class are sent as a result of  widgets handling keyboard events  See Also:  VerifyListener_  Sample code and further information_  Serialized Form    
103,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/Clipboard.html,extends Object The Clipboard provides a mechanism for transferring data from one  application to another or within an application.    IMPORTANT: This class is not intended to be subclassed.  See Also:  Clipboard snippets_  SWT Example: ClipboardExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
104,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/TextTransfer.html,"provides a platform specific mechanism   for converting plain text represented as a java String   to a platform specific representation of the data and vice versa.    An example of a java String containing plain text is shown   below:      String textData = ""Hello World"";      Note the TextTransfer does not change the content of the text  data. For a better integration with the platform_ the application should convert  the line delimiters used in the text data to the standard line delimiter used by the  platform.    See Also:  Transfer    "
105,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/StyledTextContent.html,Clients may implement the StyledTextContent interface to provide a   custom store for the StyledText widget content. The StyledText widget   interacts with its StyledTextContent in order to access and update   the text that is being displayed and edited in the widget.   A custom content implementation can be set in the widget using the  StyledText.setContent API.    
106,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TextChangeListener.html,extends org.eclipse.swt.internal.SWTEventListener The StyledText widget implements this listener to receive  notifications when changes to the model occur.  It is not intended to be implemented by clients or by   implementors of StyledTextContent.   Clients should listen to the ModifyEvent or ExtendedModifyEvent   that is sent by the StyledText widget to receive text change   notifications.  Implementors of StyledTextContent should call the textChanging  and textChanged methods when text changes occur as described   below. If the entire text is replaced the textSet method   should be called instead.    
107,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/printing/Printer.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Device Instances of this class are used to print to a printer.  Applications create a GC on a printer using new GC(printer)  and then draw on the printer GC using the usual graphics calls.    A Printer object may be constructed by providing  a PrinterData object which identifies the printer.  A PrintDialog presents a print dialog to the user  and returns an initialized instance of PrinterData.  Alternatively_ calling new Printer() will construct a  printer object for the user's default printer.    Application code must explicitly invoke the Printer.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    See Also:  PrinterData_  PrintDialog_  Printing snippets_  Sample code and further information    "
108,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Caret.html,extends Widget Instances of this class provide an i-beam that is typically used  as the insertion point for text.  Styles:  (none)  Events:  (none)    IMPORTANT: This class is not intended to be subclassed.    See Also:  Caret snippets_  SWT Example: ControlExample_ Canvas tab_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
109,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/FontData.html,extends Object Instances of this class describe operating system fonts.    For platform-independent behaviour_ use the get and set methods  corresponding to the following properties:    height  the height of the font in points  name  the face name of the font_ which may include the foundry  style  A bitwise combination of NORMAL_ ITALIC and BOLD  If extra_ platform-dependent functionality is required:  On Windows_ the data member of the FontData  corresponds to a Windows LOGFONT structure whose fields  may be retrieved and modified.  On X_ the fields of the FontData correspond  to the entries in the font's XLFD name and may be retrieved and modified.    Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.  See Also:  Font_  Sample code and further information    
110,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/RTFTransfer.html,"provides a platform specific mechanism   for converting text in RTF format represented as a java String   to a platform specific representation of the data and vice versa.    An example of a java String containing RTF text is shown   below:      String rtfData = ""{\\rtf1{\\colortbl;\\red255\\green0\\blue0;}\\uc1\\b\\i Hello World}"";    See Also:  Transfer    "
111,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TableColumn.html,extends Item Instances of this class represent a column in a table widget.    Styles:  LEFT_ RIGHT_ CENTER  Events:  Move_ Resize_ Selection    Note: Only one of the styles LEFT_ RIGHT and CENTER may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Table_ TableItem_ TableColumn snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
112,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/TypedEvent.html,extends org.eclipse.swt.internal.SWTEventObject This is the super class for all typed event classes provided  by SWT. Typed events contain particular information which is  applicable to the event occurrence.  See Also:  Event_  Sample code and further information_  Serialized Form    
113,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Cursor.html,extends Resource Instances of this class manage operating system resources that  specify the appearance of the on-screen pointer. To create a  cursor you specify the device and either a simple cursor style  describing one of the standard operating system provided cursors  or the image and mask data for the desired appearance.    Application code must explicitly invoke the Cursor.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    Styles:    CURSOR_ARROW_ CURSOR_WAIT_ CURSOR_CROSS_ CURSOR_APPSTARTING_ CURSOR_HELP_  CURSOR_SIZEALL_ CURSOR_SIZENESW_ CURSOR_SIZENS_ CURSOR_SIZENWSE_ CURSOR_SIZEWE_  CURSOR_SIZEN_ CURSOR_SIZES_ CURSOR_SIZEE_ CURSOR_SIZEW_ CURSOR_SIZENE_ CURSOR_SIZESE_  CURSOR_SIZESW_ CURSOR_SIZENW_ CURSOR_UPARROW_ CURSOR_IBEAM_ CURSOR_NO_ CURSOR_HAND      Note: Only one of the above styles may be specified.    See Also:  Cursor snippets_  Sample code and further information    
114,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/DeviceData.html,extends Object    
115,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/FontMetrics.html,extends Object Instances of this class provide measurement information  about fonts including ascent_ descent_ height_ leading  space between rows_ and average character width.  FontMetrics are obtained from GCs  using the getFontMetrics() method.  See Also:  GC.getFontMetrics()_  Sample code and further information    
116,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Canvas.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Composite Instances of this class provide a surface for drawing  arbitrary graphics.  Styles:  (none)  Events:  (none)    This class may be subclassed by custom control implementors  who are building controls that are not constructed  from aggregates of other controls. That is_ they are either  painted using SWT graphics calls or are handled by native  methods.    See Also:  Composite_  Canvas snippets_  SWT Example: ControlExample_  Sample code and further information    "
117,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/ImageLoaderListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the incremental loading of image data.     After creating an instance of a class that implements  this interface it can be added to an image loader using the  addImageLoaderListener method and removed using  the removeImageLoaderListener method. When  image data is either partially or completely loaded_ this  method will be invoked.    See Also:  ImageLoader_  ImageLoaderEvent    
118,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/ImageLoaderEvent.html,extends org.eclipse.swt.internal.SWTEventObject Instances of this class are sent as a result of the incremental  loading of image data.    Notes:    The number of events which will be sent when loading images  is not constant. It varies by image type_ and for JPEG images it   varies from image to image.  For image sources which contain multiple images_ the   endOfImage flag in the event will be set to true  after each individual image is loaded.  See Also:  ImageLoader_  ImageLoaderListener_  Sample code and further information_  Serialized Form    
119,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Region.html,extends Resource Instances of this class represent areas of an x-y coordinate  system that are aggregates of the areas covered by a number  of polygons.    Application code must explicitly invoke the Region.dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    See Also:  SWT Example: GraphicsExample_  Sample code and further information    
120,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/TextLayout.html,extends Resource TextLayout is a graphic object that represents  styled text.    Instances of this class provide support for drawing_ cursor  navigation_ hit testing_ text wrapping_ alignment_ tab expansion  line breaking_ etc. These are aspects required for rendering internationalized text.    Application code must explicitly invoke the TextLayout#dispose()   method to release the operating system resources managed by each instance  when those instances are no longer required.    Since:  3.0  See Also:  TextLayout_ TextStyle snippets_  SWT Example: CustomControlExample_ StyledText tab_  Sample code and further information    
121,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/TextStyle.html,extends Object TextStyle defines a set of styles that can be applied  to a range of text.    The hashCode() method in this class uses the values of the public  fields to compute the hash value. When storing instances of the  class in hashed collections_ do not modify these fields after the  object has been inserted.       Application code does not need to explicitly release the  resources managed by each instance when those instances are no longer  required_ and thus no dispose() method is provided.    Since:  3.0  See Also:  TextLayout_  Font_  Color_  TextLayout_ TextStyle snippets_  Sample code and further information    
122,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FormAttachment.html,"extends Object Instances of this class are used to define the edges of a control  within a FormLayout.     FormAttachments are set into the top_ bottom_ left_  and right fields of the FormData for a control.  For example:    FormData data = new FormData();  data.top = new FormAttachment(0_5);  data.bottom = new FormAttachment(100_-5);  data.left = new FormAttachment(0_5);  data.right = new FormAttachment(100_-5);  button.setLayoutData(data);        A FormAttachment defines where to attach the side of  a control by using the equation_ y = ax + b. The ""a"" term represents   a fraction of the parent composite's width (from the left) or height  (from the top). It can be defined using a numerator and denominator_  or just a percentage value. If a percentage is used_ the denominator   is set to 100. The ""b"" term in the equation represents an offset_ in  pixels_ from the attachment position. For example:    FormAttachment attach = new FormAttachment (20_ -5);    specifies that the side to which the FormAttachment  object belongs will lie at 20% of the parent composite_ minus 5 pixels.      Control sides can also be attached to another control.  For example:    FormAttachment attach = new FormAttachment (button_ 10);    specifies that the side to which the FormAttachment  object belongs will lie in the same position as the adjacent side of   the button control_ plus 10 pixels. The control side can   also be attached to the opposite side of the specified control.  For example:    FormData data = new FormData ();  data.left = new FormAttachment (button_ 0_ SWT.LEFT);    specifies that the left side of the control will lie in the same position  as the left side of the button control. The control can also   be attached in a position that will center the control on the specified   control. For example:    data.left = new FormAttachment (button_ 0_ SWT.CENTER);    specifies that the left side of the control will be positioned so that it is  centered between the left and right sides of the button control.  If the alignment is not specified_ the default is to attach to the adjacent side.    Since:  2.0  See Also:  FormLayout_  FormData_  Sample code and further information    "
123,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/GridData.html,extends Object GridData is the layout data object associated with   GridLayout. To set a GridData object into a   control_ you use the Control.setLayoutData(Object) method.     There are two ways to create a GridData object with certain   fields set. The first is to set the fields directly_ like this:    GridData gridData = new GridData();  gridData.horizontalAlignment = GridData.FILL;  gridData.grabExcessHorizontalSpace = true;  button1.setLayoutData(gridData);    gridData = new GridData();  gridData.horizontalAlignment = GridData.FILL;  gridData.verticalAlignment = GridData.FILL;  gridData.grabExcessHorizontalSpace = true;  gridData.grabExcessVerticalSpace = true;  gridData.horizontalSpan = 2;  button2.setLayoutData(gridData);    The second is to take advantage of GridData convenience constructors_ for example:     button1.setLayoutData(new GridData (SWT.FILL_ SWT.CENTER_ true_ false));  button2.setLayoutData(new GridData (SWT.FILL_ SWT.FILL_ true_ true_ 2_ 1));        NOTE: Do not reuse GridData objects. Every control in a   Composite that is managed by a GridLayout  must have a unique GridData object. If the layout data   for a control in a GridLayout is null at layout time_   a unique GridData object is created for it.    See Also:  GridLayout_  Control.setLayoutData(java.lang.Object)_  Sample code and further information    
124,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/program/Program.html,extends Object Instances of this class represent programs and  their associated file extensions in the operating  system.  See Also:  Program snippets_  Sample code and further information    
125,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ControlListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated by moving  and resizing controls.     After creating an instance of a class that implements  this interface it can be added to a control using the  addControlListener method and removed using  the removeControlListener method. When a  control is moved or resized_ the appropriate method will  be invoked.    See Also:  ControlAdapter_  ControlEvent    
126,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/FocusListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated as controls  gain and lose focus.    After creating an instance of a class that implements  this interface it can be added to a control using the  addFocusListener method and removed using  the removeFocusListener method. When a  control gains or loses focus_ the appropriate method  will be invoked.    See Also:  FocusAdapter_  FocusEvent    
127,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/HelpListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the event that is generated when help is  requested for a control_ typically when the user presses F1.    After creating an instance of a class that implements  this interface it can be added to a control using the  addHelpListener method and removed using  the removeHelpListener method. When help  is requested for a control_ the helpRequested method  will be invoked.    See Also:  HelpEvent    
128,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/KeyListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated as keys  are pressed on the system keyboard.    After creating an instance of a class that implements  this interface it can be added to a control using the  addKeyListener method and removed using  the removeKeyListener method. When a  key is pressed or released_ the appropriate method will  be invoked.    See Also:  KeyAdapter_  KeyEvent    
129,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated as mouse buttons  are pressed.    After creating an instance of a class that implements  this interface it can be added to a control using the  addMouseListener method and removed using  the removeMouseListener method. When a  mouse button is pressed or released_ the appropriate method  will be invoked.    See Also:  MouseAdapter_  MouseEvent    
130,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseMoveListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the events that are generated as the mouse  pointer moves.    After creating an instance of a class that implements  this interface it can be added to a control using the  addMouseMoveListener method and removed using  the removeMouseMoveListener method. As the  mouse moves_ the mouseMove method will be invoked.    See Also:  MouseEvent    
131,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseTrackListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated as the mouse  pointer passes (or hovers) over controls.    After creating an instance of a class that implements  this interface it can be added to a control using the  addMouseTrackListener method and removed using  the removeMouseTrackListener method. When the  mouse pointer passes into or out of the area of the screen  covered by a control or pauses while over a control_ the  appropriate method will be invoked.    See Also:  MouseTrackAdapter_  MouseEvent    
132,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/PaintListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated when the  control needs to be painted.     After creating an instance of a class that implements  this interface it can be added to a control using the  addPaintListener method and removed using  the removePaintListener method. When a  paint event occurs_ the paintControl method will be  invoked.    See Also:  PaintEvent    
133,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/TraverseListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the events that are generated when a  traverse event occurs in a control.    After creating an instance of a class that implements  this interface it can be added to a control using the  addTraverseListener method and removed using  the removeTraverseListener method. When a  traverse event occurs in a control_ the keyTraversed method  will be invoked.    See Also:  TraverseEvent    
134,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Monitor.html,extends Object Instances of this class are descriptions of monitors.  Since:  3.0  See Also:  Display_  Monitor snippets_  Sample code and further information    
135,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Menu.html,extends Widget Instances of this class are user interface objects that contain  menu items.  Styles:  BAR_ DROP_DOWN_ POP_UP_ NO_RADIO_GROUP  LEFT_TO_RIGHT_ RIGHT_TO_LEFT  Events:  Help_ Hide_ Show     Note: Only one of BAR_ DROP_DOWN and POP_UP may be specified.  Only one of LEFT_TO_RIGHT or RIGHT_TO_LEFT may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Menu snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
136,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Widget.html,extends Object This class is the abstract superclass of all user interface objects.   Widgets are created_ disposed and issue notification to listeners  when events occur which affect them.  Styles:  (none)  Events:  Dispose    IMPORTANT: This class is intended to be subclassed only  within the SWT implementation. However_ it has not been marked  final to allow those outside of the SWT development team to implement  patched versions of the class in order to get around specific  limitations in advance of when those limitations can be addressed  by the team. Any class built using subclassing to access the internals  of this class will likely fail to compile or run between releases and  may be strongly platform specific. Subclassing should not be attempted  without an intimate and detailed understanding of the workings of the  hierarchy. No support is provided for user-written classes which are  implemented as subclasses of this class.    See Also:  checkSubclass()_  Sample code and further information    
137,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Dialog.html,"extends Object This class is the abstract superclass of the classes  that represent the built in platform dialogs.  A Dialog typically contains other widgets  that are not accessible. A Dialog is not  a Widget.    This class can also be used as the abstract superclass  for user-designed dialogs. Such dialogs usually consist  of a Shell with child widgets. The basic template for a  user-defined dialog typically looks something like this:    public class MyDialog extends Dialog {  Object result;    public MyDialog (Shell parent_ int style) {  super (parent_ style);  }  public MyDialog (Shell parent) {  this (parent_ 0); // your default style bits go here (not the Shell's style bits)  }  public Object open () {  Shell parent = getParent();  Shell shell = new Shell(parent_ SWT.DIALOG_TRIM | SWT.APPLICATION_MODAL);  shell.setText(getText());  // Your code goes here (widget creation_ set result_ etc).  shell.open();  Display display = parent.getDisplay();  while (!shell.isDisposed()) {  if (!display.readAndDispatch()) display.sleep();  }  return result;  }  }      Note: The modality styles supported by this class  are treated as HINTs_ because not all are supported  by every subclass on every platform. If a modality style is  not supported_ it is ""upgraded"" to a more restrictive modality  style that is supported. For example_ if PRIMARY_MODAL  is not supported by a particular dialog_ it would be upgraded to   APPLICATION_MODAL. In addition_ as is the case  for shells_ the window manager for the desktop on which the  instance is visible has ultimate control over the appearance  and behavior of the instance_ including its modality.    Styles:  APPLICATION_MODAL_ PRIMARY_MODAL_ SYSTEM_MODAL_ SHEET  Events:  (none)    Note: Only one of the styles APPLICATION_MODAL_ PRIMARY_MODAL_  and SYSTEM_MODAL may be specified.    See Also:  Shell_  SWT Example: ControlExample_  Sample code and further information    "
138,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ExpandListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the expanding and collapsing of ExpandItems.    After creating an instance of a class that implements  this interface it can be added to a ExpandBar   control using the addExpandListener method and  removed using the removeExpandListener method.   When a item of the ExpandBar is expanded or  collapsed_ the appropriate method will be invoked.    Since:  3.2  See Also:  ExpandAdapter_  ExpandEvent    
139,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/FileDialog.html,extends Dialog Instances of this class allow the user to navigate  the file system and select or enter a file name.  Styles:  SAVE_ OPEN_ MULTI  Events:  (none)    Note: Only one of the styles SAVE and OPEN may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  FileDialog snippets_  SWT Example: ControlExample_ Dialog tab_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
140,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MenuDetectListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated when the  platform-specific trigger for showing a context menu is  detected.    After creating an instance of a class that implements  this interface it can be added to a control or TrayItem  using the addMenuDetectListener method and  removed using the removeMenuDetectListener method.  When the context menu trigger occurs_ the  menuDetected method will be invoked.    Since:  3.3  See Also:  MenuDetectEvent    
141,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ArmListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the event that is generated when a widget_  such as a menu item_ is armed.    After creating an instance of a class that implements  this interface it can be added to a widget using the  addArmListener method and removed using  the removeArmListener method. When the  widget is armed_ the widgetArmed method will be invoked.    See Also:  ArmEvent    
142,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/TreeListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the expanding and collapsing of tree  branches.    After creating an instance of a class that implements  this interface it can be added to a tree control using the  addTreeListener method and removed using  the removeTreeListener method. When a branch  of the tree is expanded or collapsed_ the appropriate method  will be invoked.    See Also:  TreeAdapter_  TreeEvent    
143,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/GCData.html,extends Object Instances of this class are descriptions of GCs in terms  of unallocated platform-specific data fields.    IMPORTANT: This class is not part of the public  API for SWT. It is marked public only so that it can be shared  within the packages provided by SWT. It is not available on all  platforms_ and should never be called from application code.    See Also:  Sample code and further information  Restriction:  This class is not intended to be referenced by clients    
144,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/DisposeListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the event that is generated when a widget  is disposed.    After creating an instance of a class that implements  this interface it can be added to a widget using the  addDisposeListener method and removed using  the removeDisposeListener method. When a  widget is disposed_ the widgetDisposed method will  be invoked.    See Also:  DisposeEvent    
145,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MenuListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the hiding and showing of menus.    After creating an instance of a class that implements  this interface it can be added to a menu using the  addMenuListener method and removed using  the removeMenuListener method. When the  menu is hidden or shown_ the appropriate method will  be invoked.    See Also:  MenuAdapter_  MenuEvent    
146,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ShellListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with changes in state of Shells.    After creating an instance of a class that implements  this interface it can be added to a shell using the  addShellListener method and removed using  the removeShellListener method. When the  state of the shell changes_ the appropriate method will  be invoked.    See Also:  ShellAdapter_  ShellEvent    
147,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Tree.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Composite Instances of this class provide a selectable user interface object  that displays a hierarchy of items and issues notification when an  item in the hierarchy is selected.    The item children that may be added to instances of this class  must be of type TreeItem.    Style VIRTUAL is used to create a Tree whose  TreeItems are to be populated by the client on an on-demand basis  instead of up-front. This can provide significant performance improvements for  trees that are very large or for which TreeItem population is  expensive (for example_ retrieving values from an external source).    Here is an example of using a Tree with style VIRTUAL:    final Tree tree = new Tree(parent_ SWT.VIRTUAL | SWT.BORDER);  tree.setItemCount(20);  tree.addListener(SWT.SetData_ new Listener() {  public void handleEvent(Event event) {  TreeItem item = (TreeItem)event.item;  TreeItem parentItem = item.getParentItem();  String text = null;  if (parentItem == null) {  text = ""node "" + tree.indexOf(item);  } else {  text = parentItem.getText() + "" - "" + parentItem.indexOf(item);  }  item.setText(text);  System.out.println(text);  item.setItemCount(10);  }  });      Note that although this class is a subclass of Composite_  it does not normally make sense to add Control children to  it_ or set a layout on it_ unless implementing something like a cell  editor.      Styles:  SINGLE_ MULTI_ CHECK_ FULL_SELECTION_ VIRTUAL_ NO_SCROLL  Events:  Selection_ DefaultSelection_ Collapse_ Expand_ SetData_ MeasureItem_ EraseItem_ PaintItem    Note: Only one of the styles SINGLE and MULTI may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Tree_ TreeItem_ TreeColumn snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
148,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TreeItem.html,extends Item Instances of this class represent a selectable user interface object  that represents a hierarchy of tree items in a tree widget.    Styles:  (none)  Events:  (none)    IMPORTANT: This class is not intended to be subclassed.    See Also:  Tree_ TreeItem_ TreeColumn snippets_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
149,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/MenuItem.html,extends Item Instances of this class represent a selectable user interface object  that issues notification when pressed and released.   Styles:  CHECK_ CASCADE_ PUSH_ RADIO_ SEPARATOR  Events:  Arm_ Help_ Selection    Note: Only one of the styles CHECK_ CASCADE_ PUSH_ RADIO and SEPARATOR  may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
150,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/DragDetectListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that deal with the events that are generated when a drag  gesture is detected.    After creating an instance of a class that implements  this interface it can be added to a control using the  addDragDetectListener method and removed using  the removeDragDetectListener method. When the  drag is detected_ the drageDetected method will be invoked.    Since:  3.3  See Also:  DragDetectEvent    
151,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseWheelListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method  that deals with the event that is generated as the mouse  wheel is scrolled.    After creating an instance of a class that implements  this interface it can be added to a control using the  addMouseWheelListener method and removed using  the removeMouseWheelListener method. When the  mouse wheel is scrolled the mouseScrolled method  will be invoked.    Since:  3.3  See Also:  MouseEvent    
152,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/MessageBox.html,extends Dialog Instances of this class are used to inform or warn the user.  Styles:  ICON_ERROR_ ICON_INFORMATION_ ICON_QUESTION_ ICON_WARNING_ ICON_WORKING  OK_ OK | CANCEL  YES | NO_ YES | NO | CANCEL  RETRY | CANCEL  ABORT | RETRY | IGNORE  Events:  (none)    Note: Only one of the styles ICON_ERROR_ ICON_INFORMATION_ ICON_QUESTION_  ICON_WARNING and ICON_WORKING may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  SWT Example: ControlExample_ Dialog tab_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    
153,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Label.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Control Instances of this class represent a non-selectable  user interface object that displays a string or image.  When SEPARATOR is specified_ displays a single  vertical or horizontal line.    Shadow styles are hints and may not be honored  by the platform. To create a separator label  with the default shadow style for the platform_  do not specify a shadow style.    Styles:  SEPARATOR_ HORIZONTAL_ VERTICAL  SHADOW_IN_ SHADOW_OUT_ SHADOW_NONE  CENTER_ LEFT_ RIGHT_ WRAP  Events:  (none)    Note: Only one of SHADOW_IN_ SHADOW_OUT and SHADOW_NONE may be specified.  SHADOW_NONE is a HINT. Only one of HORIZONTAL and VERTICAL may be specified.  Only one of CENTER_ LEFT and RIGHT may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Label snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "
154,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/GridLayout.html,extends Layout Instances of this class lay out the control children of a   Composite in a grid.     GridLayout has a number of configuration fields_ and the   controls it lays out can have an associated layout data object_ called   GridData. The power of GridLayout lies in the   ability to configure GridData for each control in the layout.       The following code creates a shell managed by a GridLayout  with 3 columns:    Display display = new Display();  Shell shell = new Shell(display);  GridLayout gridLayout = new GridLayout();  gridLayout.numColumns = 3;  shell.setLayout(gridLayout);    The numColumns field is the most important field in a   GridLayout. Widgets are laid out in columns from left   to right_ and a new row is created when numColumns + 1   controls are added to the Composite.    See Also:  GridData_  GridLayout snippets_  SWT Example: LayoutExample_  Sample code and further information    
155,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleActionListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that handle AccessibleAction events.    After creating an instance of a class that implements  this interface it can be added to an accessible using the  addAccessibleActionListener method and removed using  the removeAccessibleActionListener method.    Since:  3.6  See Also:  AccessibleActionAdapter_  AccessibleActionEvent    
156,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleHyperlinkListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that handle AccessibleHyperlink events.    After creating an instance of a class that implements  this interface it can be added to an accessible using the  addAccessibleHyperlinkListener method and removed using  the removeAccessibleHyperlinkListener method.    Since:  3.6  See Also:  AccessibleHyperlinkAdapter_  AccessibleHyperlinkEvent    
157,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleTableListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that handle AccessibleTable events.    After creating an instance of a class that implements  this interface it can be added to an accessible using the  addAccessibleTableListener method and removed using  the removeAccessibleTableListener method.    Many methods in this listener return cell accessible objects_  which should implement AccessibleTableCellListener.    Since:  3.6  See Also:  AccessibleTableAdapter_  AccessibleTableEvent_  AccessibleTableCellListener_  AccessibleTableCellEvent    
158,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleTableCellListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that handle AccessibleTableCell events.    After creating an instance of a class that implements  this interface it can be added to an accessible using the  addAccessibleTableCellListener method and removed using  the removeAccessibleTableCellListener method.    Since:  3.6  See Also:  AccessibleTableCellAdapter_  AccessibleTableCellEvent    
159,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleValueListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that handle AccessibleValue events.    After creating an instance of a class that implements  this interface it can be added to an accessible using the  addAccessibleValueListener method and removed using  the removeAccessibleValueListener method.    Since:  3.6  See Also:  AccessibleValueAdapter_  AccessibleValueEvent    
160,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleAttributeListener.html,extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods  that handle AccessibleAttribute events.    After creating an instance of a class that implements  this interface it can be added to an accessible using the  addAccessibleAttributeListener method and removed using  the removeAccessibleAttributeListener method.    Since:  3.6  See Also:  AccessibleAttributeAdapter_  AccessibleAttributeEvent_  AccessibleTextAttributeEvent    
161,http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Table.html,"Implementers of Drawable can have a graphics context (GC)  created for them_ and then they can be drawn on by sending messages to  their associated GC. SWT images_ and device objects such as the Display  device and the Printer device_ are drawables.    IMPORTANT: This interface is not part of the SWT  public API. It is marked public only so that it can be shared  within the packages provided by SWT. It should never be  referenced from application code.    See Also:  Device_  Image_  GC     extends Composite Instances of this class implement a selectable user interface  object that displays a list of images and strings and issues  notification when selected.    The item children that may be added to instances of this class  must be of type TableItem.    Style VIRTUAL is used to create a Table whose  TableItems are to be populated by the client on an on-demand basis  instead of up-front. This can provide significant performance improvements for  tables that are very large or for which TableItem population is  expensive (for example_ retrieving values from an external source).    Here is an example of using a Table with style VIRTUAL:    final Table table = new Table (parent_ SWT.VIRTUAL | SWT.BORDER);  table.setItemCount (1000000);  table.addListener (SWT.SetData_ new Listener () {  public void handleEvent (Event event) {  TableItem item = (TableItem) event.item;  int index = table.indexOf (item);  item.setText (""Item "" + index);  System.out.println (item.getText ());  }  });       Note that although this class is a subclass of Composite_  it does not normally make sense to add Control children to  it_ or set a layout on it_ unless implementing something like a cell  editor.      Styles:  SINGLE_ MULTI_ CHECK_ FULL_SELECTION_ HIDE_SELECTION_ VIRTUAL_ NO_SCROLL  Events:  Selection_ DefaultSelection_ SetData_ MeasureItem_ EraseItem_ PaintItem    Note: Only one of the styles SINGLE_ and MULTI may be specified.    IMPORTANT: This class is not intended to be subclassed.    See Also:  Table_ TableItem_ TableColumn snippets_  SWT Example: ControlExample_  Sample code and further information  Restriction:  This class is not intended to be subclassed by clients.    "